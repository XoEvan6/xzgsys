<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>一个小手机</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
	<style>
        /* --- 主题与全局 --- */
        :root {
            --bg-color: #f0f2f5; --phone-bg: #F8F9FA; --primary-text: #1d2129;
            --secondary-text: #8a8d91; --accent-color: #007AFF; --border-color: #dee2e6;
            --bubble-user: #007AFF; --bubble-user-text: #ffffff; --bubble-ai: #E9ECEF;
            --bubble-ai-text: #1d2129; --page-transition-duration: 0.3s;
			--bg-color-secondary: #ffffff; /* 卡片背景色 (白色) */
            --bg-color-tertiary: #f8f9fa;  /* 悬停/高亮背景色 (淡灰色) */
            --tertiary-text: #adb5bd;      
			--header-bg-rgb: 255, 255, 255;
        }
		
		/* --- 推荐的全局设置 --- */
		* {
		    box-sizing: border-box;
		}


                /* --- 基础布局 --- */
       /* --- 基础布局 (无边框修正版) --- */
       html {
           height: 100%;
		   overflow: hidden; /* <-- 非常重要！禁止html和body滚动 */
    overscroll-behavior: contain; /* <-- 锦上添花，防止滚动穿透 */
       }
       body { 
           background-color: var(--bg-color); 
           font-family: 'Inter', sans-serif; 
           height: 100%;
           margin: 0;
           overscroll-behavior: contain;
		   overflow: hidden; /* <-- 非常重要！禁止html和body滚动 */
       }
       
       .phone-container {
           width: 100%;
           height: 100%;/* 使用 vh 单位，直接获取视口高度 */
           background: none;
           padding: 0;
           box-shadow: none;
       }.phone-body { background: var(--phone-bg); width: 100%; height: 100%; border-radius: 0; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        
        /* --- 页面导航 --- */
        /* --- 页面导航 (修改为淡入淡出效果) --- */
        .page-stack { 
    position: relative; 
    width: 100%; 
    flex: 1; /* 使用此复合属性替换 height 和 flex-grow */
    min-height: 0; /* 【重要】添加此行以增强布局稳定性 */
}
        .page { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background-color: var(--phone-bg); 
            display: flex; 
            flex-direction: column; 
            /* 核心修改：过渡效果改为透明度和缩放 */
            transition: opacity var(--page-transition-duration) ease-in-out, 
                        transform var(--page-transition-duration) ease-in-out; 
            /* 默认状态：完全透明，不可点击 */
            opacity: 0; 
            pointer-events: none; 
            z-index: 1; 
        }
        .page.active { 
            /* active状态：完全不透明，恢复正常大小，可点击 */
            opacity: 1; 
            transform: scale(1);
            pointer-events: auto; 
            z-index: 2; /* 显示在最上层 */
        }
        .page.previous {
            /* 后退时，下层页面保持可见，但无交互 */
            opacity: 1;
            pointer-events: none;
            z-index: 1; 
            /* 可以加一个轻微的缩放，更有层次感 */
            transform: scale(0.98); 
        }


        /* --- 通用 UI --- */
       .app-header {
           /* 1. 将布局模式从 flex 改为 grid */
           display: grid;
           /* 2. 定义一个三列网格 */
           grid-template-columns: 1fr auto 1fr; /* 左中右三列 */
           align-items: center;
           padding: 12px 8px; /* 调整一下内边距 */
           flex-shrink: 0;
           border-bottom: 1px solid var(--border-color);
            background-color: rgba(var(--header-bg-rgb), 0.9);
           backdrop-filter: blur(10px);
		   position: relative;
		   z-index: 5; 

       }
	   .header-left, .header-right {
	       display: flex;
	       align-items: center;
	   }
	   .header-right {
	       justify-content: flex-end; /* 让右侧按钮靠右对齐 */
	   }
	   .app-header .back-btn, .app-header .action-btn { background: none; border: none; cursor: pointer; padding: 8px; }
        .app-header .back-btn { margin-left: -8px; }
        .app-header .action-btn { margin-right: 8px; }
      .app-header .title {
          /* 告诉标题去占据第二列（也就是中间那列） */
          grid-column: 2;
          
          /* 其他样式保持不变，但不再需要 flex-grow */
          font-weight: 600;
          font-size: 17px;
          color: var(--primary-text);
          text-align: center;
          
          /* 同样可以加上防止文字溢出的样式 */
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
      }
	  .svg-icon { width: 24px; height: 24px; color: var(--accent-color); }
        .page-content { flex: 1; overflow-y: auto; background-size: cover; background-position: center;position: relative; z-index: 1; min-height: 0; } 
		/* MODIFIED: Added background properties */

        /* --- 主屏幕 --- */
        #home-screen .page-content { padding: 40px 20px; }
        .app-list { list-style: none; padding: 0; margin: 0; }
        .app-list-item { display: flex; align-items: center; padding: 12px 20px; cursor: pointer; border-radius: 12px; margin-bottom: 12px; background-color: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        .app-list-item .icon-bg { width: 48px; height: 48px; border-radius: 12px; display: flex; justify-content: center; align-items: center; margin-right: 16px; flex-shrink: 0; }
        .app-list-item .icon-bg .svg-icon { color: #fff; }
        .app-list-item .info .name { font-weight: 500; font-size: 16px; color: var(--primary-text); }
        .app-list-item .info .desc { font-size: 14px; color: var(--secondary-text); }
        .app-list-item .chevron .svg-icon { color: var(--secondary-text); width: 20px; height: 20px; }

        /* --- 聊天界面 (V2.0 精致瘦身版) --- */
        #chat-page .page-content { 
            display: flex; 
            flex-direction: column; 
        }
        .chat-messages { 
            flex-grow: 1; 
            padding: 10px; /* 左右内边距可以稍微加大，让气泡不贴边 */
            overflow-y: auto; 
        }
        
        /* 1. 缩小消息行间距 */
        .message-row { 
            display: flex; 
            margin-bottom: 10px; /* 【缩小】从 12px 减少到 10px */
            align-items: flex-start; 
            gap: 8px; 
            position: relative; 
        }
        
        /* 2. 缩小头像 */
        .chat-avatar { 
            width: 36px;  /* 【缩小】从 40px 减少到 36px */
            height: 36px; /* 【缩小】从 40px 减少到 36px */
            border-radius: 50%;
            object-fit: cover; 
            flex-shrink: 0; 
        }
        
        .message-content { 
            display: flex; 
            flex-direction: column; 
            max-width: 80%;
            position: relative;  
            min-width: 0;
        }
        
        /* 3. 缩小气泡字体和内边距 */
        .chat-bubble { 
            padding: 8px 12px; /* 【缩小】从 10px 15px 减少到 8px 12px，气泡更紧凑 */
            border-radius: 16px; /* 圆角可以稍微减小一点 */
            word-wrap: break-word; 
            font-size: 14px;   /* 【核心缩小】从 15px 减少到 14px */
            line-height: 1.5;  /* 【缩小】行高也相应调整 */
            cursor: pointer; 
        }
        
        /* 4. 缩小引用片段的样式 */
        .reply-snippet {
            background: rgba(0,0,0,0.08); 
            padding: 6px 10px;    /* 【缩小】内边距 */
            margin-bottom: 6px;   /* 【缩小】与气泡内容的间距 */
            border-radius: 6px;
            font-size: 12px;      /* 【缩小】字体 */
            color: var(--secondary-text);
            border-left: 3px solid var(--accent-color);
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
        }
        .message-row.user .reply-snippet {
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.8);
            border-left-color: #fff;
        }
        
        /* 5. 调整气泡圆角和对齐（这部分不变，但很重要） */
        .message-row.user { justify-content: flex-end; }
        .message-row.user .message-content { align-items: flex-end; }
        .message-row.user .chat-bubble { background: var(--bubble-user); color: var(--bubble-user-text); border-bottom-right-radius: 5px; }
        
        .message-row.ai { justify-content: flex-start; }
        .message-row.ai .message-content { align-items: flex-start; }
        .message-row.ai .chat-bubble { background: var(--bubble-ai); color: var(--bubble-ai-text); border-bottom-left-radius: 5px; }
        
        /* 6. 缩小群聊成员名字 */
        .member-name { 
            font-size: 12px;  /* 【缩小】从 13px 减少到 12px */
            color: var(--secondary-text); 
            margin-bottom: 4px; 
            margin-left: 4px; 
        }

        /* 多样化消息样式 */
        .chat-bubble.bubble-image img { max-width: 100%; border-radius: 12px; display: block; }
        .chat-bubble.bubble-image { padding: 4px; }
        /* 输入区域 */
        .message-input-area { padding: 12px; border-top: 1px solid var(--border-color); background-color: rgba(var(--header-bg-rgb), 0.9); display: flex; flex-direction: column; gap: 8px; }
        .reply-bar { padding: 8px; background: var(--bubble-ai); border-radius: 8px; font-size: 13px; position: relative; }
        .reply-bar-close { position: absolute; top: 4px; right: 4px; cursor: pointer; }
        .input-wrapper { display: flex; align-items: flex-end; gap: 8px; }
.flexible-input {
    flex-grow: 1;
    border: 1px solid var(--border-color);
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--phone-bg);
    font-size: 16px;
    resize: none;
    max-height: 120px;
    box-sizing: border-box; /* 1.【核心】告诉浏览器padding和border都算在总宽高内 */
    line-height: 1.4;       /* 2.【微调】设置一个合适的行高，有助于稳定计算 */
    overflow-y: hidden;     /* 3.【关键】在JS接管滚动前，先隐藏默认的滚动条 */
}

/* 2. 【保留】为 #message-input 保留它可能需要的特定样式 (如果未来有的话) */
/* 如果这个大括号变成空的也没关系，先留着结构 */
#message-input {
    /* 之前 #message-input 里的所有样式都移到 .flexible-input 里了 */
}.input-action-btn { background: var(--accent-color); border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .input-action-btn.secondary { background-color: var(--bubble-ai); }
        .input-action-btn .svg-icon { color: #fff; width: 20px; height: 20px; }
        .input-action-btn.secondary .svg-icon { color: var(--primary-text); }
        #call-api-btn .spinner { border-top-color: #fff; width:20px; height:20px; border-width: 2px; }

        /* --- 表单 & 列表 & 设置 --- */
        .form-group { margin-bottom: 24px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--primary-text); }
        .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background: #fff; }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .avatar-upload-group { display: flex; align-items: center; gap: 16px; }
        .avatar-upload-group .avatar-preview { width: 64px; height: 64px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload-group .upload-btn { flex-grow: 1; padding: 10px; text-align: center; background: var(--bubble-ai); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; }
        .list-view { padding: 0; }
        .list-item { display: flex; align-items: center; padding: 16px; border-bottom: 1px solid var(--border-color); cursor: pointer; }
        .list-item .info { flex-grow: 1; }
        .list-item .info .name { font-weight: 500; }
        .list-item .info .name .group-icon { font-size: 12px; background: #eee; color: #555; padding: 2px 6px; border-radius: 4px; margin-left: 8px; vertical-align: middle; } /* ADDED: Group chat icon */


        /* --- 弹窗 & 菜单 --- */
        .toast { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.75); color: white; padding: 12px 20px; border-radius: 20px; font-size: 14px; z-index: 9999; opacity: 0; transition: opacity 0.3s, bottom 0.3s; pointer-events: none; }
        .toast.show { opacity: 1; bottom: 80px; }
        .context-menu { position: absolute; background: #fff; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); padding: 8px; z-index: 10000; min-width: 150px; }
        .context-menu-item { padding: 10px 12px; border-radius: 8px; cursor: pointer; }
        .context-menu-item:hover { background: var(--bubble-ai); }
        #modal-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; display: none; justify-content: center; align-items: center; }
        #modal-content { background: #fff; padding: 20px; border-radius: 16px; max-width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        
        /* --- 多选删除模式 --- */
        .multi-select-mode .message-row::before { content: ''; display: block; width: 20px; height: 20px; border: 2px solid var(--border-color); border-radius: 50%; position: absolute; left: -8px; top: 50%; transform: translateY(-50%); background: #fff; }
        .multi-select-mode .message-row.selected::before { background: var(--accent-color); border-color: var(--accent-color); background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E"); }
        .multi-select-bar { display: flex; padding: 12px; border-top: 1px solid var(--border-color); background: #fff; }
        .btn { display: block; width: 100%; padding:12px 0px 14px; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; color: white; cursor: pointer; text-align: center; position: relative; }
        .btn-primary { background-color: var(--accent-color); }
        .btn-secondary { background-color: #6c757d; margin-top: 15px; }
        .spinner { display: none; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.5); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { to { transform: rotate(360deg); } }
		/* --- 【全新】聊天操作菜单 (Action Sheet) --- */
		#show-actions-btn {
		    padding: 0; /* Reset padding for the plus button */
		}
		.action-sheet-overlay {
		    position: absolute;
		    top: 0;
		    left: 0;
		    width: 100%;
		    height: 100%;
		    background: rgba(0,0,0,0.4);
		    z-index: 1000;
		    opacity: 0;
		    pointer-events: none;
		    transition: opacity 0.3s ease-out;
		}
		.action-sheet-overlay.show {
		    opacity: 1;
		    pointer-events: auto;
		}
		.action-sheet {
		    position: absolute;
		    bottom: 0;
		    left: 0;
		    right: 0;
		    background-color: #f7f7f7;
		    border-radius: 20px 20px 0 0;
		    padding: 20px 20px 10px;
		    transform: translateY(100%);
		    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
		}
		.action-sheet-overlay.show .action-sheet {
		    transform: translateY(0);
		}
		.action-grid {
		    display: grid;
		    grid-template-columns: repeat(4, 1fr);
		    gap: 20px;
		    margin-bottom: 20px;
		}
		.action-item {
		    text-align: center;
		    cursor: pointer;
		}
		.action-icon {
		    width: 60px;
		    height: 60px;
		    background-color: #ffffff;
		    border-radius: 15px;
		    display: flex;
		    justify-content: center;
		    align-items: center;
		    margin: 0 auto 8px;
		    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
		}
		.action-icon .svg-icon {
		    width: 28px;
		    height: 28px;
		    color: var(--primary-text);
		}
		.action-label {
		    font-size: 13px;
		    color: var(--secondary-text);
		}
		.action-sheet-cancel {
		    width: 100%;
		    padding: 14px 0 14px;
		    text-align: center;
		    font-size: 17px;
		    font-weight: 500;
		    background-color: #ffffff;
		    border-radius: 12px;
		    cursor: pointer;
		    margin-top: 10px;
		}
		/* --- 【美化】日记 App 样式 --- */
		.diary-card-item {
		    background-color: #ffffff;
		    margin: 0 15px 12px;
		    border-radius: 12px;
		    box-shadow: 0 3px 10px rgba(0,0,0,0.06);
		    display: flex;
		    align-items: center;
		    padding: 16px;
		    gap: 16px;
		    cursor: pointer;
		    transition: transform 0.2s, box-shadow 0.2s;
		}
		.diary-card-item:hover {
		    transform: translateY(-2px);
		    box-shadow: 0 5px 15px rgba(0,0,0,0.08);
		}
		.diary-card-icon {
		    flex-shrink: 0;
		    width: 48px;
		    height: 48px;
		    border-radius: 12px;
		    display: flex;
		    justify-content: center;
		    align-items: center;
		    background-color: #eef1f5; /* 使用一个柔和的背景色 */
		}
		.diary-card-icon .svg-icon {
		    color: #8a8d91; /* 图标颜色 */
		}
		.diary-card-info {
		    flex-grow: 1;
		    overflow: hidden;
		}
		.diary-card-info .name {
		    font-weight: 500;
		    font-size: 16px;
		    color: var(--primary-text);
		}
		.diary-card-info .subtext {
		    font-size: 14px;
		    color: var(--secondary-text);
		    white-space: nowrap;
		    overflow: hidden;
		    text-overflow: ellipsis;
		}
/* --- 日记功能样式 (混合风格最终版) --- */
#diary-entry-page .page-content {
    background-color: var(--bg-color); /* 1. 保持简洁的浅灰背景 */
    padding: 20px;
    overflow-y: auto;
}
.diary-entry-container {
    background-color: #ffffff; /* 2. 干净的白色卡片 */
    border-radius: 12px;
    padding: 25px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
}
.diary-date {
    font-family: 'Inter', sans-serif; /* 3. 日期使用清晰的系统字体 */
    font-size: 18px;
    font-weight: 600;
    color: var(--primary-text);
    padding-bottom: 15px;
    border-bottom: 1px solid var(--border-color); /* 4. 纤细的分割线 */
    margin-bottom: 25px;
}
.diary-date::after {
    display: none; /* 5. 确认移除胶带装饰 */
}
.diary-content {
    font-family: 'Ma Shan Zheng', cursive; /* 6. 【核心】正文换回手写字体 */
    font-size: 21px;                  /* 7. 调整为舒适的手写字号 */
    line-height: 1.9;                 /* 8. 保持较大的行距，模仿手写习惯 */
    color: #3a3a3a;                   /* 9. 使用更像墨水颜色的深灰色 */
    white-space: pre-wrap;
    text-indent: 2em;                 /* 10. 保留首行缩进，更有“文章”的感觉 */
}
/* 11. 【核心】移除旧的红色悬浮删除按钮样式 */
.diary-delete-btn {
   display: none;
}
/* --- 朋友圈样式 --- */
#moments-page .page-content {
    /* 【修改】移除顶部内边距，让头图能顶到最上面 */
    padding-top: 0; 
    background-color: #fff;
	position: relative;
}
.moment-comment .replied-to-author {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin: 0 4px; /* 和"回复"字样拉开一点距离 */
}

.moment-card {
    /* 这部分样式保持不变 */
    position: relative;
    margin: 0 0 25px 0;
    padding: 0 15px;
    border-bottom: 8px solid #f0f2f5;
    padding-bottom: 15px;
}
.moment-card:last-child { border-bottom: none; }
/* ... (其他 .moment- 开头的样式保持不变) ... */
.moment-delete-btn {
   position: absolute;
   top: 15px;
   right: 15px;
   background: none;
   border: none;
   cursor: pointer;
   padding: 5px;
   opacity: 0.5;
   transition: opacity 0.2s;
}
.moment-delete-btn:hover { opacity: 1; }
.moment-delete-btn .svg-icon {
   width: 20px;
   height: 20px;
   color: var(--secondary-text);
}
.moment-header {
   display: flex;
   align-items: center;
   gap: 12px;
   margin-bottom: 12px;
}
.moment-header .avatar {
   width: 44px;
   height: 44px;
   border-radius: 50%;
   object-fit: cover;
}
.moment-header .info { flex-grow: 1; }
.moment-header .name {
   font-weight: 600;
   font-size: 16px;
   color: var(--primary-text);
}
.moment-header .timestamp {
   font-size: 12px;
   color: var(--secondary-text);
}
.moment-content p {
   font-size: 16px;
   line-height: 1.6;
   color: var(--primary-text);
   white-space: pre-wrap;
   margin: 0 0 12px 0;
}
.moment-image { margin-bottom: 12px; }
.moment-image img {
   max-width: 100%;
   border-radius: 12px;
   display: block;
}
.moment-actions {
   display: flex;
   justify-content: flex-end;
   gap: 10px;
   margin-bottom: 10px;
}
.moment-action-btn {
   background: #f0f2f5;
   border: none;
   border-radius: 20px;
   padding: 6px 12px;
   cursor: pointer;
   display: flex;
   align-items: center;
   gap: 6px;
   font-size: 14px;
   font-weight: 500;
}
.moment-action-btn .svg-icon {
   width: 18px;
   height: 18px;
}
.moment-action-btn.liked .svg-icon {
   fill: #E53935;
   stroke: #E53935;
}
.moment-interactions {
   background-color: #f0f2f5;
   border-radius: 8px;
   padding: 2px 12px;
}
.moment-likes {
   display: flex;
   align-items: center;
   gap: 8px;
   padding: 8px 0;
   font-size: 14px;
   color: var(--accent-color);
   font-weight: 500;
}
.moment-likes .svg-icon {
   width: 16px;
   height: 16px;
   color: var(--accent-color);
   flex-shrink: 0;
}
.moment-likes span {
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
}
.moment-comments-container {
   padding: 8px 0;
   border-top: 1px solid #e0e2e5;
}
.moment-comment {
   font-size: 14px;
   line-height: 1.5;
   margin-bottom: 4px;
}
.moment-comment .comment-author {
   font-weight: 600;
   color: var(--accent-color);
   cursor: pointer;
}

/* --- 【全新】朋友圈主页头图及悬浮按钮样式 --- */
.moments-profile-header {
    position: relative;
    /* 【修改】让头图区域和下面的内容分开 */
    margin-bottom: 40px; 
    cursor: pointer;
}
.profile-cover-image {
    width: 100%;
    height: 280px; /* 【修改】增加高度以容纳按钮和信息 */
    background-color: #ccc;
    background-size: cover;
    background-position: center;
    /* 【修改】移除圆角，让它填满顶部 */
}

/* 【新增】悬浮按钮的通用样式 */
.moments-floating-btn {
    position: fixed;
    top: 35px; /* 【修改】调整位置，避开顶部状态栏 */
    z-index: 15;
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    justify-content: center;
    align-items: center;
    border: none;
    backdrop-filter: blur(5px);
}
.moments-floating-btn .svg-icon {
    color: #fff;
    width: 22px;
    height: 22px;
}
.moments-back-btn {
    left: 15px;
}
.moments-camera-btn {
    right: 15px;
}

/* 【修改】个人信息区域的样式 */
.profile-info {
    position: absolute;
    bottom: -20px;
    right: 15px;
    display: flex;
    align-items: flex-end; /* 【修改】让文本和头像底部对齐 */
    gap: 15px;
}
/* 【新增】名字和签名的容器 */
.profile-text-content {
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* 文字右对齐 */
}
.profile-name {
    font-size: 20px; /* 字体可以稍大一些 */
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    margin-bottom: 8px; /* 和签名拉开距离 */
}
.profile-avatar {
    width: 80px; /* 尺寸可以稍大一些 */
    height: 80px;
    border-radius: 12px;
    border: 4px solid #fff;
    object-fit: cover;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
/* 【修改】签名的样式，现在它在名字下方 */
.profile-signature {
    font-size: 14px;
    color: gray; /* 【修改】使用主要文字颜色，也就是黑色 */
    text-shadow: 0 1px 2px rgba(255,255,255,0.7); /* 【修改】阴影改为浅色，在深色背景上更清晰 */
    max-width: 200px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}


      /* --- 滚动条强制隐藏 (终极版) --- */
      /* 针对所有 Webkit 内核的浏览器 (Chrome, Safari, Edge, etc.) */
      ::-webkit-scrollbar {
          display: none;
          width: 0 !important; /* 强制宽度为0 */
          height: 0 !important; /* 强制高度为0 */
      }
      
      /* 针对 Firefox */
      * {
          scrollbar-width: none;
      }
      
      /* 针对 IE 和老版 Edge */
      * {
          -ms-overflow-style: none;
      }
     /* --- 音乐播放器样式 --- */
     
     .music-info {
         flex-grow: 1;
         overflow: hidden;
         white-space: nowrap;
     }
     
     .music-info .title {
         font-size: 14px;
         font-weight: 500;
         color: var(--primary-text);
     }
     
     .lyrics-container {
         font-size: 12px;
         color: var(--secondary-text);
         margin-top: 2px;
         position: relative;
         height: 16px; /* 固定高度 */
     }
     
     .music-controls button {
         background: none;
         border: none;
         cursor: pointer;
         padding: 4px;
     }
     .music-controls .svg-icon {
         width: 20px;
         height: 20px;
         color: var(--primary-text);
     }
	 .player-btn svg {
	     vertical-align: middle; /* 让图标垂直居中 */
	     width: 1em; /* 大小与文字基本一致 */
	     height: 1em;
	     fill: currentColor; /* 颜色继承按钮的文字颜色 */
	 }

     /* 音乐管理弹窗的样式 */
     .music-playlist-item {
         display: flex; justify-content: space-between; align-items: center;
         padding: 8px; border-bottom: 1px solid #eee;
     }
     .music-playlist-item .song-info { flex-grow: 1; cursor: pointer; }
     .music-playlist-item .song-title { font-weight: 500; }
     .music-playlist-item .song-artist { font-size: 12px; color: #888; }
     .music-playlist-item .delete-song-btn { color: #E53935; }


/* 【新增】聊天列表头像样式 */
.chat-list-avatar {
    width: 52px;
    height: 52px;
    border-radius: 12px; /* 方形圆角头像 */
    margin-right: 16px;
    object-fit: cover;
    flex-shrink: 0;
    background-color: #ccc; /* 图片加载前的占位颜色 */
}
/* --- 新增：消息时间戳样式 --- */
.message-timestamp {
    font-size: 12px;
    color: var(--secondary-text);
    margin: 0 4px;
    flex-shrink: 0; /* 防止被压缩 */
    align-self: flex-end; /* 关键：让自身在交叉轴（垂直方向）上对齐到底部 */
    padding-bottom: 5px; /* 微调：增加一点内边距，让文字的底部和气泡的圆角看起来更协调 */
}
/* --- 聊天列表置顶样式 --- */
.chat-list-item.is-pinned {
    background-color: #f0f2f5; 
}
/* --- 新增：状态栏样式 --- */
.status-bar {
	display: none; 
    padding: 18px 30px 8px;
    text-align: left;
    font-weight: 600;
    font-size: 16px;
    color: var(--primary-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    box-sizing: border-box;
    z-index: 20; /* 【修改】确保它在最顶层 */
    pointer-events: none;
    /* 【新增】在朋友圈页面，让状态栏文字变白，更清晰 */
    mix-blend-mode: difference;
    color: white;
}
/* --- 新增：聊天搜索结果样式 --- */
.search-result-item {
    display: flex;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    gap: 12px;
    align-items: flex-start;
}
.search-result-item:hover {
    background-color: #f0f2f5;
}
.search-result-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}
.search-result-item .info {
    flex-grow: 1;
    overflow: hidden;
}
.search-result-item .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
}
.search-result-item .name {
    font-weight: 500;
    color: var(--primary-text);
}
.search-result-item .timestamp {
    font-size: 12px;
    color: var(--secondary-text);
}
.search-result-item .content {
    font-size: 14px;
    color: var(--secondary-text);
    /* 防止文本换行，保持单行显示 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* 搜索关键词高亮样式 */
.search-result-item .content mark {
    background-color: #ffd700;
    color: black;
    font-weight: 600;
    border-radius: 3px;
    padding: 1px 2px;
}
/* --- 同人论坛样式 --- */
#fanfic-forum-page .page-content {
    background-color: #ffffff;
    padding: 12px 0;
}

.fanfic-empty-state {
    text-align: center;
    padding-top: 100px;
    color: var(--secondary-text);
}

.fanfic-card {
    background-color: #fff;
    margin: 0 12px 20px 12px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s;
}
.fanfic-card:active {
    transform: scale(0.98);
}

.fanfic-card-content {
    padding: 16px;
}

.fanfic-card-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--primary-text);
    margin: 0 0 10px 0;
}

.fanfic-card-snippet {
    font-size: 15px;
    color: var(--secondary-text);
    line-height: 1.6;
    max-height: 72px; /* 大约3行 */
    overflow: hidden;
    text-overflow: ellipsis;
    /* 多行省略需要额外处理，这里先简单隐藏 */
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
}

.fanfic-card-actions {
    display: flex;
    padding: 8px 16px;
    border-top: 1px solid var(--border-color);
    gap: 20px;
}

.fanfic-action-btn {
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 14px;
    color: var(--secondary-text);
}
.fanfic-action-btn .svg-icon {
    width: 20px;
    height: 20px;
}
.fanfic-action-btn.liked .svg-icon {
    fill: #E53935;
    stroke: #E53935;
}
/* 在 “--- 同人论坛样式 ---” 区域添加 */
.fanfic-card-footer {
    padding: 10px 16px;
    border-top: 1px solid var(--border-color);
    font-size: 13px;
    color: var(--secondary-text);
    display: flex;
    gap: 16px;
    align-items: center; 	
}
/* 【全新添加】为图标和数字的组合体设置样式 */
.fanfic-footer-item {
    display: flex;
    align-items: center;
    gap: 5px; /* 图标和数字之间的间距 */
}

/* 【全新添加】定义图标本身的大小和颜色 */
.fanfic-footer-item .svg-icon {
    width: 16px;
    height: 16px;
    color: var(--secondary-text); /* 使用你已有的颜色变量，保持风格统一 */
}

/* --- 文章详情页样式 --- */
#fanfic-detail-container {
    padding: 20px;
}
.fanfic-full-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 25px;
}
.fanfic-full-content {
    font-size: 16px;
    line-height: 1.8;
    white-space: pre-wrap;
    margin-bottom: 40px;
}
.fanfic-comments-section {
    border-top: 1px solid var(--border-color);
    padding-top: 20px;
}
.comments-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 15px;
}
/* --- 文章详情页样式 --- */
.comment-thread {
    background-color: #f8f9fa; /* 1. 为每条评论添加浅灰色背景，形成卡片 */
    padding: 12px 16px;      /* 2. 增加内边距，让内容更舒展 */
    border-radius: 12px;       /* 3. 添加圆角，让卡片更柔和 */
    margin-bottom: 12px;
}
.comment-author {
    font-weight: 600;                 /* 4. 字体加粗，更突出 */
    color: var(--accent-color);       /* 5. 使用主题强调色 (蓝色)，醒目且可交互感强 */
    margin-bottom: 6px;               /* 6. 稍微增加与下方内容的间距 */
    font-size: 14px;                  /* 7. 字体略微缩小，形成视觉层级 */
}
.comment-content {
    color: #495057;                   /* 8. 使用更柔和的深灰色，降低阅读疲劳 */
    line-height: 1.6;                 /* 9. 增大行高，提升大段文字的可读性 */
    margin-bottom: 4px;
}
.comment-reply {
    margin-left: 20px;
    padding-left: 12px;
    border-left: 2px solid var(--border-color); /* 10. 使用主题边框颜色，风格更统一 */
    margin-top: 10px;
}
.comment-reply-btn {
    font-size: 12px;
    color: var(--secondary-text);
    cursor: pointer;
}

/* 在 “--- 文章详情页样式 ---” 区域添加 */
.fanfic-detail-actions {
    display: flex;
    justify-content: center; /* 居中 */
    gap: 30px; /* 按钮间距 */
    padding: 20px 0;
    margin-bottom: 20px;
    border-top: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
}
/* ---爱心按钮 --- */
svg use[href="#icon-heart"] {
    fill: none;
    stroke: currentColor; /* currentColor 是个非常有用的值，它表示“边框颜色跟随其父元素的文字颜色” */
    transition: all 0.2s ease-in-out; /* 平滑过渡效果 */
}

/* 2. 【“喜欢”状态的覆盖样式】 */
.liked svg use[href="#icon-heart"] {
    fill: #E53935;
    stroke: #E53935;
}

/* 3. 【“喜欢”状态的文字样式】 */
.liked span {
    color: #E53935;
}

/* 4. (可选但推荐) 为所有 svg-icon 设置一个统一的大小 */
.svg-icon {
    width: 20px;
    height: 20px;
}

/* 在 “--- 聊天界面样式 ---” 区域添加 */
.fanfic-share-bubble {
    background-color: var(--bg-color-secondary);
    border-radius: 12px;
    padding: 12px;
    max-width: 280px; /* 限制最大宽度 */
    cursor: pointer; /* 增加可点击手势 */
    border: 1px solid var(--border-color);
    transition: background-color 0.2s;
}

.fanfic-share-bubble:hover {
    background-color: var(--bg-color-tertiary);
}

.fanfic-share-title {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 6px;
    /* 防止标题过长 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.fanfic-share-snippet {
    font-size: 13px;
    color: var(--secondary-text);
    margin-bottom: 10px;
    /* 多行省略 */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;  
    overflow: hidden;
}

.fanfic-share-footer {
    font-size: 12px;
    color: var(--tertiary-text);
    padding-top: 6px;
    border-top: 1px solid var(--border-color);
}
/* --- 在 “同人论坛样式” 区域内添加 --- */

/* 已选角色标签的样式 */
.fanfic-char-pill {
    background-color: #e6f2ff;
    color: var(--accent-color);
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
}

/* 标签上的移除按钮 'x' */
.fanfic-char-pill-remove {
    background: #cddfff;
    border: none;
    border-radius: 50%;
    width: 16px;
    height: 16px;
    cursor: pointer;
    font-size: 12px;
    line-height: 16px;
    font-weight: bold;
    color: var(--accent-color);
}

.list-view-scrollable {
    max-height: 60vh; /* 核心：最大高度是视窗高度的60% */
    overflow-y: auto;   /* 核心：当内容超出时，自动显示垂直滚动条 */
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #fff;
}
/* 角色选择弹窗的列表项 */
.char-select-list-item {
    border-bottom: none; /* 移除旧边框 */
    border-top: 1px solid var(--border-color); /* 用顶部边框做分割线 */
}
.char-select-list-item:first-child {
    border-top: none; /* 第一个列表项不需要顶部边框 */
}
.char-select-list-item:hover {
    background-color: #f8f9fa;
}
.char-select-list-item input[type="checkbox"] {
    width: 18px;
    height: 18px;
    margin-right: 12px;
}
.char-select-list-item label {
    flex-grow: 1;
}
#fanfic-search-container {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    transition: all 0.35s ease-in-out;
    border-bottom: 0px solid transparent !important; /* 收起时隐藏边框 */
}
#fanfic-search-container.open {
    max-height: 300px; /* 一个足够大的高度，确保内容能完全显示 */
    padding-top: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--border-color) !important; /* 展开时显示边框 */
}

/* --- 全局音乐播放条 (Top Bar) --- */
#music-player-bar {
    position: absolute;
    left: 0;
    width: 100%;
    z-index: 50; /* 层级要高 */
    flex-wrap: wrap; /* 允许换行，为进度条腾出空间 */
    padding: 6px 12px;
    box-sizing: border-box;
	background-color: rgba(240, 240, 240, 0.9);
    backdrop-filter: blur(5px);
    border-bottom: 1px solid var(--border-color);
}

/* 这是播放器在朋友圈页面上的【特殊样式】 */
#music-player-bar.on-moments-page {
    background-color: rgba(0, 0, 0, 0.3); /* 半透明黑色背景 */
    backdrop-filter: blur(10px);          /* 增加模糊效果，更有质感 */
    border-bottom: 1px solid rgba(255, 255, 255, 0.2); /* 边框也用半透明白色 */
    transition: background-color 0.3s;    /* 添加过渡动画 */
}

/* 在朋友圈页面，播放器上的文字和图标要变成白色才看得清 */
#music-player-bar.on-moments-page,
#music-player-bar.on-moments-page .music-info .title,
#music-player-bar.on-moments-page .lyrics-container,
#music-player-bar.on-moments-page .svg-icon {
    color: #ffffff;
}

.progress-bar-top {
    width: 100%;
    height: 2px;
    background-color: rgba(0,0,0,0.1);
    position: absolute;
    top: 0;
    left: 0;
    cursor: pointer;
}
.progress-bar-top::after {
    content: '';
    display: block;
    height: 100%;
    background-color: var(--accent-color);
    width: var(--progress, 0%); /* 确保是这行 */
    transition: width 0.1s linear; /* 增加一个平滑过渡 */
}
/* 放在 .progress-bar-top::after 的样式后面 */
.progress-handle-top {
    position: absolute;
    top: 50%;
    left: var(--progress, 0%); /* 使用CSS变量来定位 */
    width: 10px;
    height: 10px;
    background: var(--accent-color);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none; /* 让点击可以穿透圆点，点到下面的进度条 */
}

/* --- 音乐 App 主页面 --- */
#music-app-page {
    position: relative; /* 关键：为伪元素定位提供基准 */
    background-color: #282828; /* 默认深色背景 */
    color: #fff;
    overflow: hidden; /* 防止背景溢出 */
}

/* 新增：用于显示壁纸和遮罩的伪元素 */
#music-app-page::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* 将其置于内容下方 */
    
    /* 关键：背景图片由一个CSS变量控制，默认是渐变 */
    background-image: var(--music-wallpaper, linear-gradient(to top, #282828 0%, #484848 100%));
    
    background-size: cover;
    background-position: center;
    
    /* 关键：添加一个半透明黑色遮罩，确保文字清晰可见 */
    box-shadow: inset 0 0 0 100vmax rgba(0,0,0,0.4);
    
    transition: background-image 0.5s ease-in-out; /* 添加淡入淡出效果 */
}


#music-main-content {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
}
#music-player-main-view {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    flex-grow: 1;
}

/* 黑胶唱片 (已修改) */
.vinyl-container {
    position: relative;
    width: 280px;
    height: 280px;
    margin-top: 40px;
}

/* 【修改】用 CSS 绘制指针 */
.vinyl-arm {
    position: absolute;
    top: -20px;
    left: 270px;
    width: 150px;
    height: 150px;
    z-index: 10;
    transform-origin: 15px 15px; /* 设置旋转中心点 */
    transition: transform 0.5s ease;
    transform: rotate(60deg);
    pointer-events: none; /* 让鼠标可以穿透指针，点击到下面的封面 */
}
/* 【新增】用伪元素绘制指针的“转轴” */
.vinyl-arm::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 30px;
    height: 30px;
    background: #333;
    border-radius: 50%;
    border: 2px solid #555;
    box-shadow: 0 0 5px rgba(0,0,0,0.5);
}
/* 【新增】用伪元素绘制指针的“臂”和“唱头” */
.vinyl-arm::after {
    content: '';
    position: absolute;
    top: 11px; /* 垂直居中 */
    left: 15px; /* 从转轴中心开始 */
    width: 100px; /* 臂的长度 */
    height: 8px; /* 臂的厚度 */
    background: linear-gradient(to right, #d3d3d3, #b0b0b0); /* 金属质感渐变 */
    border-radius: 4px;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    /* 绘制唱头部分 */
    border-right: 12px solid #444;
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
}

.vinyl-container.playing .vinyl-arm {
    transform: rotate(120deg);
}

/* 【修改】用 CSS 绘制黑胶唱片 */
.vinyl-record {
    width: 280px;
    height: 280px;
    /* 移除背景图片，改用纯 CSS 实现 */
    background-color: #222; /* 唱片底色 */
    background-image: repeating-radial-gradient( /* 用渐变模拟唱片上的纹路 */
        circle at center, 
        rgba(255, 255, 255, 0.04) 0, 
        rgba(255, 255, 255, 0.04) 1px, 
        transparent 1px, 
        transparent 3px
    );
    box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 15px rgba(0,0,0,0.6); /* 增加内外阴影，更有立体感 */
    border: 2px solid #111;
    
    /* 保留原有的动画和布局属性 */
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate-vinyl 20s linear infinite;
    animation-play-state: paused;
}
.vinyl-container.playing .vinyl-record {
    animation-play-state: running;
}
@keyframes rotate-vinyl {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.vinyl-cover {
    width: 180px;
    height: 180px;
    background-color: #555;
    background-size: cover;
    background-position: center;
    border-radius: 50%;
    border: 2px solid #111;
}

/* 主歌词区 */
.lyrics-view-main {
    height: 60px;
    text-align: center;
    font-size: 16px;
    color: #ccc;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 10px;
}

/* 主进度条 */
.main-progress-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 12px;
    color: #aaa;
}
.progress-bar-main {
    flex-grow: 1;
    height: 4px;
    background: rgba(255,255,255,0.2);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}
.progress-filled-main {
    height: 100%;
    background: #fff;
    border-radius: 2px;
    width: 0%;
}
.progress-handle-main {
    position: absolute;
    top: 50%;
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

/* 主控制按钮 */
.music-app-controls {
    width: 100%;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 10px 0;
}
.control-btn {
    background: none;
    border: none;
    cursor: pointer;
    fill: #fff;
    padding: 10px;
}
.control-btn svg {
    width: 24px;
    height: 24px;
}
.control-btn.play-btn svg {
    width: 48px;
    height: 48px;
}

/* 侧边栏 */
#music-sidebar {
    position: absolute;
    top: 0;
    right: 0;
    width: 80%;
    max-width: 300px;
    height: 100%;
    background: #f8f9fa;
    z-index: 100;
    transform: translateX(100%);
    transition: transform 0.3s ease;
    display: flex;
    flex-direction: column;
    box-shadow: -5px 0 15px rgba(0,0,0,0.1);
}
#music-sidebar.active {
    transform: translateX(0);
}
.sidebar-header {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
}
.sidebar-header h3 { margin: 0; color: var(--primary-text); }
.sidebar-content {
    flex-grow: 1;
    overflow-y: auto;
}
.sidebar-footer {
    padding: 12px;
    border-top: 1px solid var(--border-color);
}
/* 侧边栏内的播放列表项 (复用之前的样式) */
#music-playlist-sidebar-container .music-playlist-item {
    padding: 12px 16px;
}
#music-playlist-sidebar-container .music-playlist-item .song-title {
    color: var(--primary-text); /* 将歌曲标题设为主要文字颜色 (近黑色) */
}
#music-playlist-sidebar-container .music-playlist-item .song-artist {
    color: var(--secondary-text); /* 将歌手名设为次要文字颜色 (灰色) */
}
#music-playlist-sidebar-container .music-playlist-item.playing {
    background-color: #e0eaff;
    border-left: 3px solid var(--accent-color);
}
/* --- 全屏歌词样式 --- */
#full-lyrics-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(15px);
    z-index: 200;
    display: none; /* 默认隐藏 */
    color: #999;
    font-size: 18px;
    text-align: center;
    overflow: hidden;
}
.lyrics-list {
    width: 100%;
    height: 100%;
    padding: 50% 20px; /* 上下留出空间，让当前歌词能在中间 */
    box-sizing: border-box;
    overflow-y: auto;
    scroll-behavior: smooth; /* 平滑滚动 */
}
.lyrics-list p {
    margin: 18px 0;
    line-height: 1.5;
    transition: color 0.3s, transform 0.3s;
}
.lyrics-list p.active {
    color: #fff;
    font-weight: 600;
    transform: scale(1.1);
}
/* --- 【全新】一起听歌弹窗样式 (Listen Together Modal) --- */

/* 遮罩层 */
.lt-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(4px);
    z-index: 1001; /* 比其他元素层级高 */
    display: flex;
    justify-content: center;
    align-items: flex-end; /* 关键：让弹窗从底部对齐 */
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}
.lt-overlay.show {
    opacity: 1;
    pointer-events: auto;
}

/* 弹窗主体 */
.lt-modal {
    width: 100%;
    max-height: 85%;
    background: #ffffff;
    border-radius: 28px 28px 0 0;
    box-shadow: 0 -5px 30px rgba(0,0,0,0.15);
    padding: 12px 20px 30px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}
.lt-overlay.show .lt-modal {
    transform: translateY(0);
}

/* 顶部拖动条和关闭按钮 */
.lt-header-bar {
    display: flex;                 /* 启用 Flexbox 布局 */
    justify-content: space-between;/* 核心！两端对齐，中间项目会被自动推开 */
    align-items: center;           /* 垂直居中，让三者高低对齐 */
    width: 100%;                   /* 确保容器占满宽度 */
}
.lt-drag-handle {
    width: 40px;
    height: 5px;
    background-color: #dcdcdc;
    border-radius: 2.5px;
}
.lt-close-btn {
    position: absolute;
    top: -5px;
    right: -5px;
    background: #f0f2f5;
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    font-size: 24px;
    line-height: 30px;
    text-align: center;
    color: #8a8d91;
    cursor: pointer;
}

/* 头像和计时器区域 */
.lt-profile-section {
    text-align: center;
    margin-bottom: 25px;
}
.lt-avatars {
    display: flex;
    justify-content: center;
    margin-bottom: 12px;
}
.lt-avatar {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    border: 3px solid #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    object-fit: cover;
}
.lt-avatar:last-child {
    margin-left: -18px; /* 头像重叠效果 */
}
#lt-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--primary-text);
    margin: 0 0 4px 0;
}
#lt-timer {
    font-size: 14px;
    color: var(--secondary-text);
    margin: 0;
}

/* 当前播放卡片 */
.lt-current-song-card {
    display: flex;
    align-items: center;
    gap: 15px;
    background: #f8f9fa;
    border-radius: 16px;
    padding: 12px;
    margin-bottom: 25px;
}
.lt-current-cover {
    width: 56px;
    height: 56px;
    border-radius: 12px;
    object-fit: cover;
    flex-shrink: 0;
}
.lt-current-info {
    flex-grow: 1;
    overflow: hidden;
}
.lt-current-info h3 {
    font-size: 16px;
    font-weight: 500;
    color: var(--primary-text);
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.lt-current-info p {
    font-size: 13px;
    color: var(--secondary-text);
    margin: 0;
}
.lt-play-pause-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--accent-color);
    border: none;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    flex-shrink: 0;
}

/* 播放列表 */
.lt-playlist-section {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 防止内容溢出 */
}
.lt-playlist-section h4 {
    margin: 0 0 10px 0;
    font-size: 15px;
    color: var(--secondary-text);
}
.lt-playlist-container {
    overflow-y: auto;
    flex-grow: 1;
}
/* 复用之前的列表项样式，但做些微调 */
.lt-playlist-item {
    display: flex;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid #f0f2f5;
    cursor: pointer;
}
.lt-playlist-item .song-info {
    flex-grow: 1;
}
.lt-playlist-item .song-title {
    font-weight: 500;
    color: var(--primary-text);
}
.lt-playlist-item .song-artist {
    font-size: 12px;
    color: var(--secondary-text);
}
.lt-playlist-item .delete-song-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
}
/* 正在播放的特殊样式 */
.lt-playlist-item.playing .song-title {
    color: var(--accent-color);
}
.lt-playlist-item.playing::before {
    content: '▶';
    color: var(--accent-color);
    font-size: 10px;
    margin-right: 10px;
}
/* --- 新增：CSS 预览区域样式 --- */
.css-preview-area {
    background-color: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 16px;
    overflow: hidden; /* 确保内部样式不会溢出 */
}
/* 覆盖预览区内的消息间距，使其更紧凑 */
.css-preview-area .message-row {
    margin-bottom: 8px;
}
.css-preview-area .message-row:last-child {
    margin-bottom: 0;
}
/* --- 【新增】API 设置页面美化样式 --- */
.api-card-new {
    background-color: #fff;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
}
.api-card-new .api-card-title {
    margin-top: 0;
    margin-bottom: 20px;
    font-size: 18px;
    font-weight: 600;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 15px;
}
.api-list-item-new {
    display: flex;
    align-items: center;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 10px;
    gap: 10px;
}
.api-list-item-new.active {
    border-color: var(--accent-color);
    background-color: #e6f2ff;
}
.api-list-item-new .info {
    flex-grow: 1;
}
.api-list-item-new .info .name {
    font-weight: 500;
    color: var(--primary-text);
}
.api-list-item-new .info .url {
    font-size: 12px;
    color: var(--secondary-text);
    word-break: break-all;
}
.api-list-item-new .actions {
    display: flex;
    flex-direction: column;
    gap: 5px;
    flex-shrink: 0;
}
.api-list-item-new .actions .btn-small {
    padding: 5px 10px;
    font-size: 13px;
    border-radius: 6px;
    border: none;
    cursor: pointer;
}
.api-list-item-new .actions .apply-btn {
    background-color: var(--accent-color);
    color: white;
}
.api-list-item-new .actions .delete-btn {
    background-color: #E53935;
    color: white;
}
.api-list-item-new.active .actions .apply-btn {
    background-color: #ccc;
    cursor: not-allowed;
}

/* --- 消息与弹窗终极美化 v3 --- */
/* 1. 语音消息优化 (修复宽度自适应) */
.bubble-voice {
    display: flex; flex-direction: column; align-items: flex-start;
    gap: 0; min-width: 80px; max-width: 220px; padding: 0;
   transition: none; /* 先重置所有 transition */
}
.bubble-voice.expanded {
    /* 【关键修复】展开时，移除JS设定的固定宽度，让其由内容和max-width决定 */
    width: auto !important; 
    max-width: 80%;
}
.voice-main {
    display: flex; align-items: center; gap: 8px;
    padding: 10px 15px; width: 100%; box-sizing: border-box;
	transition: width 0.35s cubic-bezier(0.4, 0, 0.2, 1);
}
.message-row.user .bubble-voice .voice-main { flex-direction: row-reverse; }
.voice-main .svg-icon { flex-shrink: 0; }
.message-row.user .bubble-voice .svg-icon { transform: scaleX(-1); color: var(--bubble-user-text); }
.message-row.ai .bubble-voice .svg-icon { color: var(--bubble-ai-text); }
.voice-duration { font-size: 14px; color: var(--secondary-text); flex-shrink: 0; }
.message-row.user .voice-duration { color: rgba(255, 255, 255, 0.8); }
.voice-waves { display: flex; align-items: center; gap: 2px; flex-grow: 1; overflow: hidden; height: 20px; }
.message-row.user .voice-waves { justify-content: flex-end; }
.voice-wave { background-color: var(--secondary-text); border-radius: 2px; width: 3px; }
.message-row.user .voice-wave { background-color: rgba(255, 255, 255, 0.8); }
.bubble-voice .voice-text {
    max-height: 0; overflow: hidden;
    transition: max-height 0.35s ease-out, padding 0.35s ease-out;
    padding-top: 0; padding-bottom: 0;
    border-top: 1px solid rgba(0,0,0,0.08);
    margin: 0; width: 100%; box-sizing: border-box;
    font-size: 15px; line-height: 1.6;
    padding-left: 15px; padding-right: 15px;
}
.bubble-voice.expanded .voice-text { max-height: 1000px; padding-top: 8px; padding-bottom: 12px; }
.message-row.user .bubble-voice .voice-text { border-top-color: rgba(255,255,255,0.2); }

* 2. 【全新】Instagram 风格图片弹窗 */
#modal-content.instagram-viewer-modal {
    width: 95%;
    max-width: 450px; /* 更大的宽度 */
    height: auto;
    max-height: 80%; /* 更高的高度 */
    background-color: #ffffff;
    border: 1px solid #dbdbdb;
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    /* 更快、更直接的动画 */
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease-out;
}
#modal-content.instagram-viewer-modal.show-animation {
    transform: scale(1);
    opacity: 1;
}

.ins-header {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid #efefef;
}
.ins-header img {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
    background-color: #f0f0f0;
}
.ins-header .ins-user-info {
    font-weight: 600;
    font-size: 15px;
    color: #262626;
}
.ins-close-btn {
    margin-left: auto;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.ins-close-btn .svg-icon { width: 20px; height: 20px; color: #8e8e8e; }

.ins-content-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 16px 20px;
    font-size: 15px;
    line-height: 1.7;
    color: #333;
    white-space: pre-wrap; /* 保持文本格式 */
}

.ins-footer {
    flex-shrink: 0;
    padding: 8px 16px 12px;
    border-top: 1px solid #efefef;
}
.ins-action-bar {
    display: flex;
    align-items: center;
    gap: 16px;
}
.ins-action-btn {
    cursor: pointer;
    background: none;
    border: none;
    padding: 0;
    display: flex;
}
.ins-action-btn .svg-icon {
    width: 24px;
    height: 24px;
    color: #262626;
    transition: transform 0.2s ease, color 0.2s ease;
}
.ins-action-btn:hover .svg-icon {
    transform: scale(1.1);
    color: #8e8e8e;
}
.ins-action-btn.bookmark {
    margin-left: auto; /* 将书签按钮推到最右边 */
}

.ins-likes {
    font-size: 14px;
    color: #262626;
    margin-top: 8px;
    font-weight: 500;
}
.ins-likes span {
    font-weight: 400;
    color: #8e8e8e;
}

/* 3. 文件预览“Pro”级美化 */
#modal-content.document-viewer-modal {
    width: 95%; max-width: 400px; height: 85%; max-height: 720px;
    padding: 0; display: flex; flex-direction: column;
    box-shadow: 0 10px 40px rgba(0,0,0,0.25); border-radius: 20px;
    transform: scale(0.95); opacity: 0;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
#modal-content.document-viewer-modal.show-animation { transform: scale(1); opacity: 1; }

.doc-header {
    flex-shrink: 0; padding: 10px 16px; border-bottom: 1px solid #e9ecef;
    display: flex; justify-content: space-between; align-items: center;
    background-color: #fff; border-radius: 20px 20px 0 0;
}
.doc-header .title { font-weight: 500; font-size: 15px; color: #495057; }
.doc-header .close-btn { /* ... 省略，样式未变 ... */ }

/* 新增：模拟编辑器工具栏 */
.doc-toolbar {
    flex-shrink: 0;
    padding: 8px 12px;
    background-color: #f8f9fa;
    border-bottom: 1px solid #e9ecef;
    display: flex;
    align-items: center;
    gap: 4px;
    overflow-x: auto; /* 在小屏幕上可以横向滚动 */
}
.doc-tool-btn {
    background: none; border: none; padding: 6px; border-radius: 6px;
    cursor: not-allowed; /* 设为禁用状态，因为只是装饰 */
    opacity: 0.7;
    display: flex; align-items: center; justify-content: center;
}
.doc-tool-btn .svg-icon { width: 18px; height: 18px; color: #495057; }
.doc-tool-separator {
    width: 1px;
    height: 18px;
    background-color: #dee2e6;
    margin: 0 6px;
}

.doc-content-wrapper {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px; /* 给滚动区域一点边距 */
    background-color: #f1f3f5; /* 类似桌面的背景色 */
}
.doc-paper {
    background: #fff;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    min-height: 100%;
}
.doc-paper-body {
    font-family: 'Times New Roman', 'Ma Shan Zheng', serif; /* 使用更像文档的字体 */
    line-height: 1.9;
    font-size: 17px;
    white-space: pre-wrap;
    color: #212529;
}
/* 4. 文件消息美化 (样式不变) */
.chat-bubble.bubble-file {
    background-color: #FFFFFF;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 0;
    width: 250px;
    overflow: hidden;
    color: var(--primary-text);
}
.file-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
}
.file-card-header .svg-icon {
    width: 40px;
    height: 40px;
    color: #555;
    flex-shrink: 0;
}
.file-card-info .file-name {
    font-weight: 500;
    font-size: 16px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.4;
}
.file-card-info .file-size {
    font-size: 12px;
    color: var(--secondary-text);
    margin-top: 4px;
}
.file-card-footer {
    border-top: 1px solid var(--border-color);
    padding: 4px 12px;
    font-size: 12px;
    color: var(--secondary-text);
}
/* 5. 撤回消息样式 (正式整合) */
.retracted-message {
    color: var(--secondary-text);
    font-size: 13px;
    padding: 8px 16px;
    background: #e9ecef;
    border-radius: 16px;
    margin: 12px auto;
    cursor: default; /* 整体不可点击，只有span可点 */
    display: inline-block; /* 让margin:auto生效 */
}
.retracted-message span {
    text-decoration: underline;
    cursor: pointer;
    color: var(--accent-color); /* 给可点击部分一个强调色 */
}
/* --- 消息与弹窗终极美化 v6 (全系 Ins 风格) --- */
/* 2. 【全新】Ins 风格交互式气泡 (v2 修复版) */
.chat-bubble.bubble-transfer,
.chat-bubble.bubble-location,
.chat-bubble.bubble-gift {
    /* 统一的卡片基础样式 */
    background-color: #FFFFFF !important;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 0;
    width: 250px;
    overflow: hidden;
    color: var(--primary-text);
    /* 【核心修复】强制内部元素垂直排列 */
    display: flex;
    flex-direction: column;
}

/* 卡片头部：包含图标和标题 */
.interactive-card-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    flex-shrink: 0; /* 防止头部被压缩 */
}
.interactive-card-header .svg-icon {
    width: 38px;  /* 稍微增大图标，更协调 */
    height: 38px;
    flex-shrink: 0;
    padding: 8px;
    border-radius: 8px; /* 圆角矩形更好看 */
    color: white;
}
.interactive-card-header .info {
    flex-grow: 1;
    overflow: hidden; /* 防止文字溢出 */
}
.interactive-card-header .info .title {
    font-weight: 500;
    font-size: 16px;
    /* 【核心修复】防止标题换行 */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.interactive-card-header .info .subtitle {
    font-size: 13px; /* 副标题字体稍大一点 */
    color: var(--primary-text); /* 金额/礼物名用主要颜色，更清晰 */
    margin-top: 4px;
}

/* 为不同类型的卡片设置独特的图标背景色 */
.bubble-transfer .svg-icon { background-color: #fabf44; }
.bubble-location .svg-icon { background-color: #4a90e2; }
.bubble-gift .svg-icon { background-color: #f87c7c; }

/* 卡片主体内容区（仅定位卡片使用） */
.interactive-card-body {
    height: 100px;
    background: #e9e9e9 url('https://files.catbox.moe/608ojk.jpg') center/cover;
}

/* 卡片底部：显示状态或类型 */
.interactive-card-footer {
    border-top: 1px solid var(--border-color);
    padding: 6px 12px;
    font-size: 12px;
    color: var(--secondary-text);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0; /* 防止底部被压缩 */
}
.interactive-card-footer .status {
    font-weight: 500;
}

/* 3. 【全新】Ins 风格弹窗 (统一框架) */
#modal-content.instagram-viewer-modal {
    width: 95%; max-width: 450px; height: auto; max-height: 80%;
    background-color: #ffffff; border: 1px solid #dbdbdb; padding: 0;
    display: flex; flex-direction: column; border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    transform: scale(0.95); opacity: 0;
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease-out;
}
#modal-content.instagram-viewer-modal.show-animation { transform: scale(1); opacity: 1; }

.ins-header {
    flex-shrink: 0; display: flex; align-items: center;
    padding: 12px 16px; border-bottom: 1px solid #efefef;
}
.ins-header img { width: 36px; height: 36px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #f0f0f0; }
.ins-header .ins-user-info { font-weight: 600; font-size: 15px; color: #262626; }
.ins-close-btn { margin-left: auto; cursor: pointer; width: 30px; height: 30px; display: flex; justify-content: center; align-items: center; }
.ins-close-btn .svg-icon { width: 20px; height: 20px; color: #8e8e8e; }

/* 【关键修复】图片描述文字左对齐 */
.ins-content-body {
    flex-grow: 1; overflow-y: auto; padding: 20px;
    font-size: 15px; line-height: 1.7; color: #333;
    white-space: pre-wrap; text-align: left; /* 强制左对齐 */
}

.ins-footer {
    flex-shrink: 0; padding: 12px 16px;
    border-top: 1px solid #efefef;
}
/* 装饰性图标栏 */
.ins-action-bar { display: flex; align-items: center; gap: 16px; }
.ins-action-btn { cursor: pointer; background: none; border: none; padding: 0; display: flex; }
.ins-action-btn .svg-icon { width: 24px; height: 24px; color: #262626; transition: transform 0.2s ease, color 0.2s ease; }
.ins-action-btn:hover .svg-icon { transform: scale(1.1); color: #8e8e8e; }
.ins-action-btn.bookmark { margin-left: auto; }
.ins-likes { font-size: 14px; color: #262626; margin-top: 8px; font-weight: 500; }
.ins-likes span { font-weight: 400; color: #8e8e8e; }

/* 交互式弹窗的特定内容样式 */
.ins-content-body.interactive-content {
    text-align: center; /* 交互弹窗内容居中 */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 30px 20px;
}
.interactive-icon-large { margin-bottom: 16px; }
.interactive-icon-large .svg-icon { width: 60px; height: 60px; color: var(--accent-color); }
.interactive-title { font-size: 22px; font-weight: 600; color: #262626; margin: 0 0 8px 0; }
.interactive-subtitle { font-size: 15px; color: #8e8e8e; margin: 0; line-height: 1.5; }
.interactive-message { font-style: italic; color: #555; margin-top: 16px; padding: 10px; background: #f9f9f9; border-radius: 8px; }

/* 交互式弹窗的按钮 */
.ins-footer.interactive-actions {
    display: flex;
    gap: 12px;
    padding: 16px;
}
.ins-footer.interactive-actions button {
    flex: 1;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.2s;
}
.ins-footer.interactive-actions button:hover { opacity: 0.85; }
.ins-button-primary { background-color: var(--accent-color); color: white; }
.ins-button-secondary { background-color: #efefef; color: #262626; }
/* --- 【全新】转发消息样式 --- */
.chat-bubble.bubble-forward {
    background-color: #FFFFFF !important;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 12px;
    width: 260px;
    color: var(--primary-text);
    cursor: pointer;
    transition: background-color 0.2s;
}
.chat-bubble.bubble-forward:hover {
    background-color: #f9f9f9 !important;
}
.forward-header {
    font-size: 16px;
    font-weight: 500;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 8px;
}
.forward-snippet {
    font-size: 14px;
    color: var(--secondary-text);
    line-height: 1.5;
}
.forward-snippet p {
    margin: 0 0 4px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.forward-snippet p:last-child {
    margin-bottom: 0;
}

/* --- 【全新】转发记录查看器弹窗 --- */
#modal-content.forward-viewer-modal {
    width: 95%;
    max-width: 450px;
    height: 80%;
    background-color: #f0f2f5; /* 使用灰色背景，更像聊天背景 */
    padding: 0;
    display: flex;
    flex-direction: column;
    border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
}
.forward-viewer-header {
    flex-shrink: 0;
    text-align: center;
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
    background-color: #fff;
    border-radius: 24px 24px 0 0;
    position: relative;
}
.forward-viewer-header .title {
    font-weight: 600;
    font-size: 17px;
}
.forward-viewer-header .ins-close-btn { /* 复用ins风格的关闭按钮 */
    position: absolute;
    top: 50%;
    right: 12px;
    transform: translateY(-50%);
}
.forward-viewer-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 10px;
}
/* 在查看器内模拟消息行 */
.forward-viewer-body .message-line {
    margin-bottom: 12px;
    font-size: 15px;
}
.forward-viewer-body .sender {
    font-weight: 500;
    margin-bottom: 4px;
    color: var(--primary-text);
}
.forward-viewer-body .message {
    padding: 8px 12px;
    background-color: #fff;
    border-radius: 8px;
    display: inline-block;
    max-width: 90%;
    word-wrap: break-word;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}
/* --- 【全新】转发目标选择器美化 --- */
.forward-target-selector .list-item {
    /* 复用 chat-list-item 的大部分样式，但移除了边框，让它在弹窗内更简洁 */
    display: flex;
    align-items: center;
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.forward-target-selector .list-item:last-child {
    border-bottom: none;
}
.forward-target-selector .list-item:hover {
    background-color: #f0f2f5;
}
.forward-target-selector .chat-list-avatar {
    width: 48px;
    height: 48px;
    border-radius: 10px;
    margin-right: 14px;
    object-fit: cover;
    flex-shrink: 0;
    background-color: #e9ecef;
}
.forward-target-selector .info {
    flex-grow: 1;
    overflow: hidden; /* 防止文字溢出 */
}
.forward-target-selector .name {
    font-weight: 500;
    color: var(--primary-text);
    font-size: 16px;
}
.forward-target-selector .subtext {
    font-size: 13px;
    color: var(--secondary-text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-top: 4px;
}
.forward-target-selector .group-icon {
    font-size: 12px;
    background: #eee;
    color: #555;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    vertical-align: middle;
}
/* --- 【全新 V2.0】表情包库交互式样式 --- */
/* 表情包网格容器 - 确保它能填满空间并滚动 */
#sticker-grid-container-wrapper {
    flex-grow: 1;
    overflow: hidden; /* 让内部的网格自己滚动 */
}
#sticker-grid-container {
    height: 100%;
    overflow-y: auto; /* 核心：让网格本身可以垂直滚动 */
    padding-top: 5px;
    padding-bottom: 5px;
}

/* 添加面板展开时的样式 */
#add-sticker-panel.open {
    max-height: 300px; /* 展开后的高度，可以根据内容调整 */
    border-bottom-color: var(--border-color) !important; /* 显示分割线 */
    margin-bottom: 15px !important; /* 和下面的网格拉开距离 */
}

/* 表情包单个项目的美化 */
/* 【V2.2 遮挡问题终极修复版】表情包单个项目的美化 */
#sticker-grid-container .sticker-item {
    /* 【核心修复】移除 aspect-ratio，改用明确的高度 */
    height: 80px; 
    
    /* 其他样式保持不变，但可以移除多余的 width: 100% */
    background-color: #f0f2f5;
    border-radius: 8px;
    cursor: pointer;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    position: relative;
    overflow: hidden;
    transition: transform 0.2s;
}

#sticker-grid-container .sticker-item:active {
    transform: scale(0.9);
}

/* 【V2.1 交互修正版】悬浮删除图标样式 */
#sticker-grid-container .sticker-item .delete-overlay {
    position: absolute;
    top: 2px;
    right: 2px;
    width: 24px;
    height: 24px;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    line-height: 24px; /* 确保图标垂直居中 */
    
    /* 默认状态：完全透明，且缩小，不可见 */
    opacity: 0;
    transform: scale(0.5);
    pointer-events: none;
    transition: all 0.2s ease-in-out;
}

/* 仅当鼠标悬浮在整个表情项上时，才让删除图标“准备好” */
#sticker-grid-container .sticker-item:hover .delete-overlay {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto; /* 【关键】只有此时，删除图标才可被点击 */
}


/* --- 【全新】表情包专属气泡样式 --- */
.chat-bubble.bubble-sticker {
    background-color: transparent !important; /* 无背景色 */
    border: none !important; /* 无边框 */
    padding: 0 !important; /* 无内边距 */
    box-shadow: none !important; /* 无阴影 */
    max-width: 120px; /* 限制最大尺寸 */
    cursor: default; /* 鼠标指针为默认，表示不可点击 */
}
.chat-bubble.bubble-sticker img {
    width: 100%;
    height: auto;
    display: block;
    /* 你可以加一点效果，比如轻微的阴影，让它更有质感 */
    /* filter: drop-shadow(0 2px 3px rgba(0,0,0,0.15)); */
}
/* --- 【V4 终极布局版】通话页面样式 --- */
#call-page {
    background-color: #1c1c1e;
    color: #fff;
}
#call-background {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover; background-position: center;
    transition: opacity 0.5s ease-in-out;
}
#call-overlay {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(15px);
}
.call-ui-container {
    position: relative; z-index: 10;
    width: 100%; height: 100%;
    display: flex; flex-direction: column;
    padding: 0; box-sizing: border-box;
}

/* --- 顶部信息 --- */
.call-header {
    flex-shrink: 0;
    padding: 60px 20px 20px;
    text-align: center;
    transition: opacity 0.3s, transform 0.3s;
}
.call-avatar {
    width: 90px; height: 90px;
    border-radius: 50%; object-fit: cover;
    margin: 0 auto 15px;
    border: 2px solid rgba(255,255,255,0.5);
}
.call-name { font-size: 24px; font-weight: 600; }
.call-status { font-size: 16px; color: #a0a0a0; margin-top: 8px; }

/* --- 中间聊天记录 --- */
.call-history-wrapper {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    /* 【核心修改】为底部的绝对定位控制区留出空间 */
    padding-bottom: 220px; 
    box-sizing: border-box;
}
.call-history-log {
    width: 100%;
    max-height: 100%;
    overflow-y: auto;
    padding: 0 15px 10px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
/* ... 气泡样式 p.user, p.ai 保持不变 ... */
.call-history-log p { margin: 0; line-height: 1.5; font-size: 15px; padding: 6px 12px; border-radius: 12px; max-width: 85%; word-wrap: break-word; }
.call-history-log p.user { background-color: var(--accent-color); align-self: flex-end; }
.call-history-log p.ai { background-color: rgba(255,255,255,0.2); align-self: flex-start; }

/* --- 底部控制 --- */
.call-controls {
    /* 【核心修改】将整个控制区绝对定位在底部 */
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px 20px 40px;
    z-index: 20;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.call-input-wrapper {
    display: none;
    gap: 10px;
}
#call-input { flex-grow: 1; border: none; background: rgba(255,255,255,0.2); border-radius: 20px; padding: 10px 15px; color: #fff; font-size: 16px; }
#call-send-btn { border: none; background: var(--accent-color); color: #fff; padding: 0 20px; border-radius: 20px; cursor: pointer; font-weight: 500; }

.call-actions-final {
    display: flex;
    justify-content: space-around;
    align-items: center;
}
.call-action-item { text-align: center; }
.call-action-button {
    width: 70px; height: 70px;
    background: rgba(255,255,255,0.15);
    border-radius: 50%;
    display: flex; justify-content: center; align-items: center;
    margin: 0 auto 8px; cursor: pointer;
}
.call-action-button svg { width: 30px; height: 30px; color: #fff; }
.call-hangup-btn { /* 样式不变 */ }

/* --- 视频通话专属覆盖样式 --- */
#call-page.video-mode .call-header {
    opacity: 0;
    transform: translateY(-20px);
    pointer-events: none;
}
#call-page.video-mode #call-overlay {
    backdrop-filter: blur(0);
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, rgba(0,0,0,0.0) 50%);
}
#call-page.video-mode .call-status {
    position: absolute;
    top: 20px; left: 20px;
    text-align: left;
    background: rgba(0,0,0,0.4);
    padding: 4px 10px; border-radius: 12px;
    font-size: 14px;
    opacity: 1; transform: translateY(0); pointer-events: auto;
	 text-shadow: 0 1px 3px rgba(0,0,0,0.6);
}
#call-page.video-mode .call-history-wrapper {
    /* 【核心修改】不再需要 absolute 定位，因为它已经是 flex-grow: 1 了 */
    /* 我们只需要调整它的 padding-bottom 就可以控制它和按钮的距离 */
    padding-bottom: 220px; 
    /* 移除旧的定位代码
    position: absolute;
    bottom: 200px; 
    left: 0; right: 0;
    height: 35%;
    justify-content: flex-end; */
}
#call-page.video-mode .call-controls {
    background: transparent;
}
#call-page.video-mode .call-history-log p {
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    /* 也可以让气泡本身更透明一点，更好地融入背景 */
    background-color: rgba(0,0,0,0.3); 
}
#call-page.video-mode .call-history-log p.user {
    /* 用户的气泡可以保持原样，因为它本身颜色很深 */
    background-color: var(--accent-color);
    text-shadow: none;
}

.call-hangup-row { text-align: center; margin-top: 10px; }
.call-hangup-btn {
    width: 70px; height: 70px;
    border-radius: 50%;
    border: none;
    background: #FF3B30;
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91'%3E%3C/path%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: 30px;
    transform: rotate(135deg);
}
/* --- 【全新】来电界面样式 --- */
.incoming-call-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 9998; /* 层级极高 */
    display: none; /* 默认隐藏 */
    color: #fff;
}
.incoming-call-background {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-color: #2c3e50;
    background-size: cover;
    background-position: center;
    filter: blur(20px) brightness(0.6);
    transform: scale(1.1);
}
.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 100%;
    padding-bottom: 50px;
}
.incoming-action-item {
    text-align: center;
}
.incoming-action-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    margin-bottom: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.incoming-action-btn.decline {
    background-color: #FF3B30;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91'%3E%3C/path%3E%3C/svg%3E");
    background-size: 35px;
    background-repeat: no-repeat;
    background-position: center;
    transform: rotate(135deg);
}
.incoming-action-btn.accept {
    background-color: #34C759;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z'%3E%3C/path%3E%3C/svg%3E");
    background-size: 35px;
    background-repeat: no-repeat;
    background-position: center;
}
.incoming-action-item span {
    font-size: 16px;
    font-weight: 500;
}
/* --- 【全新】温馨小屋 (Pet House) 样式 --- */
#ph-tabs .ph-tab-btn {
    flex: 1;
    padding: 12px;
    border: none;
    background: none;
    font-size: 16px;
    font-weight: 500;
    color: var(--secondary-text);
    border-bottom: 2px solid transparent;
    cursor: pointer;
}
#ph-tabs .ph-tab-btn.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.ph-content .creature-display {
    text-align: center;
    margin-bottom: 20px;
}
.ph-content .creature-image {
    width: 120px;
    height: 120px;
    object-fit: contain;
    margin-bottom: 10px;
    /* filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1)); */ /* 给宠物加点阴影 */
}
.ph-content .creature-name {
    font-size: 18px;
    font-weight: 600;
}
.ph-content .creature-species {
    font-size: 14px;
    color: var(--secondary-text);
}

.ph-status-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}
.ph-status-bar label {
    width: 60px;
    font-size: 14px;
}
.ph-status-bar .progress-bg {
    flex-grow: 1;
    height: 12px;
    background-color: #eee;
    border-radius: 6px;
    overflow: hidden;
}
.ph-status-bar .progress-fill {
    height: 100%;
    border-radius: 6px;
    transition: width 0.3s ease;
}

.ph-section h4 {
    margin: 10px 0 8px 0;
    font-size: 15px;
    color: var(--secondary-text);
}
.ph-log-box, .ph-inventory-box {
    max-height: 100px;
    overflow-y: auto;
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 13px;
}
.ph-log-box p {
    margin: 0 0 4px;
    color: #666;
}
.ph-inventory-box .inventory-item {
    display: flex;
    justify-content: space-between;
    padding: 4px 0;
}

/* 商店样式 */
#shop-items-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
}
.shop-item {
    background-color: #f8f9fa;
    border-radius: 12px;
    padding: 12px;
    text-align: center;
}
.shop-item-icon {
    font-size: 28px;
}
.shop-item-name {
    font-weight: 500;
    margin: 8px 0;
}
.shop-item-desc {
    font-size: 12px;
    color: var(--secondary-text);
    min-height: 30px;
}
.shop-item-buy-btn {
    width: 100%;
    padding: 8px;
    border: none;
    border-radius: 8px;
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
    margin-top: 10px;
}
/* --- 【全新】线下剧场 (Offline Scene) 样式 --- */
#offline-scene-page .page-content {
    background-color: #fdfaf4; /* 仿羊皮纸背景 */
    font-family: 'Times New Roman', 'Ma Shan Zheng', serif; /* 使用更像书籍的字体 */
    padding: 20px;
    font-size: 17px;
    line-height: 1.8;
}

#scene-log-container {
    /* 为容器本身添加内边距，而不是给条目 */
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px; /* 控制段落间的距离 */
}
.scene-entry {
    backdrop-filter: blur(8px); /* 关键的磨砂效果 */
    -webkit-backdrop-filter: blur(8px); /* 兼容 Safari */
    border-radius: 12px;
    padding: 12px 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);

    white-space: pre-wrap;
}

.scene-entry.narrative {

}

.scene-entry.user-dialogue {

}
.scene-entry.user-dialogue::before {
    content: '你：';
    font-weight: 600;
}

.scene-entry.user-action {
    font-style: italic; /* 用户行动使用斜体 */
}

.scene-entry.user-internal {
    padding-left: 20px;
    border-left: 2px solid #e9ecef;
}
.scene-entry.user-internal::before {
    content: '(内心) ';
    font-style: normal;
}

#scene-input-mode-selector {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 10px;
}
.scene-input-mode-btn {
    background: #f0f2f5;
    border: 1px solid var(--border-color);
    padding: 6px 15px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 14px;
}
.scene-input-mode-btn.active {
    background-color: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}

/* 聊天记录里“场景回顾”的专属气泡样式 */
.chat-bubble.bubble-scene-summary {
    background-color: #fdfaf4 !important;
    border: 1px solid #e9d8c1;
    color: #654321;
    width: 260px;
    cursor: pointer;
}
.scene-summary-header {
    font-weight: 600;
    padding-bottom: 8px;
    border-bottom: 1px dashed #e9d8c1;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
}
.scene-summary-snippet {
    font-style: italic;
    font-size: 14px;
    max-height: 60px;
    overflow: hidden;
}
.scene-summary-footer {
    margin-top: 10px;
    font-size: 12px;
    text-align: right;
    color: #a08c75;
}

/* 【新增】用户旁白 (上帝视角) 样式 */
.scene-entry.user-narrative {
    color: #6a1b9a; /* 默认紫色 */
    font-weight: bold;
    text-align: center;
    margin: 20px 0;
}

/* 【新增】故事选项容器样式 */
#scene-choices-container {
    padding: 10px 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background-color: rgba(253, 250, 244, 0.8); /* 半透明的羊皮纸色 */
    backdrop-filter: blur(2px);
}
.scene-choice-btn {
    width: 100%;
    padding: 12px;
    font-size: 16px;
    background-color: #fff;
    border: 1px solid #e9d8c1;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
.scene-choice-btn:hover {
    background-color: #fdfaf4;
    border-color: #a08c75;
}
/* --- 【V2 全新】世界书折叠列表样式 --- */
.collapsible-world-book-container {
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f8f9fa;
    transition: box-shadow 0.2s;
}
.collapsible-world-book-container.expanded {
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

.world-book-summary-trigger {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
}
.world-book-summary-trigger:hover {
    background-color: #f1f3f5;
}

.world-book-summary-trigger .title {
    font-weight: 500;
}
.world-book-summary-trigger .chevron-icon {
    width: 20px;
    height: 20px;
    color: var(--secondary-text);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.collapsible-world-book-container.expanded .chevron-icon {
    transform: rotate(90deg);
}

.world-book-checklist-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.35s ease-in-out, padding 0.35s ease-in-out;
    background-color: #fff;
    padding: 0 15px;
    display: flex;
    flex-direction: column;
    gap: 10px; /* 选项之间的垂直间距 */
}
.collapsible-world-book-container.expanded .world-book-checklist-content {
    max-height: 250px; /* 展开后的最大高度，可根据需要调整 */
    overflow-y: auto; /* 如果内容超出，则显示滚动条 */
    padding: 15px;
}

/* 保持单个选项的样式不变，但确保它们是块级元素 */
.wb-link-item {
    display: flex;
    align-items: flex-start; 
    background-color: #fff;
    border-radius: 8px;
    padding:10px 12px;
    cursor: pointer;
    transition: background-color 0.2s;
}
.wb-link-item:hover {
    background-color: #f8f9fa;
}
.wb-link-item input[type="checkbox"] {
   width: 16px;
       height: 16px;
       border: 1px solid var(--border-color);
       border-radius: 3px;
       background-color: #fff;
       cursor: pointer;
       /* 绝对定位，便于控制 */
       position: relative;
       top: 3px;  
}
.wb-link-item input[type="checkbox"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}
.wb-link-item label {
    white-space: normal; /* Allow text to wrap */
        word-break: break-word; /* Break long words if necessary */
        overflow: visible;
        text-overflow: clip;
    
        /* 保持与复选框的间距 */
        margin: 0 0 0 8px !important; 
        line-height: 1.5; /* 增加行高，让多行文本更易读 */
}

input[type="checkbox"]:checked + label {
    font-weight: 600;
    color: var(--accent-color);
}
/* --- 【全新】系统消息卡片美化样式 --- */
.summary-card-base {
    display: inline-block; /* 允许 margin: auto 生效 */
    width: 280px;
    background-color: #FFFFFF;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    padding: 12px 15px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    text-align: left; /* 卡片内文字左对齐 */
}

.summary-card-base:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

.summary-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 8px;
}

.summary-card-header .svg-icon {
    width: 20px;
    height: 20px;
    color: var(--secondary-text);
}

.summary-card-header .title {
    font-weight: 600;
    color: var(--primary-text);
}

.summary-card-content {
    font-size: 14px;
    color: var(--secondary-text);
    line-height: 1.5;
}

.summary-card-footer {
    margin-top: 10px;
    font-size: 13px;
    font-weight: 500;
    color: var(--accent-color);
    text-align: right;
}
/* --- 【全新】纪念日卡片样式 --- */
.anniversary-card {
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 15px;
    color: #ffffff;
    background-size: cover;
    background-position: center;
    position: relative;
    overflow: hidden;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    min-height: 120px;
}
.anniversary-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, rgba(0,0,0,0.1) 100%);
}
.anniversary-card-content {
    position: relative;
    z-index: 2;
}
.anniversary-card .countdown {
    font-size: 28px;
    font-weight: 700;
}
.anniversary-card .countdown.is-today {
    color: #f6e58d;
}
.anniversary-card .countdown-label {
    font-size: 14px;
    opacity: 0.9;
}
.anniversary-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-top: 8px;
}
.anniversary-card .date {
    font-size: 14px;
    opacity: 0.9;
}
.anniversary-card .type-badge {
    position: absolute;
    top: 15px;
    right: 15px;
    background: rgba(255,255,255,0.2);
    padding: 4px 8px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 500;
}

/* --- 【全新 V2.0 精确校准版】全局设置开关样式 --- */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
    flex-shrink: 0; /* 防止在 flex 布局中被压缩 */
}
.switch input { 
    opacity: 0; 
    width: 0; 
    height: 0; 
}
.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 28px; /* 让圆角等于高度，形成完美跑道形 */
    
    /* ▼▼▼ 核心修复：使用 Flexbox 精确对齐 ▼▼▼ */
    display: flex;
    align-items: center; /* 垂直居中 */
    padding: 0 4px; /* 设置左右两边的内边距 */
}
.slider:before {
    /* 【简化】不再需要 position: absolute 和 left/bottom */
    content: "";
    height: 20px;
    width: 20px;
    background-color: white;
    border-radius: 50%;
    transition: .4s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* (可选) 加一点阴影更有质感 */
}

/* ▼▼▼ 核心修复：用 Flexbox 的 justify-content 来控制位置 ▼▼▼ */
input:checked + .slider {
    background-color: var(--accent-color);
    justify-content: flex-end; /* 选中时，让圆圈跑到最右边 */
}

/* --- 【全新】聊天界面图标自定义 --- */
.custom-icon-btn {
    background-size: 60% !important; /* 让图标占按钮的60%，留出边距 */
    background-position: center !important;
    background-repeat: no-repeat !important;
}

/* 规则1: 当输入框按钮有自定义图标时，隐藏原来的SVG图标，并把背景变透明 */
.input-action-btn.has-custom-icon .svg-icon {
    display: none !important;
}
.input-action-btn.has-custom-icon {
    background-color: transparent !important;
}

/* 规则2: 当头部按钮有自定义图标时，隐藏原来的SVG图标 */
.app-header .action-btn.has-custom-icon .svg-icon,
.app-header .back-btn.has-custom-icon .svg-icon {
    display: none !important;
}

/* 规则3: 处理【调用API】按钮的加载状态 */
#call-api-btn.has-custom-icon.is-loading {
    /* 当有自定义图标且在加载时，用加载图标覆盖发送图标 */
    background-image: var(--custom-icon-loading) !important;
     /* 让加载中的图标也转起来 */
    animation: spin 1.5s linear infinite;
}
#call-api-btn.has-custom-icon.is-loading .spinner {
    /* 隐藏默认的CSS边框小菊花 */
    display: none !important;
}



/* --- 【V5 最终精调版】主屏幕美化样式 --- */
#home-screen-content {
    padding: 20px 20px 5px 20px;
    background-size: cover;
    background-position: center;
    color: var(--home-text-color, white);
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
}

.system-bar {
    flex-shrink: 0;
    text-align: center;
    padding: 30px 0 20px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
#home-time { font-size: 52px; font-weight: 600; }
#home-date { font-size: 16px; opacity: 0.8; }

/* 1. 【核心】2x2 网格布局容器 (保持不变) */
.home-main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 15px;
    width: 100%;
    max-width: 420px;
    margin: auto;
    aspect-ratio: 1 / 1;
}

/* 兼容性回退方案 (保持不变) */
@supports not (aspect-ratio: 1 / 1) {
    .home-main-grid { height: 0; padding-bottom: 100%; position: relative; }
    .home-main-grid > * { position: absolute; width: calc(50% - 7.5px); height: calc(50% - 7.5px); }
    .home-main-grid > *:nth-child(1) { top: 0; left: 0; }
    .home-main-grid > *:nth-child(2) { top: 0; right: 0; }
    .home-main-grid > *:nth-child(3) { bottom: 0; left: 0; }
    .home-main-grid > *:nth-child(4) { bottom: 0; right: 0; }
}

/* 2. 【核心】为所有格子创建统一的、透明的“占位容器”样式 */
#home-widget-anniversary, #home-app-grid-top-right, #home-app-chat, #home-widget-music {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 3. 【核心】为格子内部的“可见元素”定义样式 */

/* a. 小组件的内部元素 */
/* a. 小组件的内部元素 */
/* a. 小组件的内部元素 */
.home-widget-inner {
    width: 100%; /* 宽度占满格子 */
    /* 【核心修改】移除 height: 100%; */
    aspect-ratio: 1 / 1; /* 【核心新增】强制宽高比为1:1，即正方形 */
    box-sizing: border-box; /* (推荐新增) 确保padding不会撑大元素 */
    
    padding: 16px;
    border-radius: 28px; /* 推荐保留稍大的圆角 */
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(15px);
    -webkit-backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    background-size: cover;
    background-position: center;
}

/* 纪念日小组件内部文字样式 (无变化) */
.widget-anniversary-days { font-size: 42px; font-weight: 700; }
.widget-anniversary-label { font-size: 14px; opacity: 0.8; }
.widget-anniversary-title { font-size: 16px; font-weight: 500; text-align: right; }

/* b. 右上角 2x2 小图标的网格容器 (它本身也是个格子) */
#home-app-grid-top-right {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 15px;
	 place-items: center;
}

/* c. 聊天App的内部图标元素 */
.app-icon-large-inner {
    width: 85%; /* 让聊天图标为 85% 大小，确保正方形 */
    aspect-ratio: 1 / 1;
    position: relative;
    border-radius: 22%;
    overflow: hidden;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease;
}
.app-icon-large-inner:active { transform: scale(0.95); }

/* d. 音乐小组件的内部元素 */
#home-widget-music-inner {
    width: 95%; /* 让音乐小组件为 95% 大小 */
    height: 95%;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 黑胶唱片相关样式 (无变化) */
.widget-vinyl-container {
    position: relative; width: 100%; padding-bottom: 100%; height: 0;
}
.widget-vinyl-record {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #222;
    background-image: repeating-radial-gradient(circle at center, rgba(255, 255, 255, 0.04) 0, rgba(255, 255, 255, 0.04) 1px, transparent 1px, transparent 2px);
    box-shadow: 0 0 15px rgba(0,0,0,0.4), inset 0 0 10px rgba(0,0,0,0.5);
    border: 1px solid #111; border-radius: 50%; display: flex;
    justify-content: center; align-items: center;
    animation: rotate-vinyl 20s linear infinite; animation-play-state: paused;
}
.widget-vinyl-record.playing { animation-play-state: running; }
.widget-vinyl-cover {
    width: 65%; height: 65%; background-color: #555; background-size: cover;
    background-position: center; border-radius: 50%; border: 1px solid #111;
}

/* 底部 Dock (无变化) */
.bottom-dock {
    flex-shrink: 0; display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
    /* 【核心修改】将背景从半透明黑色，改为半透明白色 */
    background: rgba(255, 255, 255, 0.15); 
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 12px; border-radius: 24px; margin: 15px 10px 0 10px;
}

/* --- 小图标 & Dock 图标样式 --- */
.app-icon-small, .app-icon-dock {
    position: relative; border-radius: 22%; overflow: hidden;
    cursor: pointer; display: flex; flex-direction: column;
    align-items: center; justify-content: center; transition: transform 0.2s ease;
    aspect-ratio: 1 / 1;
}
.app-icon-small {
    width: 75%;
    height: 75%;
}
.app-icon-small:active, .app-icon-dock:active { transform: scale(0.95); }

/* 图标通用内部样式 (背景、SVG等) */
.app-icon-bg {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(255, 255, 255, 0.2); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    z-index: 1;
}
.app-icon-large-inner .svg-icon, .app-icon-small .svg-icon, .app-icon-dock .svg-icon {
    position: relative; z-index: 2; color: white; filter: drop-shadow(0 1px 1px rgba(0,0,0,0.2));
}

/* SVG 图标尺寸 */
.app-icon-large-inner .svg-icon { width: 40%; height: 40%; }
.app-icon-small .svg-icon { width: 50%; height: 50%; }
.app-icon-dock .svg-icon { width: 45%; height: 45%; }

/* App 名称 */
.app-name {
    position: absolute; bottom: 10px; font-size: 14px;
    font-weight: 500; z-index: 2; text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}

/* 隐藏旧列表 */
#home-screen .app-list { display: none; }
/* --- 【新增】心声弹窗样式 (Ins 风格 V2) --- */
#heart-voice-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    /* 遮罩层变暗，更能突出主体 */
    background: rgba(246, 243, 253, 0.4); 
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);

    z-index: 9999;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px;
    box-sizing: border-box;

    opacity: 0;
    transition: opacity 0.25s ease-out;
    pointer-events: none;
    cursor: pointer;
}
#heart-voice-overlay.show {
    opacity: 1;
    pointer-events: auto;
}
#heart-voice-bubble {
    /* 核心：用 padding 和 border-image 实现渐变边框 */
    position: relative; /* 为伪元素定位提供基准 */
    background-color: rgba(255, 255, 255, 0.85); /* 半透明白色背景 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 24px; /* 更大的圆角 */
    padding: 30px 35px;
    max-width: 85%;
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
    cursor: default;
    
    transform: scale(0.9) translateY(10px);
    opacity: 0;
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                opacity 0.25s ease-out;

    /* 用伪元素创建渐变边框，不影响内部布局 */
    border: 2px solid transparent; /* 先创建透明边框占位 */
}
#heart-voice-bubble::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 24px; /* 必须和父元素保持一致 */
    padding: 2px; /* 边框的宽度 */
    /* 这是 Ins 风格的渐变色 */
    background: linear-gradient(45deg, #e7dcf0 0%, #e6b4d9 25%, #c684dc 50%, #ae7acc 75%, #bc1888 100%); 
    -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
    -webkit-mask-composite: destination-out; 
    mask-composite: exclude;
}

#heart-voice-overlay.show #heart-voice-bubble {
    transform: scale(1) translateY(0);
    opacity: 1;
}

#heart-voice-text {
    /* 字体也进行美化 */
    font-family: 'Ma Shan Zheng', 'Inter', sans-serif; /* 优先使用手写体 */
    font-style: normal; /* 手写体一般自带风格，无需斜体 */
    font-weight: 500;
    color: #333; /* 深色文字更清晰 */
    font-size: 20px; /* 字体可以稍大一些 */
    line-height: 1.8;
    position: relative; /* 确保文字在伪元素之上 */
    z-index: 2;
	max-height: 60vh; /* 【新增】限制最大高度为视窗高度的60% */
	    overflow-y: auto;   /* 【新增】当内容超出时，自动显示垂直滚动条 */
	    padding-right: 10px; /* 【新增】为滚动条留出一点空间，防止文字压住滚动条 */
	    text-align: left; /* 【优化】长文本左对齐更易读 */
}

/* 在文字前后加上引号，更有“内心独白”的感觉 */
#heart-voice-text::before {
    content: '“';
    position: absolute;
    top: -15px;
    left: -15px;
    font-size: 40px;
    color: rgba(0,0,0,0.1);
}
#heart-voice-text::after {
    content: '”';
    position: absolute;
    bottom: -25px;
    right: -15px;
    font-size: 40px;
    color: rgba(0,0,0,0.1);
}
/* --- 【导航与页签布局最终修正版】--- */

/* 1. 底部导航栏样式 (这部分不变，但为了完整性再次提供) */
.app-bottom-nav {
    display: flex;
    justify-content: space-around;
    padding: 6px 0 8px;
    border-top: 1px solid var(--border-color);
    background-color: rgba(var(--header-bg-rgb), 0.9);
    backdrop-filter: blur(10px);
    flex-shrink: 0;
}
.app-bottom-nav .nav-btn {
    background: none; border: none; cursor: pointer;
    display: flex; flex-direction: column; align-items: center;
    gap: 4px; padding: 4px 12px; color: var(--secondary-text);
    transition: color 0.2s;
}
.app-bottom-nav .nav-btn .svg-icon { width: 24px; height: 24px; }
.app-bottom-nav .nav-btn span { font-size: 11px; font-weight: 500; }
.app-bottom-nav .nav-btn.active { color: var(--accent-color); }


/* 2. 页签面板通用样式 */
.tab-pane {
    width: 100%; /* 确保面板宽度为100% */
    height: 100%; /* 确保面板高度为100% */
    overflow-y: auto; /* 默认允许滚动 */
    display: none; /* 默认隐藏 */
    flex-direction: column; /* 【关键】所有面板默认都是垂直布局 */
}

/* 【关键】激活的面板用 display: flex 来显示，这样内部的 flex 布局才能生效 */
.tab-pane.active {
    display: flex;
}


/* 3. 联系人页面专属布局 */
/* 搜索框容器：高度固定，不拉伸 */
#contacts-search-wrapper {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0; /* 【关键】防止被压缩 */
}
#contacts-search-input {
    width: 100%; padding: 10px 15px; border-radius: 20px;
    border: none; background-color: #f0f2f5; /* 修改了默认背景色 */
    box-sizing: border-box; font-size: 16px;
}
/* 联系人列表：占据所有剩余空间 */
.contact-list-scroll-area {
    flex-grow: 1; /* 【关键】占据剩余空间 */
    overflow-y: auto; /* 内容超出时滚动 */
    min-height: 0; /* 【关键】一个神奇的flexbox修复，防止内容溢出 */
}
/* 联系人分组标题（这个你已经有了，合并进来） */
.contact-section-header {
    padding: 8px 16px;
    background-color: var(--bg-color);
    font-size: 14px;
    font-weight: 500;
    color: var(--secondary-text);
}


/* 4. “我”页面的美化样式 */
.me-profile-card {
    display: flex; align-items: center; background-color: #fff;
    padding: 20px; border-radius: 16px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s; margin-bottom: 24px;
}
.me-profile-card:hover { 
    transform: translateY(-2px); 
    box-shadow: 0 6px 16px rgba(0,0,0,0.08);
}
.me-avatar {
    width: 64px; height: 64px; border-radius: 18px;
    object-fit: cover; margin-right: 16px;
}
.me-info { flex-grow: 1; }
.me-name { font-size: 20px; font-weight: 600; color: var(--primary-text); }
.me-id { display: block; font-size: 14px; color: var(--secondary-text); margin-top: 6px; }
.me-section {
    background-color: #fff; border-radius: 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06); overflow: hidden;
}
.me-list-item {
    display: flex; align-items: center; padding: 16px 20px;
    cursor: pointer; transition: background-color 0.2s;
}
.me-list-item:not(:last-child) { border-bottom: 1px solid var(--border-color); }
.me-list-item:hover { background-color: #f8f9fa; }
.me-item-icon { width: 22px; height: 22px; margin-right: 16px; }
.me-list-item span { font-size: 16px; color: var(--primary-text); }

    </style>
</head>
<body>
    <!-- SVG Icons -->
    <svg style="display: none;"><defs>
        <symbol id="icon-chat" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></symbol>
        <symbol id="icon-book" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></symbol>
        <symbol id="icon-key" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></symbol>
        <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></symbol>
        <symbol id="icon-settings" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></symbol>
        <symbol id="icon-back" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></symbol>
        <symbol id="icon-chevron-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></symbol>
        <symbol id="icon-send" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></symbol>
        <symbol id="icon-user" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></symbol>
        <symbol id="icon-save" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></symbol>
        <symbol id="icon-mic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line></symbol>
        <symbol id="icon-close" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></symbol>
        <symbol id="icon-file" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></symbol>
        <symbol id="icon-users" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></symbol>
        <symbol id="icon-journal" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4.5A2.5 2.5 0 0 1 6.5 2H16v4l-2-1-2 1V2H6.5A2.5 2.5 0 0 0 4 4.5v15A2.5 2.5 0 0 0 6.5 22H20V8.5"></path>
        <path d="M16 2v4"></path>
        <path d="M22 14a4 4 0 0 0-4-4h-2v8h2a4 4 0 0 0 4-4z"></path>
        </symbol>
        <symbol id="icon-trash" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></symbol>
	    <symbol id="icon-moments" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	        <rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect>
	        <path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path>
	        <line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>
	    </symbol>
	    <symbol id="icon-camera" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	        <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
	        <circle cx="12" cy="13" r="4"></circle>
	    </symbol>
	   <symbol id="icon-heart" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	       <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
	   </symbol>
	    <symbol id="icon-comment" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
	    </symbol>
		<symbol id="icon-music" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
		    <path d="M9 18V5l12-2v13"></path>
		    <circle cx="6" cy="18" r="3"></circle>
		    <circle cx="18" cy="16" r="3"></circle>
		</symbol>
		<symbol id="icon-quill" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
		    <path d="M4 13.5V4a2 2 0 0 1 2-2h8.5L20 7.5V20a2 2 0 0 1-2 2h-5.5"></path>
		    <polyline points="14 2 14 8 20 8"></polyline>
		    <path d="M3 17.5l5-5 2.5 2.5-5 5L3 17.5z"></path>
		</symbol>
		<symbol id="icon-repost" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
		    <path d="m17 1 4 4-4 4"></path>
		    <path d="M3 11v-1a4 4 0 0 1 4-4h14"></path>
		    <path d="m7 23-4-4 4-4"></path>
		    <path d="M21 13v1a4 4 0 0 1-4 4H3"></path>
		</symbol>
		<symbol id="icon-file-doc" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
		    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
		    <polyline points="14 2 14 8 20 8"></polyline>
		    <line x1="16" y1="13" x2="8" y2="13"></line>
		    <line x1="16" y1="17" x2="8" y2="17"></line>
		    <polyline points="10 9 9 9 8 9"></polyline>
		</symbol>
		<symbol id="icon-printer" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></symbol>
		<symbol id="icon-undo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 13v-2a4 4 0 0 0-4-4H8l-4 4 4 4"></path></symbol>
		<symbol id="icon-redo" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 13v-2a4 4 0 0 1 4-4h9l4 4-4 4"></path></symbol>
		<symbol id="icon-bold" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></symbol>
		<symbol id="icon-italic" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></symbol>
		<symbol id="icon-underline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></symbol>
		<symbol id="icon-align-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line></symbol>
         <symbol id="icon-comment" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></symbol>
	    <symbol id="icon-send" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></symbol>
	    <symbol id="icon-bookmark" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></symbol>  
        <symbol id="icon-gift" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path></symbol>
        <symbol id="icon-map-pin" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></symbol>
        <symbol id="icon-check-circle" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></symbol>
        <symbol id="icon-search" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></symbol>
	    <svg style="display: none;"><defs>
	        <symbol id="icon-volume" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
	            <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
	        </symbol>
		<!-- Forum App Icon (New) -->
		<symbol id="icon-forum-new" viewBox="0 0 24 24" fill="currentColor">
		    <path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path>
		</symbol>
		
		<!-- Anniversary App Icon (New) -->
		<symbol id="icon-anniversary-new" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
		    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
		    <line x1="16" y1="2" x2="16" y2="6"></line>
		    <line x1="8" y1="2" x2="8" y2="6"></line>
		    <line x1="3" y1="10" x2="21" y2="10"></line>
		    <path d="M11.99,14.5a2.5,2.5 0 0,1 4.5,0 C16.49,16.5,12,19,12,19C12,19,7.51,16.5,7.5,14.5a2.5,2.5 0 0,1 4.49,0Z" fill="currentColor"></path>
		</symbol>
		        <!-- 【全新】转账图标 (Yen/Yuan Symbol) -->
        <symbol id="icon-transfer-new" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M12 18v-5M8 9l4 4 4-4"></path>
            <path d="M8 13h8"></path>
        </symbol>
	</defs></svg>

    <div class="phone-container">
       <div class="phone-body" id="phone-body">
            <div class="page-stack">
                <!-- Home Screen -->
                <div id="home-screen" class="page active">
                <!-- 【V2 美化版】主屏幕页面内容 -->
                <div class="page-content" id="home-screen-content">
                    <!-- 系统时间栏 (保持不变) -->
                   <div id="home-system-bar" class="system-bar">
                       <div><span id="home-time">10:24</span></div>
                       <div><span id="home-date">8月15日 星期五</span></div>
                   </div>
                
                    <!-- 【核心修改】全新的 2x2 网格布局容器 -->
                    <div class="home-main-grid">
                        <!-- 左上角: 纪念日小组件 -->
                        <div id="home-widget-anniversary"> <!-- 移除 class="home-widget" -->
                            <div class="home-widget-inner"> <!-- ▼▼▼ 用这个新的 div 包裹内容 ▼▼▼ -->
                                <!-- JS会在这里填充内容 -->
                            </div>
                        </div>
                
                        <!-- 右上角: 4个小App图标 -->
                        <div id="home-app-grid-top-right" class="app-grid-small">
                            <!-- JS会在这里填充4个图标 -->
                        </div>
                
                        <!-- 左下角: 聊天大图标 -->
                        <div id="home-app-chat" class="app-icon-large" data-target="chat-list-page">
                             <div class="app-icon-large-inner"> <!-- ▼▼▼ 新增这个 div ▼▼▼ -->
                                 <!-- JS会在这里填充图标内容 -->
                             </div>                               <!-- ▲▲▲ 新增这个 div ▲▲▲ -->
                        </div>

                        <!-- 右下角: 音乐播放器小组件 -->
                        <div id="home-widget-music" data-target="music-app-page"> <!-- 移除 class="home-widget" -->
                            <div id="home-widget-music-inner"> <!-- ▼▼▼ 用这个新的 div 包裹内容 ▼▼▼ -->
                                <!-- JS会在这里填充黑胶唱片 -->
                            </div>
                        </div>
                    </div>
                
                    <!-- 底部Dock栏 (保持不变) -->
                    <div id="home-bottom-dock" class="bottom-dock">
                        <!-- JS会在这里填充4个图标 -->
                    </div>
                </div>
                </div>
                <!-- Chat App Main Page -->
                <div id="chat-list-page" class="page">
                    <!-- 1. 头部结构基本不变，但我们给标题加了个ID，方便后面根据页签切换文字 -->
                    <div class="app-header">
                         <div class="header-left">
                            <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button>
                         </div>
                         <div class="title" id="chat-app-main-title">聊天</div> <!-- 【修改】给标题一个ID -->
                         <div class="header-right">
                            <button class="action-btn" id="add-chat-btn"><svg class="svg-icon"><use href="#icon-plus"></use></svg></button>
                         </div>
                    </div>
                
                    <!-- 2. 【核心修改】这里是新的内容区域容器，它将容纳所有页签面板 -->
                    <div id="chat-app-content" class="page-content" style="padding: 0; display: flex; flex-direction: column;">
                        
                        <!-- 面板1: 聊天列表 (我们把原来的聊天列表容器挪到了这里) -->
                        <div id="tab-pane-chat" class="tab-pane active">
                            <div class="list-view" id="chat-list-container">
                                <!-- JS会在这里填充聊天列表 -->
                            </div>
                        </div>
                
                        <!-- 面板2: 联系人 (布局最终修正版) -->
                        <div id="tab-pane-contacts" class="tab-pane">
                            <!-- 搜索框容器 -->
                            <div id="contacts-search-wrapper">
                                <input type="search" id="contacts-search-input" placeholder="搜索联系人...">
                            </div>
                            <!-- 【修改】列表容器拥有了自己的 class -->
                            <div id="contacts-list-container" class="contact-list-scroll-area">
                                <!-- 联系人列表将由JS动态生成 -->
                            </div>
                        </div>
                
                        <!-- 面板3: 我 (也是全新的结构) -->
                       <div id="tab-pane-me" class="tab-pane" style="padding: 20px 16px; background-color: var(--bg-color);">
                           <!-- "我"页面的内容将由JS动态生成 -->
                           <div id="me-page-container" style="width: 100%;"></div>
                       </div>
                
                    </div>
                
                    <!-- 3. 【核心新增】这是全新的底部导航栏 -->
                    <nav id="app-bottom-nav" class="app-bottom-nav">
                        <button class="nav-btn active" data-tab="chat">
                            <svg class="svg-icon"><use href="#icon-chat"></use></svg>
                            <span>聊天</span>
                        </button>
                        <button class="nav-btn" data-tab="contacts">
                            <svg class="svg-icon"><use href="#icon-users"></use></svg>
                            <span>联系人</span>
                        </button>
                        <button class="nav-btn" data-tab="moments">
                            <svg class="svg-icon"><use href="#icon-moments"></use></svg>
                            <span>朋友圈</span>
                        </button>
                        <button class="nav-btn" data-tab="me">
                            <svg class="svg-icon"><use href="#icon-user"></use></svg>
                            <span>我</span>
                        </button>
                    </nav>
                </div>
                <!-- ↑↑↑ 新版本到这里结束 ↑↑↑ -->
                <!-- Chat Page -->
                <div id="chat-page" class="page">
                    <div class="app-header">
						<div class="header-left">
						<button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button>
						</div>
						<div class="title" id="chat-title">...</div> 
						<!-- ▼▼▼ 这是替换后的新版本 ▼▼▼ -->
						<div class="header-right" >
						
						    <!-- 1. 这是唯一的“更多”按钮 -->
						    <button class="action-btn" id="chat-more-options-btn" title="更多选项">
						        <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
						            <circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>
						        </svg>
						    </button>
						</div>
						<!-- ▲▲▲ 新版本结束 ▲▲▲ -->
						</div>
					<div class="page-content"><div class="chat-messages" id="chat-messages-container"></div></div>
                    <div class="message-input-area">
                        <div id="reply-bar-container" style="display: none;"></div>
                        <div class="input-wrapper">
							 <button id="show-actions-btn" class="input-action-btn secondary" title="更多功能">
							        <svg class="svg-icon"><use href="#icon-plus"></use></svg>
							    </button>
                            <textarea id="message-input" class="flexible-input" placeholder="输入消息..." rows="1"></textarea>
                            <button id="send-as-user-btn" class="input-action-btn secondary" title="以“我”发送"><svg class="svg-icon"><use href="#icon-user"></use></svg></button>
                            <button id="call-api-btn" class="input-action-btn" title="请求AI回复"><svg class="svg-icon"><use href="#icon-send"></use></svg><div class="spinner"></div></button>
                        </div>
                    </div>
                    <div id="multi-select-bar-container" style="display: none;"></div>
                </div>
				<!-- --- 在这里添加新页面 --- -->
				<div id="chat-search-page" class="page">
				    <div class="app-header">
						 <div class="header-left">
				        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
				        <div class="title">搜索聊天记录</div>
						 <div class="header-right"></div>
				    </div>
				    <div class="page-content" style="display: flex; flex-direction: column;">
				        <div style="padding: 12px; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
				            <input type="search" id="chat-search-input" placeholder="搜索..." style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); box-sizing: border-box;">
				        </div>
				        <div id="chat-search-results-container" style="flex-grow: 1; overflow-y: auto;">
				            <!-- 搜索结果将显示在这里 -->
				        </div>
				    </div>
				</div>
                <!-- World Book List Page -->
                <div id="world-book-list-page" class="page">
                    <div class="app-header">
						 <div class="header-left">
						<button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
						<div class="title">世界书</div>
						 <div class="header-right">
						<button class="action-btn" id="add-world-book-btn"><svg class="svg-icon"><use href="#icon-plus"></use></svg></button></div>
						</div>
                    <div class="page-content list-view" id="world-book-list-container"></div>
                </div>
                <!-- World Book Edit Page -->
                <div id="world-book-edit-page" class="page">
                     <div class="app-header"><div class="header-left"><button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div><div class="title" id="world-book-edit-title">编辑世界书</div><div class="header-right"><button class="action-btn" id="save-world-book-btn"><svg class="svg-icon"><use href="#icon-save"></use></svg></button></div></div>
                    <div class="page-content" style="padding: 20px;"><input type="hidden" id="world-book-edit-id"><div class="form-group"><label for="world-book-title-input">标题</label><input type="text" id="world-book-title-input" placeholder="例如：世界背景、角色A设定"></div><div class="form-group"><label for="world-book-content-input">内容</label><textarea id="world-book-content-input" placeholder="输入该世界书的具体设定..."></textarea></div><button class="btn btn-primary destructive" id="delete-world-book-btn" style="background-color:#E53935;">删除此条目</button></div>
                </div>
               <!-- API Settings Page (全新升级版) -->
               <div id="api-settings-page" class="page">
                   <div class="app-header">
					   <div class="header-left">
                       <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
                       <div class="title">API 设置</div>
                       <!-- 移除旧的保存按钮，新逻辑在页面内 -->
                   </div>
                   <div class="page-content" style="padding: 20px;">
                       
                       <!-- Part 1: 当前使用的配置 -->
                       <div class="api-card-new">
                           <h3 class="api-card-title">当前配置</h3>
                           <div class="form-group">
                               <label for="current-api-name">配置名称</label>
                               <input type="text" id="current-api-name" readonly style="background:#eee;">
                           </div>
                           <div class="form-group">
                               <label for="current-api-model">默认模型</label>
                               <select id="current-api-model" name="model"></select>
                           </div>
                           <button type="button" class="btn btn-primary" id="save-current-model-btn">保存默认模型</button>
                       </div>
               
                       <!-- Part 2: API 仓库管理 -->
                       <div class="api-card-new" style="margin-top:25px;">
                           <h3 class="api-card-title">API 仓库</h3>
                           <div id="api-list-container">
                               <!-- 保存的 API 列表会在这里动态生成 -->
                           </div>
                           <button type="button" class="btn btn-secondary" id="show-add-api-form-btn" style="margin-top:15px;">+ 添加新 API 配置</button>
                       </div>
               
                       <!-- Part 3: 添加新配置的表单 (默认隐藏) -->
                       <div id="add-api-form-container" class="api-card-new" style="margin-top:25px; display:none;">
                           <h3 class="api-card-title">添加新配置</h3>
                           <form id="api-form">
							    <input type="hidden" id="editing-api-id">
                               <div class="form-group">
                                   <label for="api-provider">使用模板快速填写</label>
                                   <select id="api-provider" name="provider">
                                       <option value="newapi">自定义</option>
                                       <option value="deepseek">DeepSeek</option>
                                       <option value="claude">Claude (Anthropic)</option>
                                       <option value="gemini">Gemini (Google AI)</option>
                                   </select>
                               </div>
                               <div class="form-group">
                                   <label for="api-name">配置名称 (例如: 主力线路, 备用线路)</label>
                                   <input type="text" id="api-name" name="name" placeholder="给这个配置起个名字" required>
                               </div>
                               <div class="form-group">
                                   <label for="api-url">API 地址</label>
                                   <input type="url" id="api-url" name="url" placeholder="例如: https://api.openai.com" required>
                               </div>
                               <div class="form-group">
                                   <label for="api-key">密钥 (Key)</label>
                                   <input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required>
                               </div>
                               <button type="button" class="btn btn-secondary" id="test-and-save-api-btn">
                                   <span class="btn-text">测试并保存</span>
                                   <div class="spinner"></div>
                               </button>
                               <button type="button" id="cancel-add-api-btn" style="background:none; border:none; color:var(--secondary-text); text-align:center; width:100%; padding:10px; margin-top:10px; cursor:pointer;">取消</button>
                           </form>
                       </div>
                   </div>
               </div>

                <!-- Chat Settings Page (Single) -->
                <div id="chat-settings-page" class="page">
                    <div class="app-header">
						 <div class="header-left">
						<button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
						<div class="title">聊天设置</div>
						 <div class="header-right"><button class="action-btn" id="save-chat-settings-btn"><svg class="svg-icon"><use href="#icon-save"></use></svg></button></div></div>
                    <div class="page-content" style="padding: 20px;">
                        <div class="form-group"><label>对方的称呼</label><input type="text" id="setting-ai-name"></div>
                        <div class="form-group"><label>对方的头像</label><div class="avatar-upload-group"><img id="ai-avatar-preview" class="avatar-preview"><label class="upload-btn">上传图片<input type="file" id="setting-ai-avatar" accept="image/*" style="display:none;"></label></div></div>
                        <div class="form-group"><label>对方的人设 (AI将扮演)</label><textarea id="setting-ai-persona"></textarea></div>
                        <hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
                        <div class="form-group"><label>你的头像</label><div class="avatar-upload-group"><img id="user-avatar-preview" class="avatar-preview"><label class="upload-btn">上传图片<input type="file" id="setting-user-avatar" accept="image/*" style="display:none;"></label></div></div>
                        <div class="form-group"><label>你的人设 (AI如何看待你)</label><textarea id="setting-user-persona"></textarea></div>
                        <div class="form-group"><label>连接的世界书</label><div id="world-book-link-container"></div></div>
                        <div class="form-group">
                            <label for="setting-memory-depth">AI 记忆深度 (最近消息数)</label>
                            <input type="number" id="setting-memory-depth" min="2" max="50" value="12" placeholder="建议 8-20">
                            <p style="font-size: 12px; color: var(--secondary-text); margin-top: 5px;">此设置影响AI能记住的上下文长度，不影响页面加载。数值越高，API费用越高。</p>
                        </div>
                        <!-- ADDED: Chat Background Setting -->
                        <div class="form-group">
                            <label>聊天背景</label>
                            <div class="avatar-upload-group" style="gap: 8px;">
                                <img id="chat-bg-preview" class="avatar-preview" style="border-radius: 8px; width: 80px; height: 80px; object-fit: cover;">
                                <div style="flex-grow:1; display:flex; flex-direction: column; gap: 8px;">
                                    <label class="upload-btn" style="margin:0;">上传背景<input type="file" id="setting-chat-bg" accept="image/*" style="display:none;"></label>
                                    <button id="clear-chat-bg-btn" class="btn" style="padding: 10px; background: #aaa; margin: 0;">清除背景</button>
                                </div>
                            </div>
                        </div>
						<!-- =========== 开始：新增气泡美化功能区 =========== -->
						 <hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
                        <div class="form-group">
                            <label>气泡美化 (自定义CSS)</label>
                            <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
                                在此输入CSS代码可美化当前聊天的气泡、头像框、时间戳等。
                            </p>
                            
                            <!-- 预览区域 -->
                            <div id="css-preview-container" class="css-preview-area">
                                <style id="css-preview-style"></style> <!-- 用于实时预览的样式标签 -->
                                <div class="message-row ai">
                                    <div class="avatar-wrapper">
                                        <img id="preview-ai-avatar" class="chat-avatar" src="">
                                    </div> 
                                    <div class="message-content">
                                        <div class="chat-bubble">这是对方的气泡预览。</div>
										<div class="member-name">对方</div>
										 <div class="message-timestamp">10:30</div>
                                    </div>
                                </div>
                                <div class="message-row user">
                                    <div class="message-timestamp">10:31</div>
                                    <div class="message-content">
                                        <div class="chat-bubble">这是你的气泡预览。</div>
                                    </div>
                                     <div class="avatar-wrapper">
                                         <img id="preview-user-avatar" class="chat-avatar" src="">
                                     </div>
                                </div>
                            </div>

                            <textarea id="setting-custom-css" 
								placeholder="/* 用户气泡 */.message-row.user .chat-bubble /* AI气泡 */.message-row.ai .chat-bubble .message-row.user .chat-avatar /* AI头像框 */.message-row.ai .chat-avatar /* 时间戳 */.message-timestamp /* 群聊成员名字 */.member-name "></textarea>
                            <button id="restore-custom-css-btn" class="btn btn-secondary" style="margin-top: 10px; background-color: #6c757d;">恢复默认样式</button>
                        </div>
						<hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
						<!-- 【全新】视频通话形象库设置 -->
						<div class="form-group">
						    <label>视频通话形象库</label>
						    <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
						        为AI在视频通话中设置不同情绪的形象。
						    </p>
						    <div id="video-call-images-container" style="display: flex; flex-direction: column; gap: 15px;">
						        <!-- 图片列表会由 JS 动态生成在这里 -->
						    </div>
						    <button id="add-video-image-btn" class="btn btn-secondary" style="margin-top: 12px;">+ 添加新形象</button>
						</div>
						<!-- 在“对方的人设”textarea 后面添加 -->
						<div class="form-group">
						    <label for="setting-ai-voice">通话音色</label>
						    <select id="setting-ai-voice">
						        <!-- 声音选项将由 JS 动态填充 -->
						    </select>
						</div>
                        <hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
                        <button class="btn btn-primary destructive" id="delete-chat-btn" style="background-color:#E53935;">删除此聊天</button>
                    </div>
                </div>
				<!-- ADDED: Diary Feature Pages -->
				<!-- Diary Character List Page -->
				<div id="diary-character-list-page" class="page">
				    <div class="app-header">
				         <div class="header-left"><button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
				        <div class="title">AI 的日记本</div>
				    </div>
				    <div class="page-content list-view" id="diary-character-list-container">
				        <!-- 角色列表将由 JS 动态生成 -->
				    </div>
				</div>
				
				<!-- Diary Date List Page -->
				<div id="diary-date-list-page" class="page">
				    <div class="app-header">
						 <div class="header-left">
				        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
				        <div class="title" id="diary-character-name">...的日记</div>
				    </div>
				    <div class="page-content list-view" id="diary-date-list-container">
				        <!-- 日期列表将由 JS 动态生成 -->
				    </div>
				</div>
				
				<!-- Diary Entry Page -->
				<div id="diary-entry-page" class="page">
				    <div class="app-header">
				        <div class="header-left">
				            <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button>
				        </div>
				        <div class="title">阅读日记</div>
				        <!-- 【核心新增】在这里为删除按钮创建一个容器 -->
				        <div class="header-right">
				            <button class="action-btn" id="header-delete-diary-btn" title="删除日记">
				                <svg class="svg-icon"><use href="#icon-trash"></use></svg>
				            </button>
				        </div>
				    </div>
				    <div class="page-content" id="diary-entry-content-area">
				        <!-- 日记内容将由 JS 动态生成 -->
				    </div>
				</div>

                <!-- ADDED: Group Chat Settings Page -->
                <div id="group-chat-settings-page" class="page">
                    <div class="app-header">
						 <div class="header-left">
						<button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
						<div class="title">群聊设置</div> <div class="header-right"><button class="action-btn" id="save-group-chat-settings-btn"><svg class="svg-icon"><use href="#icon-save"></use></svg></button></div></div>
                    <div class="page-content" style="padding: 20px;">
                        <div class="form-group"><label>群聊名称</label><input type="text" id="setting-group-name"></div>
                        <div class="form-group">
                            <label>群成员</label>
                            <div id="group-members-list" class="list-view" style="border: 1px solid var(--border-color); border-radius: 8px;"></div>
                            <button id="add-group-member-btn" class="btn btn-secondary" style="margin-top: 12px;">+ 添加新成员</button>
                        </div>
                        <hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
                        <div class="form-group"><label>你的头像</label><div class="avatar-upload-group"><img id="group-user-avatar-preview" class="avatar-preview"><label class="upload-btn">上传图片<input type="file" id="setting-group-user-avatar" accept="image/*" style="display:none;"></label></div></div>
                        <div class="form-group"><label>你的人设 (AI如何看待你)</label><textarea id="setting-group-user-persona"></textarea></div>
                        <div class="form-group"><label>连接的世界书</label><div id="group-world-book-link-container"></div></div>
                        <div class="form-group">
                            <label for="setting-group-memory-depth">AI 记忆深度 (最近消息数)</label>
                            <input type="number" id="setting-group-memory-depth" min="2" max="50" value="12" placeholder="建议 8-20">
                            <p style="font-size: 12px; color: var(--secondary-text); margin-top: 5px;">此设置影响AI能记住的上下文长度，不影响页面加载。数值越高，API费用越高。</p>
                        </div>
                        <div class="form-group">
                            <label>聊天背景</label>
                            <div class="avatar-upload-group" style="gap: 8px;">
                                <img id="group-chat-bg-preview" class="avatar-preview" style="border-radius: 8px; width: 80px; height: 80px; object-fit: cover;">
                                <div style="flex-grow:1; display:flex; flex-direction: column; gap: 8px;">
                                    <label class="upload-btn" style="margin:0;">上传背景<input type="file" id="setting-group-chat-bg" accept="image/*" style="display:none;"></label>
                                    <button id="clear-group-chat-bg-btn" class="btn" style="padding: 10px; background: #aaa; margin: 0;">清除背景</button>
                                </div>
                            </div>
                        </div>
						<hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
						 <!-- =========== 开始：新增气泡美化功能区 (群聊) =========== -->
                        <div class="form-group">
                            <label>气泡美化 (自定义CSS)</label>
                            <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
                                在此输入CSS代码可美化当前聊天的气泡、头像框、时间戳等。
                            </p>
                            
                            <!-- 预览区域 -->
                            <div id="group-css-preview-container" class="css-preview-area">
                                <style id="group-css-preview-style"></style> <!-- 用于实时预览的样式标签 -->
                                <div class="message-row ai">
                                    <div class="avatar-wrapper">
                                        <img id="group-preview-ai-avatar" class="chat-avatar" src="">
                                    </div><!-- 移除src, 加上id -->
                                    <div class="message-content">
                                       <div class="chat-bubble">这是对方的气泡预览。</div>
                                       <div class="member-name">对方</div>
                                        <div class="message-timestamp">10:30</div>
                                    </div>
                                </div>
                                <div class="message-row user">
                                    <div class="message-timestamp">10:31</div>
                                    <div class="message-content">
                                        <div class="chat-bubble">这是你的气泡预览。</div>
                                    </div>
                                    <div class="avatar-wrapper">
                                        <img id="group-preview-user-avatar" class="chat-avatar" src="">
                                    </div> <!-- 移除src, 加上id -->
                                </div>
                            </div>

                            <textarea id="setting-group-custom-css" 
                                placeholder="/* 用户气泡 */.message-row.user .chat-bubble /* AI气泡 */.message-row.ai .chat-bubble /* 用户头像框 */.message-row.user .chat-avatar /* AI头像框 */.message-row.ai .chat-avatar /* 时间戳 */.message-timestamp /* 群聊成员名字 */.member-name "></textarea>
                            <button id="restore-group-custom-css-btn" class="btn btn-secondary" style="margin-top: 10px; background-color: #6c757d;">恢复默认样式</button>
                        </div>
                        <hr style="border:none; border-top: 1px solid var(--border-color); margin: 24px 0;">
                        <button class="btn btn-primary destructive" id="delete-group-chat-btn" style="background-color:#E53935;">删除此群聊</button>
                    </div>
                </div>

				<!-- Fanfic Forum Page (同人论坛主页) -->
				<div id="fanfic-forum-page" class="page">
				    <div class="app-header">	
						 <div class="header-left">
				        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button>
				        </div>
						<div class="title">论坛</div>
				        <!-- 这是你要求的小小的刷新按钮 -->
						<div class="header-right">
						<button class="action-btn" id="toggle-fanfic-search-btn" title="筛选">
						            <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
						            </svg>
						        </button>
						<button class="action-btn" id="my-likes-btn" title="我的喜欢">
						    <svg class="svg-icon"><use href="#icon-heart"></use></svg>
						</button>
				        <button class="action-btn" id="refresh-fanfic-btn">
				            <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
				        </button>
						</div>
				    </div>
					<div id="fanfic-search-container" >
					    <div id="fanfic-search-controls" style="display: flex; flex-direction: column; gap: 10px;"><!-- 上方：角色选择区域 -->
					        <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
					            <span style="font-size: 14px; color: var(--secondary-text); flex-shrink: 0;">角色:</span>
					            <!-- 选中的角色标签会显示在这里 -->
					            <div id="fanfic-char-pills-container" style="display: flex; gap: 6px; flex-wrap: wrap;"></div>
					            <!-- 添加角色的按钮 -->
					            <button id="fanfic-add-char-btn" style="background: none; border: 1px dashed var(--border-color); border-radius: 50%; width: 24px; height: 24px; cursor: pointer; color: var(--secondary-text); font-size: 16px; line-height: 22px;">+</button>
					        </div>
					        <!-- 下方：关键词输入框 (保持不变) -->
					        <input type="text" id="fanfic-keyword-input" placeholder="输入关键词,用逗号隔开" style="width: 100%; box-sizing: border-box; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
					    </div>
					</div>
				    <div class="page-content" id="fanfic-feed-container">
				        <!-- 同人文卡片列表将由 JS 动态生成 -->
				        <!-- 初始状态可以是空白或提示信息 -->
				        <div class="fanfic-empty-state">
				            <svg class="svg-icon" style="width:60px; height:60px; color: #ccc;"><use href="#icon-quill"></use></svg>
				            <p>点击右上角刷新，发现新故事</p>
				        </div>
				    </div>
				</div>
				
				 <!-- 喜欢的文章 -->
				<div id="fanfic-likes-page" class="page">
				    <div class="app-header">
						 <div class="header-left">
				        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
				        <div class="title">我的喜欢</div>
				    </div>
				    <div class="page-content" id="fanfic-likes-container" style="padding: 12px 0;">
				        <!-- 喜欢的文章列表将由 JS 动态生成 -->
				    </div>
				</div>

				
				<!-- Fanfic Detail Page (文章详情页) -->
				<div id="fanfic-detail-page" class="page">
				    <div class="app-header">
						 <div class="header-left">
				        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
				        <div class="title">文章详情</div>
						<div class="header-right">
						    <button class="action-btn" id="header-delete-fanfic-btn" title="删除文章">
						    <svg class="svg-icon"><use href="#icon-trash"></use></svg>
						    </button>
						</div>
				    </div>
				    <div class="page-content" id="fanfic-detail-container">
				        <!-- 文章和评论将由 JS 动态生成 -->
				    </div>
				    <!-- 底部评论输入框 -->
				   <div class="message-input-area">
				           <div class="input-wrapper">
				               <textarea id="fanfic-comment-input" class="flexible-input" placeholder="留下你的评论..." rows="1"></textarea>
				               <button id="submit-fanfic-comment-btn" class="input-action-btn">
				                   <svg class="svg-icon"><use href="#icon-send"></use></svg>
				               </button>
				           </div>
				       </div>
				   </div>
				   
			<!-- --- 全新的音乐 App 页面 --- -->
			<div id="music-app-page" class="page">
			    <!-- 侧边栏 (管理播放列表和上传) -->
			    <div id="music-sidebar">
			        <div class="sidebar-header">
			            <h3>播放列表</h3>
			        </div>
			        <div id="music-playlist-sidebar-container" class="sidebar-content">
			            <!-- 播放列表将由 JS 动态生成 -->
			        </div>
			        <div class="sidebar-footer">
			            <button id="add-song-sidebar-btn" class="btn btn-primary">添加歌曲</button>
			        </div>
			    </div>
			    <div id="music-main-content">
			        <div class="app-header" style="background: transparent; border: none;">
						 <div class="header-left">
			            <button class="back-btn"><svg class="svg-icon" style="color: #fff;"><use href="#icon-back"></use></svg></button></div>
			            <div class="title" style="color: #fff;" id="music-app-title">...</div>
						 <div class="header-right">
			            <button class="action-btn" id="toggle-playlist-sidebar-btn">
			                <svg class="svg-icon" style="color: #fff;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
			            </button>
						</div>
			        </div>
			        <div class="page-content" id="music-player-main-view">
			            <!-- 黑胶唱片 -->
			            <div id="vinyl-container" class="vinyl-container">
			                <div class="vinyl-arm"></div>
			                <div class="vinyl-record">
			                    <div class="vinyl-cover" id="vinyl-cover-img"></div>
			                </div>
			            </div>
			
			            <!-- 歌词滚动区域 -->
			            <div class="lyrics-view-main" id="main-lyrics-container">
			                <p>暂无歌词</p>
			            </div>
			
			            <!-- 进度条和时间 -->
			            <div class="main-progress-container">
			                <span id="music-current-time">00:00</span>
			                <div class="progress-bar-main">
			                    <div class="progress-filled-main"></div>
			                    <div id="progress-handle-main" class="progress-handle-main"></div>
			                </div>
			                <span id="music-duration">00:00</span>
			            </div>
			
			            <!-- 控制按钮 -->
			            <div class="music-app-controls">
			                <button id="main-play-mode-btn" class="control-btn"></button>
			                <button id="main-prev-btn" class="control-btn"><svg viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg></button>
			                <button id="main-play-pause-btn" class="control-btn play-btn"></button>
			                <button id="main-next-btn" class="control-btn"><svg viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></svg></button>
			                <button id="main-change-wallpaper-btn" class="control-btn" title="更换壁纸">
			                    <svg viewBox="0 0 24 24"><path d="M20 3H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h3l-1 2v1h12v-1l-1-2h3c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM4 16V5h16v11H4zm6.5-7.5l-2.5 3.01L7 10l-3 4h12l-4-5z"></path></svg>
			                </button>
			            </div>
			        </div>
			    </div>
				<div id="full-lyrics-view">
				    <div class="lyrics-list">
				        <!-- 歌词行将由JS动态生成 -->
				    </div>        
				</div>
			</div>	   

			<!-- Moments Page (朋友圈主页) -->
			<div id="moments-page" class="page">
			    <div class="page-content" style="background-color: #fff; padding-top: 0;"> <!-- 【修改】去掉了内边距 -->
			        <button class="back-btn moments-floating-btn moments-back-btn">
			            <svg class="svg-icon"><use href="#icon-back"></use></svg>
			        </button>
			        <button class="action-btn moments-floating-btn moments-camera-btn" id="post-new-moment-btn">
			            <svg class="svg-icon"><use href="#icon-camera"></use></svg>
			        </button>
					<div class="moments-profile-header" id="moments-profile-header">
			            <div class="profile-cover-image" id="moments-cover-image"></div>
			            
			            <!-- 【修改】将签名和名字放在同一个容器里 -->
			            <div class="profile-info">
			                <div class="profile-text-content">
			                    <span class="profile-name" id="moments-user-name">我</span>
			                    <div class="profile-signature" id="moments-signature">点击设置个性签名</div>
			                </div>
			                <img class="profile-avatar" id="moments-user-avatar" src="">
			            </div>
			            <!-- 原来的签名位置已删除 -->
			        </div>
			        
			        <div id="moments-feed-container">
			            <!-- 朋友圈动态将由 JS 动态生成 -->
			        </div>
			    </div>
			</div>

			
			<!-- Post New Moment Page (发布朋友圈页面) -->
			<div id="post-moment-page" class="page">
			    <div class="app-header">
					 <div class="header-left">
			        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
			        <div class="title">发布动态</div>
					 <div class="header-right">
			        <button class="action-btn" id="save-moment-btn" style="color: var(--accent-color); font-weight: 600; font-size: 16px;">发布</button></div>
			    </div>
			    <div class="page-content" style="padding: 20px;">
			        <div class="form-group">
			            <textarea id="moment-text-input" placeholder="分享新鲜事..." style="min-height: 150px;"></textarea>
			        </div>
			        <div class="form-group">
			            <label>添加图片 (可选)</label>
			            <div class="avatar-upload-group">
			                <img id="moment-image-preview" class="avatar-preview" style="border-radius: 8px; width: 100px; height: 100px; object-fit: cover; display: none;">
			                <label id="moment-image-upload-label" class="upload-btn" style="flex-grow: 1;">
			                    上传图片
			                    <input type="file" id="moment-image-input" accept="image/*" style="display:none;">
			                </label>
			            </div>
						<div id="moment-image-desc-group" class="form-group"  margin-top: 15px;">
						    <label for="moment-image-desc-input">图片描述 </label>
						    <input type="text" id="moment-image-desc-input" placeholder="例如：一只正在打哈欠的猫">
						</div>
			        </div>
			    </div>
			</div>
			<!-- 【全新】模拟来电界面 -->
			<div id="incoming-call-overlay" class="incoming-call-overlay">
			    <audio id="ringtone" src="https://files.catbox.moe/gr7r8w.mp3" loop></audio> <!-- 默认铃声 -->
			    
			    <!-- VVVV 就是这个元素！请确保它在这里 VVVV -->
			    <div id="incoming-call-background" class="incoming-call-background"></div>
			    <!-- ^^^^ 就是这个元素！请确保它在这里 ^^^^ -->
			
			    <div class="call-ui-container"> <!-- 复用通话页面的布局 -->
			        <div class="call-header" style="margin-top: 50px;">
			            <img id="incoming-call-avatar" src="" class="call-avatar" style="width: 120px; height: 120px;">
			            <div id="incoming-call-name" class="call-name" style="font-size: 28px;">...</div>
			            <div id="incoming-call-type" class="call-status">邀请你进行视频通话...</div>
			        </div>
			
			        <div class="incoming-call-actions">
			            <div class="incoming-action-item">
			                <button id="decline-call-btn" class="incoming-action-btn decline"></button>
			                <span>拒绝</span>
			            </div>
			            <div class="incoming-action-item">
			                <button id="accept-call-btn" class="incoming-action-btn accept"></button>
			                <span>接听</span>
			            </div>
			        </div>
			    </div>
			</div>
			<!-- 歌曲添加 -->
			<!-- --- 更新：添加/编辑歌曲的通用页面 --- -->
			<div id="add-song-page" class="page">
			    <div class="app-header">
					 <div class="header-left">
			        <button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
			        <!-- 1. 给标题加上ID -->
			        <div id="add-edit-song-page-title" class="title">添加歌曲</div>
					 <div class="header-right">
			        <button class="action-btn" id="save-new-song-btn">
			            <svg class="svg-icon"><use href="#icon-save"></use></svg>
			        </button></div>
			    </div>
			    <div class="page-content" style="padding: 20px;">
			        <!-- 2. 增加一个隐藏的输入框来存储歌曲ID -->
			        <input type="hidden" id="editing-song-id">
			
			        <div class="form-group">
			            <label for="new-song-title">歌曲名</label>
			            <input type="text" id="new-song-title" placeholder="必填">
			        </div>
			        <div class="form-group">
			            <label for="new-song-artist">歌手</label>
			            <input type="text" id="new-song-artist" placeholder="必填">
			        </div>
			        
			        <div class="form-group">
			            <label>歌曲封面 (可选)</label>
			            <div class="avatar-upload-group">
			                <img id="new-song-cover-preview" class="avatar-preview" style="border-radius: 8px; width: 64px; height: 64px; object-fit: cover; background-color: #333;">
			                <label class="upload-btn" for="new-song-cover-file-input" style="flex-grow: 1;">
			                    上传图片
			                    <input type="file" id="new-song-cover-file-input" accept="image/*" style="display:none;">
			                </label>
			            </div>
			            <input type="hidden" id="new-song-cover-base64">
			        </div>
			
			        <div class="form-group">
			            <label for="new-song-url">歌曲文件或URL</label>
			            <input type="text" id="new-song-url" placeholder="输入URL或从下方上传">
			            <label class="upload-btn" for="new-song-file-input" style="margin-top:8px;">
			                选择本地音频文件
			                <input type="file" id="new-song-file-input" accept="audio/*" style="display:none;">
			            </label>
			            <span id="file-name-display" style="font-size: 12px; color: var(--secondary-text); margin-left: 10px;"></span>
			        </div>
			        <div class="form-group">
			            <label for="new-song-lrc">LRC 歌词 (可选)</label>
			            <textarea id="new-song-lrc" placeholder="[00:12.34]这里是歌词..." style="min-height: 120px;"></textarea>
			        </div>
			    </div>
			</div>

            </div>
			<div id="chat-header-menu" class="context-menu" style="display: none;">
                <!-- 菜单项保持不变 -->
                <div class="context-menu-item" data-action="search">
                    <svg class="svg-icon" style="width: 18px; height: 18px; margin-right: 8px;"><use href="#icon-search"></use></svg>
                    <span>搜索记录</span>
                </div>
                <div class="context-menu-item" data-action="music">
                    <svg class="svg-icon" style="width: 18px; height: 18px; margin-right: 8px;"><use href="#icon-music"></use></svg>
                    <span>一起听歌</span>
                </div>
                <div class="context-menu-item" data-action="settings">
                    <svg class="svg-icon" style="width: 18px; height: 18px; margin-right: 8px;"><use href="#icon-settings"></use></svg>
                    <span>聊天设置</span>
                </div>
            </div>
            <div class="toast" id="toast"></div>
            <div id="context-menu" class="context-menu" style="display: none;"></div>
            <div id="modal-overlay"><div id="modal-content"></div></div>
			<div id="interactive-modal" class="modal-overlay">
			    <div class="modal-content">
			        <!-- JavaScript 会把礼物详情等内容填充到这里 -->
			        <div id="interactive-modal-content"></div>
			    </div>
			</div>
			<!-- --- 【全新】一起听歌弹窗 --- -->
			<div id="listen-together-overlay" class="lt-overlay">
			    <div id="listen-together-modal" class="lt-modal">
			        <!-- 弹窗顶部拖动条/关闭区域 -->
			        <div class="lt-header-bar">
			            <div class="lt-drag-handle"></div>
			            <button id="lt-close-btn" class="lt-close-btn">&times;</button>
			        </div>
			
			        <!-- 头像和计时器 -->
			        <div class="lt-profile-section">
			            <<div class="lt-avatars" id="lt-avatars">
			                <img id="lt-avatar-user" src="" class="lt-avatar">
			                <img id="lt-avatar-ai" src="" class="lt-avatar">
			            </div>
			            <h2 id="lt-title">一起听歌中</h2>
			            <p id="lt-timer">已开始 00:00</p>
			        </div>
			
			        <!-- 当前播放 -->
			        <div class="lt-current-song-card">
			            <img id="lt-current-cover" src="https://files.catbox.moe/608ojk.jpg" class="lt-current-cover">
			            <div class="lt-current-info">
			                <h3 id="lt-current-title">暂未播放</h3>
			                <p id="lt-current-artist">点击列表开始</p>
			            </div>
			             <button id="lt-play-pause-btn" class="lt-play-pause-btn"></button>
			        </div>
			
			        <!-- 播放列表 -->
			        <div class="lt-playlist-section">
			            <h4>播放列表</h4>
			            <div id="lt-playlist-container" class="lt-playlist-container">
			                <!-- 列表项将由 JS 动态生成 -->
			            </div>
			        </div>
			        
			        <!-- 添加歌曲按钮 -->
			        <button id="lt-add-song-btn" class="btn btn-primary" style="margin-top: 15px;">+ 添加歌曲</button>
			    </div>
			</div>
			<!-- 【全新】通话页面 -->
			<!-- 【V2 优化版】通话页面 -->
			<!-- 【V3 终极布局版】通话页面 -->
			<div id="call-page" class="page">
			    <div id="call-background"></div>
			    <div id="call-overlay"></div>
			
			    <div class="call-ui-container">
			        <!-- 顶部信息 -->
			        <div class="call-header">
			            <img id="call-avatar" src="" class="call-avatar">
			            <div id="call-name" class="call-name">...</div>
			            <div id="call-status" class="call-status">正在连接...</div>
			        </div>
			
			        <!-- 中间空白区域，由聊天记录填充 -->
			        <div class="call-history-wrapper">
			             <div id="call-history-log" class="call-history-log">
			                <!-- 记录会由 JS 动态生成在这里 -->
			            </div>
			        </div>
			
			        <!-- 底部控制区域 -->
			        <div class="call-controls">
			            <div id="call-input-wrapper" class="call-input-wrapper">
			                <input type="text" id="call-input" placeholder="输入文字...">
			                <button id="call-send-btn" data-call-action="send">发送</button>
			            </div>
			
			            <!-- 【V3】终极操作按钮 -->
			            <div class="call-actions-final">
			                   <div class="call-action-item">
			                       <div class="call-action-button" id="call-toggle-input-btn" data-call-action="toggle-input">
			                           <svg><use href="#icon-key"></use></svg>
			                       </div>
			                       <span>键盘</span>
			                   </div>
			                   <div class="call-action-item">
			                       <div class="call-action-button" id="call-toggle-mute-btn" data-call-action="toggle-mute">
			                           <svg id="call-mute-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
			                               <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
			                               <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
			                           </svg>
			                       </div>
			                       <span id="call-mute-label">静音</span>
			                   </div>
			                   <div class="call-action-item" id="call-hangup-wrapper">
			                       <button class="call-hangup-btn"></button>
			                   </div>
			               </div>
			        </div>
			    </div>
			</div>
			<!-- 【V3.0 终极弹窗交互版】表情包库弹窗 -->
			<div id="sticker-library-overlay" class="lt-overlay">
			    <div id="sticker-library-modal" class="lt-modal" style="max-height: 70%;">
			        <!-- 弹窗顶部：标题、添加按钮、关闭按钮 -->
			        <div class="lt-header-bar" style="justify-content: space-between; align-items: center; margin-bottom: 10px;">
			                    <h3 style="margin: 0; color: var(--primary-text);">表情包</h3>
			                    
			                    <!-- ▼▼▼ 核心修改：把关闭按钮也放进这个 div 里，实现完美对齐 ▼▼▼ -->
			                    <div style="display: flex; align-items: center; gap: 10px;">
			                        <button id="add-single-sticker-btn" class="btn btn-secondary" style="padding: 6px 12px; font-size: 14px; margin: 0;">添加单个</button>
			                        <button id="batch-add-sticker-btn" class="btn" style="padding: 6px 12px; font-size: 14px; margin:0; background-color:#6C757D; color:white;">批量添加</button>
			                        <button id="sticker-close-btn" class="lt-close-btn" style="position: static; margin-left: 5px;">&times;</button>
			                    </div>
			                </div>
			        
			        <!-- 表情包网格展示区 -->
			        <div id="sticker-grid-container-wrapper" class="lt-playlist-section" style="flex-grow: 1;"> 
			            <div id="sticker-grid-container" class="lt-playlist-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; padding: 10px 0;">
			                <!-- JS会在这里填充表情包 -->
			            </div>
			        </div>
			    </div>
			</div>
			<!-- 在 sticker-library-overlay 的 div 结束后添加 -->
			
			<!-- 【全新】温馨小屋弹窗 -->
			<div id="pet-house-overlay" class="lt-overlay"> <!-- 复用样式 -->
			    <div id="pet-house-modal" class="lt-modal" style="max-height: 90%;"> <!-- 复用样式 -->
			        <!-- 头部：标题和关闭按钮 -->
			        <div class="lt-header-bar" style="justify-content: space-between;">
			            <h3 id="ph-title" style="margin: 0;">温馨小屋</h3>
			            <span id="ph-coins-display" style="font-weight: 600; color: #E6A23C;">💰 0</span>
			            <button id="ph-close-btn" class="lt-close-btn">&times;</button>
			        </div>
			
			        <!-- 如果还未领养，显示领养界面 -->
			        <div id="ph-adoption-view" style="display: none; text-align: center; padding: 40px 0;">
			            <p>还没有安家的小伙伴呢。</p>
			            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
			                <button id="ph-adopt-pet-btn" class="btn btn-primary">领养宠物</button>
			                <button id="ph-adopt-plant-btn" class="btn btn-secondary">种植植物</button>
			            </div>
			        </div>
			
			        <!-- 领养后，显示主界面 -->
			        <div id="ph-main-view" style="display: none; flex-grow: 1; display: flex; flex-direction: column;">
			            <!-- Tab 切换 -->
			            <div id="ph-tabs" style="display: flex; border-bottom: 1px solid #eee; margin-bottom: 15px;">
			                <button class="ph-tab-btn active" data-target="ph-pet-view">宠物</button>
			                <button class="ph-tab-btn" data-target="ph-plant-view">植物</button>
			            </div>
			
			            <!-- 宠物/植物内容区 -->
			            <div id="ph-content-views" style="flex-grow: 1; overflow-y: auto;">
			                <!-- 宠物视图 -->
			                <div id="ph-pet-view" class="ph-content active">
			                    <!-- 宠物信息和状态 -->
			                </div>
			                <!-- 植物视图 -->
			                <div id="ph-plant-view" class="ph-content" style="display: none;">
			                    <!-- 植物信息和状态 -->
			                </div>
			            </div>
			
			            <!-- 通用功能区：日志、仓库、商店 -->
			            <div id="ph-common-sections" style="margin-top: 15px;">
			                <!-- 照护日志 -->
			                <div class="ph-section">
			                    <h4>照护日志</h4>
			                    <div id="ph-care-log-container" class="ph-log-box"></div>
			                </div>
			                <!-- 我的仓库 -->
			                <div class="ph-section">
			                    <h4>我的仓库</h4>
			                    <div id="ph-inventory-container" class="ph-inventory-box"></div>
			                </div>
			            </div>
			            
			            <button id="ph-open-shop-btn" class="btn btn-primary" style="margin-top: 15px;">前往商店</button>
			        </div>
			    </div>
			</div>
			<!-- 【全新】线下剧场页面 -->
			<div id="offline-scene-page" class="page">
			    <div class="app-header">
					 <div class="header-left">
			       <button id="offline-scene-back-btn" class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div><div class="title">线下剧场</div>
				   	<div class="header-right">
					<button id="scene-settings-btn" class="action-btn">
			            <svg class="svg-icon"><use href="#icon-settings"></use></svg>
			        </button>
					<button id="finish-scene-btn" class="action-btn" style="color: var(--accent-color); font-weight: 600;">结束场景</button></div>
			    </div>
			
			    <!-- 故事日志 -->
			    <div class="page-content" id="scene-log-container">
			        <!-- 故事内容将由 JS 动态生成 -->
			    </div>
			    <div id="scene-choices-container"></div>
			    <!-- 输入区域 -->
			    <!-- 替换掉原来的 #scene-input-area -->
			    <div class="message-input-area" id="scene-input-area">
			        <div id="scene-input-mode-selector">
			            <button class="scene-input-mode-btn active" data-mode="dialogue">说 “...”</button>
			            <button class="scene-input-mode-btn" data-mode="action">做 [...]</button>
			            <button class="scene-input-mode-btn" data-mode="internal">想 (...) </button>
						<button class="scene-input-mode-btn" data-mode="narrative">旁白️</button>
			        </div>
			        <div class="input-wrapper">
			           <textarea id="scene-input" class="flexible-input" placeholder="输入你的下一句话或下一个动作..." rows="1"></textarea>
			            <!-- 【核心修改】新增两个按钮 -->
			            <button id="send-user-entry-btn" class="input-action-btn secondary" title="仅记录我的话/动作">
			                <svg class="svg-icon"><use href="#icon-user"></use></svg>
			            </button>
			            <button id="generate-ai-narrative-btn" class="input-action-btn" title="让AI续写故事">
			                <svg class="svg-icon"><use href="#icon-send"></use></svg>
			                <div class="spinner"></div>
			            </button>
			        </div>
			    </div>
			</div>
			<!-- 【全新】纪念日列表页面 -->
			<div id="anniversary-list-page" class="page">
			    <div class="app-header">
			        <div class="header-left"><button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
			        <div class="title">所有纪念日</div>
			        <div class="header-right"><button class="action-btn" id="add-anniversary-btn"><svg class="svg-icon"><use href="#icon-plus"></use></svg></button></div>
			    </div>
			    <div class="page-content" id="anniversary-list-container" style="padding: 15px;">
			        <!-- 纪念日卡片将在这里生成 -->
			    </div>
			</div>
			
			<!-- 【全新】添加/编辑纪念日页面 -->
			<div id="anniversary-edit-page" class="page">
			    <div class="app-header">
			        <div class="header-left"><button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
			        <div class="title" id="anniversary-edit-title">添加纪念日</div>
			        <div class="header-right"><button class="action-btn" id="save-anniversary-btn"><svg class="svg-icon"><use href="#icon-save"></use></svg></button></div>
			    </div>
			    <div class="page-content" style="padding: 20px;">
			        <input type="hidden" id="anniversary-edit-id">
			        <div class="form-group">
			            <label for="anniversary-title-input">标题</label>
			            <input type="text" id="anniversary-title-input" placeholder="例如：我的生日">
			        </div>
			        <div class="form-group">
			            <label for="anniversary-date-input">日期</label>
			            <input type="date" id="anniversary-date-input">
			        </div>
			        <div class="form-group">
			            <label for="anniversary-type-select">类型 (重要！)</label>
			            <select id="anniversary-type-select">
			                <option value="global">全局纪念日 (所有角色可见)</option>
			                <!-- 其他角色选项将由JS动态添加 -->
			            </select>
			            <p style="font-size: 12px; color: var(--secondary-text); margin-top: 5px;">“全局”对所有AI可见（如你的生日），选择特定角色则只对他/她可见（如恋爱纪念日）。</p>
			        </div>
			         <div class="form-group">
			            <label>卡片自定义</label>
			            <div style="display: flex; gap: 20px; align-items: center;">
			                <div>
			                    <label>字体颜色</label>
			                    <input type="color" id="anniversary-font-color-input" value="#FFFFFF">
			                </div>
			                <div class="avatar-upload-group" style="flex-grow: 1;">
			                    <img id="anniversary-bg-preview" class="avatar-preview" style="width: 80px; height: 50px; border-radius: 8px;">
			                    <label class="upload-btn">上传背景<input type="file" id="anniversary-bg-input" accept="image/*" style="display:none;"></label>
			                </div>
			            </div>
			        </div>
			        <button class="btn btn-primary destructive" id="delete-anniversary-btn" style="background-color:#E53935; display:none;">删除纪念日</button>
			    </div>
			</div>
			
			<!-- 【全新】全局设置页面 -->
			<div id="global-settings-page" class="page">
			    <div class="app-header">
			        <div class="header-left"><button class="back-btn"><svg class="svg-icon"><use href="#icon-back"></use></svg></button></div>
			        <div class="title">全局设置</div>
			    </div>
			    <div class="page-content" style="padding: 20px;">
					<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 20px; margin-bottom: 20px;">
					    <div>
					        <label for="enable-time-awareness-toggle" style="font-weight: 500; margin: 0;">AI 时间感知</label>
					        <p style="font-size: 12px; color: var(--secondary-text); margin: 5px 0 0 0;">开启后，AI会知道当前几点、星期几，并可能在对话中提及。</p>
					    </div>
					    <label class="switch">
					        <input type="checkbox" id="enable-time-awareness-toggle">
					        <span class="slider round"></span>
					    </label>
					</div>
			       <div class="form-group">
			           <label for="global-font-css-input">全局字体美化 (CSS)</label>
			           <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
			               在此输入CSS代码来定义全局字体。
			           </p>
			           <textarea id="global-font-css-input" placeholder="例如：
			       @import url('https://.../font.css');
			       body, .phone-body { font-family: 'Your Font Name', sans-serif !important; }"
			       style="min-height: 120px;"></textarea>
			       </div>
			        <div class="form-group">
			            <label>桌面壁纸</label>
			            <div class="avatar-upload-group">
			                <img id="wallpaper-preview" class="avatar-preview" style="width: 80px; height: 142px; border-radius: 8px;">
			                <div style="flex-grow:1; display:flex; flex-direction: column; gap: 8px;">
			                    <label class="upload-btn">上传壁纸<input type="file" id="wallpaper-upload-input" accept="image/*" style="display:none;"></label>
			                    <button id="clear-wallpaper-btn" class="btn" style="padding: 10px; background: #aaa; margin: 0;">清除壁纸</button>
			                </div>
			            </div>
			        </div>
					
					<hr style="margin: 24px 0;">
					<h4>聊天界面图标自定义 (输入URL)</h4>
					<p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
					    输入图片的URL来自定义图标。留空则使用默认图标。
					</p>
					<div id="custom-chat-icons-container" style="display: flex; flex-direction: column; gap: 15px;">
					    <!-- JS会在这里动态生成所有App的设置项 -->
					</div>
			    
			        <hr style="margin: 24px 0;">
			        <h4>App图标自定义 (输入URL)</h4>
			        <div id="custom-icons-container" style="display: flex; flex-direction: column; gap: 15px;">
			            <!-- JS会在这里动态生成所有App的设置项 -->
			        </div>
			        
			        <hr style="margin: 24px 0;">
			        <h4>小组件美化</h4>
			        <div class="form-group">
			            <label>纪念日小组件</label>
			            <div style="display:flex; gap: 10px; align-items: center;">
			                <input type="color" id="widget-anniversary-color-input" title="字体颜色">
			                <label class="upload-btn" style="flex-grow:1;">更换背景<input type="file" id="widget-anniversary-bg-input" accept="image/*" style="display:none;"></label>
			            </div>
			        </div>
			        
			        <button id="save-global-settings-btn" class="btn btn-primary" style="margin-top: 20px;">保存所有设置</button>
			        <hr style="margin: 32px 0;">
			        <h4>主题颜色定制</h4>
			        <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 15px;">
			            实时预览，修改会立即生效。点击“保存所有设置”以持久化。
			        </p>
			       			        <!-- ▼▼▼ 用下面这段全新的代码块，替换掉旧的颜色选择器和恢复按钮 ▼▼▼ -->
			        <div id="theme-color-selectors" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px 20px;">
			            <div class="form-group">
			                <label for="theme-color-accent">主题/高亮色</label>
			                <input type="color" id="theme-color-accent" data-variable="--accent-color">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-header-bg">头部/输入框背景</label>
			                <input type="color" id="theme-color-header-bg" data-variable="--headerBg">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-primary-text">主要文字</label>
			                <input type="color" id="theme-color-primary-text" data-variable="--primary-text">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-secondary-text">次要文字</label>
			                <input type="color" id="theme-color-secondary-text" data-variable="--secondary-text">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-phone-bg">页面背景</label>
			                <input type="color" id="theme-color-phone-bg" data-variable="--phone-bg">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-global-bg">全局背景</label>
			                <input type="color" id="theme-color-global-bg" data-variable="--globalBg">
			            </div>
			            <div class="form-group">
			                <label for="theme-color-border-color">分割线</label>
			                <input type="color" id="theme-color-border-color" data-variable="--border-color">
			            </div>
						<div class="form-group">
						        <label for="theme-color-home-text">主屏幕时间/日期</label>
						        <input type="color" id="theme-color-home-text" data-variable="--home-text-color">
						</div>
			        </div>
			        <button id="reset-theme-colors-btn" class="btn btn-secondary" style="margin-top: 0;">恢复默认颜色</button>
                    <!-- ▲▲▲ 代码替换结束 ▲▲▲ -->
				        <hr style="margin: 32px 0;">				
			        <h4>数据管理</h4>
			        <p style="font-size: 12px; color: var(--secondary-text); margin-top: -5px; margin-bottom: 10px;">
			            您可以将手机中的所有数据导出为一个文件进行备份，或从备份文件中恢复。
			        </p>
			        <button id="export-data-btn" class="btn btn-secondary" style="margin-top: 10px;">
			            <span class="btn-text">导出全部数据</span>
			        </button>
			        
			        <!-- 使用 label 伪装成按钮，来触发隐藏的文件输入框 -->
			        <label for="import-data-input" class="btn btn-primary destructive" style="margin-top: 15px; background-color: #c62828;">
			            导入备份文件
			        </label>
			        <input type="file" id="import-data-input" accept=".json" style="display:none;">
				</div>
			</div>
			
			<!-- 【全新】商店弹窗 -->
			<div id="shop-overlay" class="lt-overlay">
			    <div id="shop-modal" class="lt-modal" style="max-height: 80%;">
			        <div class="lt-header-bar" style="justify-content: space-between;">
			            <h3 style="margin: 0;">宠物商店</h3>
			            <span id="shop-coins-display" style="font-weight: 600; color: #E6A23C;">💰 0</span>
			            <button id="shop-close-btn" class="lt-close-btn">&times;</button>
			        </div>
			        <div id="shop-items-container" style="overflow-y: auto; padding: 10px 0;">
			            <!-- 商品列表将由 JS 动态生成 -->
			        </div>
			    </div>
			</div>
			<!-- 【新增】心声弹窗 -->
			<div id="heart-voice-overlay">
			    <div id="heart-voice-bubble">
			        <p id="heart-voice-text">...</p>
			    </div>
			</div>
			<div id="chat-action-sheet-overlay" class="action-sheet-overlay">
                <div id="chat-action-sheet" class="action-sheet">
                    <div class="action-grid">
                        <div class="action-item" data-action="image">
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-camera"></use></svg></div>
                            <div class="action-label">图片</div>
                        </div>
                        <div class="action-item" data-action="voice">
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-mic"></use></svg></div>
                            <div class="action-label">语音</div>
                        </div>
                        <div class="action-item" data-action="file">
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-file"></use></svg></div>
                            <div class="action-label">文件</div>
                        </div>
                        <div class="action-item" data-action="location">
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-map-pin"></use></svg></div>
                            <div class="action-label">位置</div>
                        </div>
                        <div class="action-item" data-action="transfer">
                            <!-- We can reuse the save icon for transfer -->
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-transfer-new"></use></svg></div>
                            <div class="action-label">转账</div>
                        </div>
                        <div class="action-item" data-action="gift">
                            <div class="action-icon"><svg class="svg-icon"><use href="#icon-gift"></use></svg></div>
                            <div class="action-label">礼物</div>
                        </div>
						<div class="action-item" data-action="sticker">
						    <div class="action-icon">
						        <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						            <circle cx="12" cy="12" r="10"></circle>
						            <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
						            <line x1="9" y1="9" x2="9.01" y2="9"></line>
						            <line x1="15" y1="9" x2="15.01" y2="9"></line>
						        </svg>
						    </div>
						    <div class="action-label">表情包</div>
						</div>
						<!-- 在 .action-grid 中添加 -->
						<div class="action-item" data-action="voice_call">
						    <div class="action-icon">
						        <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>
						        </svg>
						    </div>
						    <div class="action-label">语音通话</div>
						</div>
						<div class="action-item" data-action="video_call">
						    <div class="action-icon">
						        <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						            <polygon points="23 7 16 12 23 17 23 7"></polygon>
						            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
						        </svg>
						    </div>
						    <div class="action-label">视频通话</div>
						</div>
						<!-- 在 "视频通话" 的 action-item 后面添加 -->
						<div class="action-item" data-action="pet_house">
						    <div class="action-icon">
						        <svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
						            <polyline points="9 22 9 12 15 12 15 22"></polyline>
						        </svg>
						    </div>
						    <div class="action-label">温馨小屋</div>
						</div>
						<div class="action-item" data-action="offline_scene">
						    <div class="action-icon">
						        <!-- 使用羽毛笔图标，象征写作 -->
						        <svg class="svg-icon"><use href="#icon-quill"></use></svg>
						    </div>
						    <div class="action-label">线下剧场</div>
						</div>
                    </div>
                    <div class="action-sheet-cancel" id="cancel-action-sheet">取消</div>
                </div>
            </div>

			<div id="music-player-bar" style="display: none;">
			    <!-- 播放器内容将由 JS 动态生成 -->
			</div>
        </div>
	</div>
 <audio id="global-audio-player" style="display:none;"></audio>
 
<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- IndexedDB Storage ---
    const DB_NAME = 'AiPhoneDB_v3.4'; // MODIFIED: DB Name
    const DB_VERSION = 1;
    const STORE_NAME = 'appStateStore';
    const STATE_KEY = 'mainState';
    let db;
	let jumpToMsgId = null;

    function openDB() {
        return new Promise((resolve, reject) => {
            if (db) return resolve(db);
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onupgradeneeded = e => {
                const dbInstance = e.target.result;
                if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                    dbInstance.createObjectStore(STORE_NAME);
                }
            };
            request.onsuccess = e => { db = e.target.result; resolve(db); };
            request.onerror = e => { console.error('IndexedDB error:', e.target.error); reject(e.target.error); };
        });
    }

    async function saveStateDB(stateObject) {
        try {
            const dbInstance = await openDB();
            const transaction = dbInstance.transaction(STORE_NAME, 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            store.put(JSON.parse(JSON.stringify(stateObject)), STATE_KEY);
        } catch (error) { console.error('Failed to save state to IndexedDB:', error); }
    }

    async function loadStateDB() {
        try {
            const dbInstance = await openDB();
            const transaction = dbInstance.transaction(STORE_NAME, 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(STATE_KEY);
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = e => reject(e.target.error);
            });
        } catch (error) { console.error('Failed to load state from IndexedDB:', error); return undefined; }
    }

    // --- STATE MANAGEMENT ---
    const defaultState = {
        chats: [], worldBooks: [],
        apiSettings: { provider: 'newapi', url: '', key: '', model: '' },
		diaries: [],
		moments: [],
		fanfics: [],
		momentsProfile: { 
		    name: '我', // 增加默认名字
		    avatar: '', // 增加头像字段
		    coverImage: '',
		    signature: '点击设置个性签名'
		    },
		 stickerLibrary: [],
		 music: {
		        playlist: [], // 全局播放列表
		        playbackState: { // 全局播放状态
		            currentTrackIndex: -1,
		            isPlaying: false,
		            playMode: 'repeat-all', // 'sequence', 'repeat-all', 'repeat-one', 'shuffle'
		            progress: 0, // 播放进度 0-1
		            duration: 0, // 当前歌曲总时长
					listenTotalTime: 0, // 记录累计收听时长（毫秒）
				   lastListenChunkStartTime: null,

		        },
		        vinylCover: '' ,// 黑胶唱片中间的自定义封面图片 (Base64)
				wallpaper: ''
		    },
		apiSettings: {
		    currentApiId: null, // 当前激活的 API 配置的 ID
		    savedApis: []  ,
			},
		 anniversaries: [], // 【全新】纪念日
		    globalSettings: {
				enableTimeAwareness: true ,
		        fontUrl: '', // 全局字体URL
		        fontFamily: '', // 与URL匹配的字体名称
		        wallpaperUrl: '', // 桌面壁纸URL (可以是base64或http)
		        // 自定义App图标, key是app的data-target值
		        customIcons: {
		            'chat-list-page': '',
		            'moments-page': '',
		            'anniversary-list-page': '',
		            'global-settings-page': '',
		            'music-app-page': '',
		            'fanfic-forum-page': '',
		            'world-book-list-page': '',
		            'diary-character-list-page': '',
		            'api-settings-page': ''
		        },
				chatIcons: {
				            plus: '',
				            sendAsUser: '',
				            send: '',
				            loading: '',
				            back: '',
				            more: ''
				        },
		        // 小组件设置
		         widget: {
		            lastMessage: {
		                author: '',
		                text: '今天会发生什么有趣的事呢？'
		            },
				anniversaryBg: '',
				            anniversaryColor: '#FFFFFF',
		        },
                // ▼▼▼ 【这是最关键的部分，请确保它在这里！】 ▼▼▼
                themeColors: {
                    accent: '#007AFF',
                    primaryText: '#1d2129',
                    secondaryText: '#8a8d91',
                    phoneBg: '#F8F9FA',
                    globalBg: '#f0f2f5',
                    headerBg: '#FFFFFF',
                    borderColor: '#dee2e6',
					homeTextColor: '#FFFFFF'
                }
                // ▲▲▲ 关键部分结束 ▲▲▲
		    },
    };
    let state = {};
    
    function saveState() { 
        saveStateDB(state).catch(err => console.error("DB save failed:", err));
    }

    async function loadState() {
        let savedState = await loadStateDB();

        if (!savedState) {
            const oldStateJSON = localStorage.getItem('aiPhoneState_v3.2'); // Migration from old version
            if (oldStateJSON) {
                console.log("Migrating state from localStorage to IndexedDB...");
                try {
                    savedState = JSON.parse(oldStateJSON);
                    await saveStateDB(savedState); 
                    localStorage.removeItem('aiPhoneState_v3.2');
                } catch (e) { savedState = null; }
            }
        }

        state = Object.assign({}, JSON.parse(JSON.stringify(defaultState)), savedState);
		 state.globalSettings = Object.assign({}, defaultState.globalSettings, state.globalSettings);
		 state.globalSettings.widget = Object.assign({}, defaultState.globalSettings.widget, state.globalSettings.widget);
         state.globalSettings.chatIcons = Object.assign({}, defaultState.globalSettings.chatIcons, state.globalSettings.chatIcons);
		state.globalSettings.customIcons = Object.assign({}, defaultState.globalSettings.customIcons, state.globalSettings.customIcons);
		 state.globalSettings.themeColors = Object.assign({}, defaultState.globalSettings.themeColors, state.globalSettings.themeColors);
		     if (!state.globalSettings.themeColors.homeTextColor) {
		            state.globalSettings.themeColors.homeTextColor = defaultState.globalSettings.themeColors.homeTextColor;
		        }
		     if (!state.anniversaries) state.anniversaries = [];
		       if (!state.globalSettings) {
		           state.globalSettings = { enableTimeAwareness: true };
		       }
            if (!state.stickerLibrary) state.stickerLibrary = [];
		 // 新增日记数据校验
		    if (!state.diaries) state.diaries = [];
        // Data structure validation and migration
               if (!state.worldBooks) state.worldBooks = [];
       		if (!state.moments) state.moments = [];
       		if (!state.fanfics) state.fanfics = [];
       
       		if (!state.momentsProfile) {
       		    state.momentsProfile = { name: '我', avatar: '', coverImage: '', signature: '点击设置个性签名' };
               }
       
               // 1. 首先，确保 state.music 对象一定存在
       		if (!state.music) {
       		    state.music = JSON.parse(JSON.stringify(defaultState.music));
       		    // 尝试从旧数据迁移 (这部分逻辑保持不变)
       		    const firstChatWithMusic = state.chats?.find(c => c.playlist && c.playlist.length > 0);
       		    if (firstChatWithMusic) {
       		        console.log("Migrating music data to global state...");
       		        state.music.playlist = firstChatWithMusic.playlist;
       		        state.music.playbackState.currentTrackIndex = firstChatWithMusic.musicState.currentTrackIndex;
       		        state.music.playbackState.isPlaying = firstChatWithMusic.musicState.isPlaying;
       		        state.music.playbackState.playMode = firstChatWithMusic.musicState.playMode || 'repeat-all';
       		        showToast("音乐数据已成功迁移到全局播放器！");
       		    }
       		}
               
               // 2. 然后，再去安全地检查它的内部属性
               if (state.music.wallpaper === undefined) {
                   state.music.wallpaper = '';
               }
       
               // 确保 playbackState 存在 (这部分逻辑可以保留，作为双重保障)
               if (!state.music.playbackState) {
                   state.music.playbackState = JSON.parse(JSON.stringify(defaultState.music.playbackState));
               } else {
		    // 兼容旧数据，如果缺少新字段则补充
		    if (state.momentsProfile.name === undefined) state.momentsProfile.name = '我';
		    if (state.momentsProfile.avatar === undefined) state.momentsProfile.avatar = '';
		}

	   state.chats.forEach(chat => {
            if (!chat.type) chat.type = 'single'; // ADDED: Default chat type
            if (!chat.settings.user.avatar) chat.settings.user.avatar = '';
			if (chat.type === 'single' && chat.settings.ai && !chat.settings.ai.videoCallImages) {
			    chat.settings.ai.videoCallImages = [];
			}
            if (chat.type === 'single' && chat.settings.ai && !chat.settings.ai.avatar) chat.settings.ai.avatar = '';
            if (chat.type === 'group' && !chat.settings.members) chat.settings.members = [];
            if (chat.type === 'group') chat.settings.members.forEach(m => { if(!m.avatar) m.avatar = ''; });
            if (!chat.messages) chat.messages = [];
            if (chat.settings.memoryDepth === undefined) chat.settings.memoryDepth = 12;
			if (chat.type === 'single' && (chat.settings.aiHeartVoice === undefined || chat.settings.aiHeartVoice === null)) {
			        chat.settings.aiHeartVoice = '（开始一段新的对话，有点期待。）';
			    }
			if (chat.settings.customCss === undefined) {
			                chat.settings.customCss = '';
			            }
			// 在 loadState 函数的 forEach 循环内
			 const defaultSceneSettings = {
                background: '',
                colors: {
                    narrative: '#495057',
                    user_dialogue: '#0056b3',
                    user_action: '#5a6268',
                    user_internal: '#6c757d',
                    user_narrative: '#6a1b9a',
                    container_bg: 'rgba(255, 255, 255, 0.75)'
                }
            };

            if (!chat.offlineSceneSettings) {
                chat.offlineSceneSettings = defaultSceneSettings;
            } else {
                // 如果对象存在，就用默认值去补充它可能缺失的键
                chat.offlineSceneSettings = {
                    ...defaultSceneSettings,
                    ...chat.offlineSceneSettings,
                    colors: {
                        ...defaultSceneSettings.colors,
                        ...(chat.offlineSceneSettings.colors || {})
                    }
                };
            }
            chat.messages.forEach(msg => { if (!msg.msgId) msg.msgId = generateId('msg'); });
		    if (!chat.playlist) chat.playlist = [];
		    if (!chat.musicState) chat.musicState = { currentTrackIndex: -1, isPlaying: false };	
			if (!chat.musicState.playMode) chat.musicState.playMode = 'sequence';
			delete chat.playlist;
            delete chat.musicState;
        });
		saveState(); // 保存一次迁移后的干净状态
    }

const avatarUrlCache = new Map(); // 使用 Map 作为缓存，性能更好

// Base64 to Blob 的转换函数
async function dataURLtoBlob(dataurl) {
    const res = await fetch(dataurl);
    return await res.blob();
}

// 获取缓存或新创建的 Blob URL
async function getCachedAvatarUrl(base64String) {
    if (!base64String) return ''; // 如果没有头像数据，返回空
    if (avatarUrlCache.has(base64String)) {
        return avatarUrlCache.get(base64String);
    }
    try {
        const blob = await dataURLtoBlob(base64String);
        const url = URL.createObjectURL(blob);
        avatarUrlCache.set(base64String, url); // 存入缓存
        return url;
    } catch (e) {
        console.error("Failed to create blob URL from base64", e);
        return base64String; // 如果失败，回退到原始 Base64
    }
}
    // --- UTILS & CORE ---
	
	// =========== 新增代码开始 ===========
	    /**
	     * 将自定义CSS应用到页面
	     * @param {string} cssString - 用户输入的CSS代码
	     */
	    function applyChatCss(cssString) {
	        if (!cssString || !cssString.trim()) {
	            removeChatCss(); // 如果是空字符串，确保移除旧样式
	            return;
	        }
	        let styleTag = get('custom-chat-style');
	        if (!styleTag) {
	            styleTag = document.createElement('style');
	            styleTag.id = 'custom-chat-style';
	            document.head.appendChild(styleTag);
	        }
	        // 为了让样式只在聊天页生效，我们给所有规则加上父选择器
	        const scopedCss = `#chat-page .chat-messages ${cssString.replace(/\}/g, '}\n#chat-page .chat-messages ')}`;
	        styleTag.textContent = scopedCss;
	    }
	
	    /**
	     * 从页面移除自定义CSS
	     */
	    function removeChatCss() {
	        const styleTag = get('custom-chat-style');
	        if (styleTag) {
	            styleTag.remove();
	        }
	    }
	    // =========== 新增代码结束 ===========
	//去除时间，只有纯文本，方便ai理解
	function cleanLrc(lrcText) {
	    if (!lrcText) return '';
	    return lrcText
	        .split('\n')
	        .map(line => line.replace(/\[\d{2}:\d{2}\.\d{2,3}\]/g, '').trim()) // 用正则表达式移除时间戳
	        .filter(line => line) // 移除空行
	        .join('\n'); // 重新组合成一个字符串
	}
	// --- UTILS & CORE ---
	
	const PET_SPECIES = {
	    'cat_orange': { name: '橘猫', icon: '🐈' },
	    'dog_shiba': { name: '柴犬', icon: '🐕' },
	    'hamster': { name: '仓鼠', icon: '🐹' },
		'rabbit': { name: '兔子', icon: '🐰' },
		'parrot': { name: '鹦鹉', icon: '🦜' },
		'turtle': { name: '乌龟', icon: '🐢' },
		 'fox': { name: '小狐狸', icon: '🦊' },
		'red_panda': { name: '小熊猫', icon: '🐼' } // 注意：用熊猫图标代替

	};
	
	const PLANT_SPECIES = {
	    'succulent': { name: '多肉植物', icon: '🌵' },
	    'mint': { name: '薄荷', icon: '🌿' },
	    'sunflower': { name: '向日葵', icon: '🌻' },
		'rose': { name: '玫瑰', icon: '🌹' },
		'clover': { name: '四叶草', icon: '🍀' },
		'bamboo': { name: '富贵竹', icon: '🎋' },
		'dandelion': { name: '蒲公英', icon: '🌬️' }, // 用风代替
		    'mushroom': { name: '荧光蘑菇', icon: '🍄' }

	};
	
	const SHOP_ITEMS = {
	    'food_normal': { name: '普通猫粮', price: 5, icon: '🥫', desc: '恢复20点饱食度', type: 'pet', effect: { hunger: 20 } },
	    'food_premium': { name: '高级猫粮', price: 10, icon: '🐟', desc: '恢复30饱食度和10愉悦度', type: 'pet', effect: { hunger: 30, happiness: 10 } },
	    'toy_ball': { name: '逗猫棒', price: 15, icon: '🥎', desc: '和宠物玩个小游戏，增加愉悦度', type: 'pet', isGame: true },
	    'water_can': { name: '普通水壶', price: 5, icon: '💧', desc: '恢复25点水分', type: 'plant', effect: { water: 25 } },
	    'fertilizer': { name: '营养液', price: 12, icon: '🧪', desc: '恢复20水分和20健康度', type: 'plant', effect: { water: 20, health: 20 } },
		// 新增道具类型
		'medicine': { name: '宠物药品', price: 20, icon: '💊', desc: '恢复50点健康度', type: 'pet', effect: { health: 50 } },
		'growth_serum': { name: '生长激素', price: 50, icon: '✨', desc: '立即增加100点成长值', type: 'any', effect: { growthPoints: 100 } }, // 'any'表示宠物植物通用
		'miracle_biscuit': { name: '奇迹饼干', price: 100, icon: '🍪', desc: '恢复所有状态至全满', type: 'pet', effect: { hunger: 100, happiness: 100, health: 100 } },
		'sun_lamp': { name: '太阳灯', price: 15, icon: '💡', desc: '为植物增加30点光照', type: 'plant', effect: { sunlight: 30 } }

	};
	
    const get = (id) => document.getElementById(id);
    const generateId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const toastEl = get('toast');
    const defaultUserAvatar = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>`;
    const defaultAiAvatar = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8V4H8"></path><rect x="4" y="12" width="16" height="8" rx="2"></rect><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="M12 18v-2"></path></svg>`;
    const INITIAL_MESSAGES_TO_RENDER = 30;

    function showToast(message, duration = 2000) {
        toastEl.textContent = message; toastEl.classList.add('show');
        setTimeout(() => { toastEl.classList.remove('show'); }, duration);
    }
    function getRandomValue(str) {
        if (!str || typeof str !== 'string') return '';
        if (str.includes(',')) {
            const arr = str.split(',').map(item => item.trim()).filter(Boolean);
            if (arr.length === 0) return '';
            return arr[Math.floor(Math.random() * arr.length)];
        }
        return str.trim();
    }
	
// --- 【全新】API 设置与管理逻辑 ---

// 预设模板
const API_TEMPLATES = {
    'deepseek': { url: 'https://api.deepseek.com', name: 'DeepSeek' },
    'claude': { url: 'https://api.anthropic.com', name: 'Claude API' },
    'gemini': { url: 'https://generativelanguage.googleapis.com', name: 'Gemini API' },
};

// 渲染整个 API 设置页面
function renderApiSettingsPage() {
    // --- 新增：安全检查 ---
   if (!state.apiSettings) {
           // 为了绝对安全，可以初始化一下 state.apiSettings
           state.apiSettings = { currentApiId: null, savedApis: [] };
       }


    const { currentApiId, savedApis } = state.apiSettings;
    const currentApi = savedApis.find(api => api.id === currentApiId);

    // 渲染当前配置区域
    if (currentApi) {
        get('current-api-name').value = `${currentApi.name} (${currentApi.url})`;
        const modelSelect = get('current-api-model');
        modelSelect.innerHTML = (currentApi.models && currentApi.models.length > 0)
            ? currentApi.models.map(m => `<option value="${m}" ${m === currentApi.model ? 'selected' : ''}>${m}</option>`).join('')
            : '<option value="">无可用模型</option>';
        modelSelect.value = currentApi.model || '';
    } else {
        get('current-api-name').value = '未选择任何配置';
        get('current-api-model').innerHTML = '<option value="">请先添加并应用一个 API 配置</option>';
    }

    // 渲染 API 仓库列表
    const listContainer = get('api-list-container');
    if (savedApis.length > 0) {
        listContainer.innerHTML = savedApis.map(api => `
            <div class="api-list-item-new ${api.id === currentApiId ? 'active' : ''}">
                <div class="info">
                    <div class="name">${api.name}</div>
                    <div class="url">${api.url}</div>
                </div>
                <div class="actions">
                    <button class="btn-small apply-btn" data-id="${api.id}" ${api.id === currentApiId ? 'disabled' : ''}>应用</button>
					 <button class="btn-small edit-btn" data-id="${api.id}" style="background-color: #6c757d; color: white;">编辑</button>
                    <button class="btn-small delete-btn" data-id="${api.id}">删除</button>
                </div>
            </div>
        `).join('');
    } else {
        listContainer.innerHTML = `<p style="text-align:center; color:var(--secondary-text);">仓库是空的，点击下方按钮添加一个吧！</p>`;
    }
}

// 测试并保存新的 API 配置
async function testAndSaveApi() {
    const nameInput = get('api-name');
    const urlInput = get('api-url');
    const keyInput = get('api-key');
    const name = nameInput.value.trim();
    const url = urlInput.value.trim();
    const key = keyInput.value.trim();
	const editingId = get('editing-api-id').value; 

    if (!name || !url || !key) {
        showToast("名称、地址和密钥不能为空！");
        return;
    }

    const btn = get('test-and-save-api-btn');
    const spinner = btn.querySelector('.spinner');
    btn.disabled = true;
    spinner.style.display = 'inline-block';

    try {
        // 使用拉取模型接口作为测试
        const response = await fetch(`${url}/v1/models`, {
            headers: { 'Authorization': `Bearer ${key}` }
        });

        if (!response.ok) {
            throw new Error(`测试失败: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();
        const models = data.data.map(m => m.id).sort();

       if (editingId) {
            // 如果有ID，说明是编辑模式
            const apiToUpdate = state.apiSettings.savedApis.find(api => api.id === editingId);
            if (apiToUpdate) {
                apiToUpdate.name = name;
                apiToUpdate.url = url;
                apiToUpdate.key = key;
                apiToUpdate.provider = get('api-provider').value;
                apiToUpdate.models = models;
                // 如果模型列表变了，可能需要重置默认模型
                if (!models.includes(apiToUpdate.model)) {
                    apiToUpdate.model = models[0] || '';
                }
                showToast(`配置 "${name}" 已更新！`);
            }
        } else {
            // 没有ID，是新增模式 (和原来一样)
            const newApiConfig = {
                id: generateId('api'), name, provider: get('api-provider').value, url, key,
                model: models[0] || '', models
            };
            state.apiSettings.savedApis.push(newApiConfig);
            if (!state.apiSettings.currentApiId) {
                state.apiSettings.currentApiId = newApiConfig.id;
            }
            showToast(`配置 "${name}" 添加成功！`);
        }
        
        saveState();
        showToast(`配置 "${name}" 添加成功！已拉取 ${models.length} 个模型。`);
        
        // 清空表单并隐藏
        get('api-form').reset();
		get('editing-api-id').value = ''; 
	    get('add-api-form-container').querySelector('.api-card-title').textContent = '添加新配置';
        get('add-api-form-container').style.display = 'none';
        get('show-add-api-form-btn').style.display = 'block';
        renderApiSettingsPage();

    } catch (error) {
        console.error("API test failed:", error);
        showToast(`测试连接失败: ${error.message}`);
    } finally {
        btn.disabled = false;
        spinner.style.display = 'none';
    }
}

// 应用一个已保存的 API 配置
function applyApiConfig(apiId) {
    if (state.apiSettings.savedApis.find(api => api.id === apiId)) {
        state.apiSettings.currentApiId = apiId;
        saveState();
        renderApiSettingsPage();
        showToast("API 配置已切换！");
    }
}

// 删除一个 API 配置
// 【V2 完整版】使用自定义弹窗替换 confirm
function deleteApiConfig(apiId) {
    const { savedApis, currentApiId } = state.apiSettings;
    
    // 1. 前置检查 (这部分不变)
    if (savedApis.length <= 1) {
        showToast("无法删除最后一个 API 配置！");
        return;
    }

    // 2.【核心修改】不再使用 if(confirm(...))，而是调用我们自己的弹窗函数
    showConfirmationModal("确定要删除这个 API 配置吗？", () => {
        // 这里的代码，就是你原来放在 confirm 的 if (true) 分支里的所有逻辑
        
        // a. 从 state 中过滤掉要删除的 API 配置
        state.apiSettings.savedApis = savedApis.filter(api => api.id !== apiId);
        
        // b. 检查是否删除了当前正在使用的配置
        if (currentApiId === apiId) {
            // 如果是，就自动将第一个配置设为当前激活的
            state.apiSettings.currentApiId = state.apiSetti.savedApis[0].id;
            showToast("当前配置已删除，已自动切换到下一个可用配置。");
        } else {
            // 如果删除的不是当前配置，就只提示删除成功
            showToast("配置已删除。");
        }
        
        // c. 保存状态并重新渲染页面
        saveState();
        renderApiSettingsPage();
    });
}

// 编辑api
function openApiEditor(apiId) {
    const apiToEdit = state.apiSettings.savedApis.find(api => api.id === apiId);
    if (!apiToEdit) return;

    // 获取表单元素
    const formContainer = get('add-api-form-container');
    const formTitle = formContainer.querySelector('.api-card-title');
    const showFormBtn = get('show-add-api-form-btn');

    // 填充数据
    get('editing-api-id').value = apiToEdit.id; // 关键：记录正在编辑的ID
    get('api-name').value = apiToEdit.name;
    get('api-url').value = apiToEdit.url;
    get('api-key').value = apiToEdit.key;
    get('api-provider').value = apiToEdit.provider || 'newapi';

    // 切换UI
    formTitle.textContent = '编辑配置'; // 更改标题
    formContainer.style.display = 'block';
    showFormBtn.style.display = 'none';
}

// 统一的事件监听设置函数
function setupApiSettingsPageListeners() {
    const page = get('api-settings-page');

    // 监听模板选择
    page.querySelector('#api-provider').addEventListener('change', (e) => {
        const provider = e.target.value;
        const template = API_TEMPLATES[provider];
        if (template) {
            get('api-url').value = template.url;
            get('api-name').value = template.name;
        } else {
            get('api-url').value = '';
            get('api-name').value = '';
        }
    });

    // 监听 "添加新配置" 按钮
    page.querySelector('#show-add-api-form-btn').addEventListener('click', () => {
        get('add-api-form-container').style.display = 'block';
        page.querySelector('#show-add-api-form-btn').style.display = 'none';
    });
    
    // 监听 "取消添加" 按钮
   // --- 这是修改后的代码 ---
   page.querySelector('#cancel-add-api-btn').addEventListener('click', () => {
       const formContainer = get('add-api-form-container');
       const showFormBtn = page.querySelector('#show-add-api-form-btn');
       const formTitle = formContainer.querySelector('.api-card-title');
   
       // 1. 重置表单所有输入框的内容
       get('api-form').reset();
   
       // 2. 清空隐藏的编辑ID，这是最关键的一步
       get('editing-api-id').value = '';
   
       // 3. 将表单标题恢复为“添加新配置”
       formTitle.textContent = '添加新配置';
   
       // 4. 隐藏表单并显示“添加”按钮 (这部分和原来一样)
       formContainer.style.display = 'none';
       showFormBtn.style.display = 'block';
   });

    // 监听 "测试并保存" 按钮
    page.querySelector('#test-and-save-api-btn').addEventListener('click', testAndSaveApi);

    // 监听 "保存默认模型" 按钮
    page.querySelector('#save-current-model-btn').addEventListener('click', () => {
        const { currentApiId, savedApis } = state.apiSettings;
        const currentApi = savedApis.find(api => api.id === currentApiId);
        if (currentApi) {
            currentApi.model = get('current-api-model').value;
            saveState();
            showToast("默认模型已保存！");
        }
    });

    // 使用事件委托处理列表中的 "应用" 和 "删除" 按钮
    page.querySelector('#api-list-container').addEventListener('click', (e) => {
        const target = e.target;
        if (target.classList.contains('apply-btn')) {
            applyApiConfig(target.dataset.id);
        } else if (target.classList.contains('delete-btn')) {
            deleteApiConfig(target.dataset.id);
        }else if (target.classList.contains('edit-btn')) { //  ◄◄◄ 新增这个 else if 判断
        openApiEditor(target.dataset.id);
    }
    });
}


    // --- NAVIGATION ---

    let navHistory = ['home-screen'];
 
               // 【最终修正版 v2】
               function navigateTo(pageId) {
                   const currentPageId = navHistory[navHistory.length - 1];
                   
                   // [核心修复] 当我们从聊天页“前进”到其他任何页面时，移除全局样式
        
        		   if (isNavigating || pageId === navHistory[navHistory.length - 1]) {
                       return;
                   }
                   isNavigating = true;
               
                   const targetPageEl = get(pageId);
               
                   if (get(currentPageId)) {
                       get(currentPageId).classList.remove('active');
                       get(currentPageId).classList.add('previous'); 
                   }
               
                   if (targetPageEl) {
                       targetPageEl.classList.add('active');
                   }
                   
                   navHistory.push(pageId);
               
                   setTimeout(() => {
                       updateLayoutForMusicPlayer();
               
                       if (pageId === 'diary-character-list-page') {
                           renderDiaryCharacterList();
                       }
                       if (pageId === 'moments-page') {
                           setupMomentsPage();
                       }
                       if (pageId === 'post-moment-page') {
                           setupPostMomentPage();
                       }
                       if (pageId === 'music-app-page') {
                           openMusicApp();
                       }
					   if (pageId === 'fanfic-forum-page') {
					       renderFanficFeed();
						    renderSelectedCharPills();
					   }
					   if (pageId === 'anniversary-list-page') {
					          renderAnniversaryList();
					      }
					   if (pageId === 'global-settings-page') {
					           renderGlobalSettingsPage(); 
					       }

                   }, 0);
                   
                  setTimeout(() => {
                          isNavigating = false;
                          if (get(currentPageId)) {
                              get(currentPageId).classList.remove('previous');
                          }
                  
                          // 【新位置】把代码粘贴到这里！
                          // 在300ms动画播放完毕，页面已经完全看不见之后，再移除CSS。
                          if (currentPageId === 'chat-page') {
                              removeChatCss();
                          }
                      }, 300);
                  }
        
               // 【优化后的版本】
               function navigateBack() {
                   if (isNavigating || navHistory.length <= 1) {
                       return;
                   }
               
                   const currentPageId = navHistory[navHistory.length - 1];
                   const targetPageId = navHistory[navHistory.length - 2];
                   const targetPageEl = get(targetPageId); // 提前获取目标页面元素
               
                   // 1. [应用样式] 如果目标是聊天页，先应用它的自定义CSS
                   if (targetPageId === 'chat-page') {
                       const chat = state.chats.find(c => c.id === currentChatId);
                       if (chat) {
                           applyChatCss(chat.settings.customCss);
                       }
                   }
               
                   isNavigating = true;
               
                   navHistory.pop();
                   const currentPageEl = get(currentPageId);
               
                   if (currentPageEl) {
                       currentPageEl.classList.remove('active');
                   }
                   
                   if (targetPageEl) {
                       // 准备目标页面，让它从 'previous' 状态就位
                       targetPageEl.classList.remove('previous'); 
                       
                       // 2. 【核心优化】把“开始动画”这个指令推迟到下一个事件循环
                       //    这给了浏览器充足的时间来消化刚刚用 applyChatCss 应用的新样式
                       setTimeout(() => {
                           targetPageEl.classList.add('active');
                       }, 0); 
                   }
                   
                   // 你原来的其他逻辑保持不变
                   setTimeout(() => {
                       updateLayoutForMusicPlayer();
                   }, 0);
               
                   setTimeout(() => {
                       isNavigating = false;
                   
                       // 动画结束后，再清理离开页面的CSS
                       if (currentPageId === 'chat-page') {
                           removeChatCss();
                       }
                   }, 300);
               }



    document.querySelectorAll('.app-list-item').forEach(el => el.addEventListener('click', () => navigateTo(el.dataset.target)));
    document.querySelectorAll('.page:not(#offline-scene-page) .back-btn').forEach(btn => {
        btn.addEventListener('click', navigateBack);
    });
    // --- MODAL & CONTEXT MENU ---
    const modalOverlay = get('modal-overlay');
    const modalContent = get('modal-content');
    const contextMenu = get('context-menu');
    
    function showModal(html) { modalContent.innerHTML = html; modalOverlay.style.display = 'flex'; }
	/**
	 * 显示一个通用的确认弹窗
	 * @param {string} message - 要显示的提示信息
	 * @param {function} onConfirm - 用户点击“确定”时要执行的回调函数
	 */
	function showConfirmationModal(message, onConfirm) {
	    const modalHTML = `
	        <div style="text-align: center; padding: 10px;">
	            <p style="font-size: 16px; margin-bottom: 25px;">${message}</p>
	            <div style="display: flex; gap: 10px;">
	                <button id="modal-cancel-btn" class="btn btn-secondary" style="flex:1; margin:0;">取消</button>
	                <button id="modal-confirm-btn" class="btn btn-primary" style="flex:1; margin:0; background-color:#E53935;">确定</button>
	            </div>
	        </div>
	    `;
	    showModal(modalHTML);
	
	    get('modal-confirm-btn').addEventListener('click', () => {
	        hideModal();
	        if (typeof onConfirm === 'function') {
	            onConfirm();
	        }
	    });
	    get('modal-cancel-btn').addEventListener('click', hideModal);
	}

	function closeModal() {
	    const modal = get('interactive-modal');
	    modal.style.display = 'none';
	}
    modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) hideModal(); });
	window.closeModal = closeModal;

    // 在 // --- MODAL & CONTEXT MENU --- 区域内
    
    // 【V2 - Context Menu Upgrade】
    function showContextMenu(e, msgId) {
        e.preventDefault();
        const chat = state.chats.find(c => c.id === currentChatId);
        if (!chat) return;
    
        // First, find the message data using the msgId
        const msg = chat.messages.find(m => m.msgId === msgId);
        if (!msg) return;
    
        // --- 【NEW CORE LOGIC】--     
                // --- 【V3 - Unified and Corrected Logic】---
                let menuItems = '';
        
                // Check the TYPE of the message to decide which menu to show.
                if (msg.type === 'call_summary' || msg.type === 'scene_summary') {
                    // For BOTH system summary cards, provide a delete option.
                    const cardName = msg.type === 'call_summary' ? '通话记录' : '场景回顾';
                    menuItems = `<div class="context-menu-item" data-action="delete" data-id="${msgId}">删除${cardName}</div>`;
                }
                else if (msg.type?.includes('retracted')) {
                    // This is a retracted message placeholder.
                    menuItems = `<div class="context-menu-item" data-action="delete-placeholder" data-id="${msgId}">删除此记录</div>`;
                } 
                else {
                    // This is a regular message (text, image, voice, etc.).
                    // ... (the existing logic for regular messages remains unchanged) ...
                    if (msg.role === 'ai') {
                        menuItems = `<div class="context-menu-item" data-action="reply" data-id="${msgId}">引用</div>`;
                        if (msg.type === 'text') menuItems += `<div class="context-menu-item" data-action="edit" data-id="${msgId}">编辑</div>`;
                    } else { // user
                        menuItems = `<div class="context-menu-item" data-action="reply" data-id="${msgId}">引用</div>`;
                        if (msg.type === 'text') menuItems += `<div class="context-menu-item" data-action="edit" data-id="${msgId}">编辑</div>`;
                        menuItems += `<div class="context-menu-item" data-action="withdraw" data-id="${msgId}">撤回</div>`;
                    }
                    menuItems += `<div class="context-menu-item" data-action="delete" data-id="${msgId}">删除</div>`;
                    menuItems += `<div class="context-menu-item" data-action="forward" data-id="${msgId}">转发</div>`;
                }
                // --- 【END NEW LOGIC】 ---
            // ...
        
        contextMenu.innerHTML = menuItems;
        contextMenu.style.display = 'block';
        
        // Positioning logic remains the same
        const pageContainer = get('chat-page');
        const containerRect = pageContainer.getBoundingClientRect();
        const menuRect = contextMenu.getBoundingClientRect();
    
        let top = e.clientY - containerRect.top;
        let left = e.clientX - containerRect.left;
    
        if (top + menuRect.height > containerRect.height) {
            top -= menuRect.height;
        }
        if (left + menuRect.width > containerRect.width) {
            left -= menuRect.width;
        }
    
        contextMenu.style.left = `${left}px`;
        contextMenu.style.top = `${top}px`;
        setTimeout(() => { // Use a timeout to prevent the current click from immediately closing it
                    document.addEventListener('click', hideContextMenuOnClickOutside, { once: true });
                }, 0);
            }
        
            // --- 【核心修复】定义一个可以被移除的具名函数 ---
            function hideContextMenuOnClickOutside(e) {
                if (!contextMenu.contains(e.target)) {
                    hideContextMenu();
                } else {
                    // If the click was inside, re-add the listener for the next click
                    document.addEventListener('click', hideContextMenuOnClickOutside, { once: true });
                }
            }
			
	// 【新增】显示心声弹窗
	function showHeartVoice() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat || !chat.settings.aiHeartVoice) return;
	
	    const overlay = get('heart-voice-overlay');
	    const textEl = get('heart-voice-text');
	
	    textEl.innerHTML = chat.settings.aiHeartVoice; // 使用 innerHTML 以支持群聊的<br>和<strong>
	    overlay.classList.add('show');
	}
	
	// 【新增】隐藏心声弹窗
	function hideHeartVoice() {
	    const overlay = get('heart-voice-overlay');
	    overlay.classList.remove('show');
	}


// 置顶功能
function showChatListContextMenu(e, chatId) {
    const chat = state.chats.find(c => c.id === chatId);
    if (!chat) return;

    const pinActionText = chat.isPinned ? '取消置顶' : '置顶聊天';
    const menuItems = `<div class="context-menu-item" data-action="toggle-pin" data-id="${chatId}">${pinActionText}</div>`;
    
    contextMenu.innerHTML = menuItems;
    contextMenu.style.display = 'block';
    
    // 定位菜单 (这段逻辑和 showContextMenu 类似)
    const phoneBodyRect = document.querySelector('.phone-body').getBoundingClientRect();
    const menuRect = contextMenu.getBoundingClientRect();
    let top = e.clientY - phoneBodyRect.top;
    let left = e.clientX - phoneBodyRect.left;

    if (top + menuRect.height > phoneBodyRect.height) {
        top -= menuRect.height;
    }
    if (left + menuRect.width > phoneBodyRect.width) {
        left -= menuRect.width;
    }

    contextMenu.style.left = `${left}px`;
    contextMenu.style.top = `${top}px`;
	setTimeout(() => { // 使用 timeout 是为了防止当前的这次点击立即触发关闭行为
	        document.addEventListener('click', hideContextMenuOnClickOutside, { once: true });
	    }, 0);
}

    function hideContextMenu() { contextMenu.style.display = 'none';  document.removeEventListener('click', hideContextMenuOnClickOutside);}
	
   contextMenu.addEventListener('click', (e) => {
       const target = e.target.closest('.context-menu-item');
       if (!target) return;
       const { action, id } = target.dataset;
   
       // --- 【新增】处理置顶/取消置顶的逻辑 ---
       if (action === 'toggle-pin') {
           const chat = state.chats.find(c => c.id === id);
           if (chat) {
               chat.isPinned = !chat.isPinned; // 切换置顶状态
               saveState();
               renderChatList(); // 重新渲染列表以查看效果
           }
       } else {
           handleContextMenuAction(action, id);
       }
       
       hideContextMenu();
   });


    // 核心逻辑与事件委托
    let currentChatId = null;
	let currentOfflineScene = null; 
	let sceneInput = null; 
	let isNavigating = false;//定义锁变量
    let currentReplyId = null;
    let multiSelectMsgIds = [];
	const globalAudioPlayer = get('global-audio-player');
	//全局变量
    document.body.addEventListener('click', (e) => {
		const musicAppItem = e.target.closest('.app-list-item[data-target="music-app-page"]');
		if (musicAppItem) {
		    openMusicApp(); // 新函数
		    navigateTo('music-app-page');
		    return;
		}
        const chatListItem = e.target.closest('.chat-list-item');
        if (chatListItem) { openChat(chatListItem.dataset.chatId); return; }
        const wbListItem = e.target.closest('.wb-list-item');
        if (wbListItem) { openWorldBookEditor(wbListItem.dataset.wbId); return; }
	
		// 打开同人论坛主页时，渲染一次
		    const fanficAppItem = e.target.closest('.app-list-item[data-target="fanfic-forum-page"]');
		    if (fanficAppItem) {
		        renderFanficFeed();
		        // navigateTo 已经在外层处理了
		        return;
		    }
			 const summaryBubble = e.target.closest('.call-summary-bubble');
			    if (summaryBubble && summaryBubble.dataset.transcript) {
			        showCallTranscriptViewer(summaryBubble.dataset.transcript);
			        return; // 处理完后退出
			    }
		
		    // 点击刷新按钮
		    if (e.target.closest('#refresh-fanfic-btn')) {
		        fetchFanfics();
		        return;
		    }
		
		    // 点击文章卡片，进入详情页
		    const fanficCard = e.target.closest('.fanfic-card');
		    if (fanficCard) {
		        renderFanficDetail(fanficCard.dataset.ficId);
		        return;
		    }
		
		    // 在详情页点击 "喜欢" 按钮
		    const detailLikeBtn = e.target.closest('#fanfic-detail-page .like-btn');
		    if (detailLikeBtn) {
		        handleLikeFanfic(detailLikeBtn.dataset.ficId); // 调用新的处理函数
		        detailLikeBtn.classList.toggle('liked'); // 实时反馈
		        return;
		    }
		    
		    // 在详情页点击 "转载" 按钮
		    const detailRepostBtn = e.target.closest('#fanfic-detail-page .repost-btn');
		    if (detailRepostBtn) {
		        handleRepostFanfic(detailRepostBtn.dataset.ficId); // 调用新的处理函数
		        return;
		    }
		
		    // 在模态框中选择了一个聊天进行转载
		    if (e.target.closest('#modal-overlay .list-item')) {
		        const item = e.target.closest('#modal-overlay .list-item');
		        const { chatId, ficId } = item.dataset;
		        const fic = state.fanfics.find(f => f.id === ficId);
		        const chat = state.chats.find(c => c.id === chatId);
		
		        if (chat && fic) {
		            // 创建一个特殊类型的消息
		            const shareMessage = {
		                msgId: generateId('msg'),
		                role: 'user', // 是用户主动分享的
		                type: 'fanfic_share',
		                content: {
		                    ficId: fic.id,
		                    title: fic.title,
		                    snippet: fic.content.substring(0, 100)
		                },
		                timestamp: new Date().toISOString()
		            };
		            chat.messages.push(shareMessage);
		            chat.lastUpdated = new Date().toISOString();
		            saveState();
		            hideModal();
		            showToast(`已转载到与 ${chat.settings.ai.name || chat.settings.groupName} 的聊天`);
		            renderChatList();
		        }
		        return;
		    }
		
		    // 提交文章评论
		    if (e.target.closest('#submit-fanfic-comment-btn')) {
		        submitFanficComment();
		        return;
		    }
			// 点击 "我的喜欢" 按钮
			if (e.target.closest('#my-likes-btn')) {
			    renderMyLikesPage();
			    navigateTo('fanfic-likes-page');
			    return;
			}
    });

      let lrcData = []; // 当前歌曲的LRC数据
     let currentLrcLine = -1; // 当前高亮的歌词行索引
 
 // 1. LRC 解析函数
    function parseLRC(lrcText) {
     if (!lrcText) return [];
     const lines = lrcText.split('\n');
     const result = [];
     for (const line of lines) {
         const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/);
         if (match) {
             const min = parseInt(match[1], 10);
             const sec = parseInt(match[2], 10);
             const ms = parseInt(match[3], 10);
             const time = min * 60 + sec + ms / 1000;
             const text = match[4].trim() || '...';
             result.push({ time, text });
         }
     }
     return result.sort((a, b) => a.time - b.time); // 按时间排序
 }
 
    // 2.--- 新增：点击黑胶唱片区域切换全屏歌词 ---
    // --- 1. 事件绑定：点击黑胶唱片/全屏歌词区域，切换显示 ---
    get('vinyl-container').addEventListener('click', toggleFullLyricsView);
    get('full-lyrics-view').addEventListener('click', toggleFullLyricsView);

    // --- 2. 辅助函数：切换全屏歌词的显示/隐藏 ---
    function toggleFullLyricsView() {
        const view = get('full-lyrics-view');
        const song = state.music.playlist[state.music.playbackState.currentTrackIndex];
        if (!song || !song.lrc || lrcData.length === 0) {
            showToast('当前歌曲无歌词');
            return;
        }

        if (view.style.display === 'block') {
            view.style.display = 'none';
        } else {
            // 在显示之前，先渲染好所有歌词
            renderFullLyrics(); 
            view.style.display = 'block';
            // 立即高亮当前行
            highlightFullLyricsLine(currentLrcLine, false);
        }
    }

    // --- 3. 辅助函数：渲染全屏歌词列表 (只在打开时调用一次) ---
    function renderFullLyrics() {
        const container = get('full-lyrics-view').querySelector('.lyrics-list');
        container.innerHTML = lrcData.map(line => `<p data-time="${line.time}">${line.text}</p>`).join('');
    }

    // --- 4. 辅助函数：高亮并滚动全屏歌词中的某一行 ---
    function highlightFullLyricsLine(lineIndex, useSmoothScroll = true) {
        const fullLyricsList = get('full-lyrics-view').querySelector('.lyrics-list');
        if (!fullLyricsList) return;

        // 移除旧的高亮
        const activeLine = fullLyricsList.querySelector('p.active');
        if (activeLine) activeLine.classList.remove('active');

        // 添加新的高亮并滚动到视图
        const allLines = fullLyricsList.querySelectorAll('p');
        if (allLines[lineIndex]) {
            allLines[lineIndex].classList.add('active');
            allLines[lineIndex].scrollIntoView({
                behavior: useSmoothScroll ? 'smooth' : 'auto', // 首次打开不平滑，后续平滑
                block: 'center'
            });
        }
    }
    
    // --- 5. 辅助函数：格式化时间 ---
    function formatTime(seconds) {
        if (isNaN(seconds)) return '00:00';
        const min = Math.floor(seconds / 60);
        const sec = Math.floor(seconds % 60);
        return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
    }

    // --- 6. 核心修改：统一的 timeupdate 事件监听器 ---
    globalAudioPlayer.addEventListener('timeupdate', () => {
        if (!globalAudioPlayer.duration || isNaN(globalAudioPlayer.duration)) return;

        const currentTime = globalAudioPlayer.currentTime;
        const duration = globalAudioPlayer.duration;
        const progress = currentTime / duration;

        // 更新进度条 (这部分逻辑是正确的)
        const topProgressBar = document.querySelector('.progress-bar-top');
        if (topProgressBar) topProgressBar.style.setProperty('--progress', `${progress * 100}%`);
        
        const mainProgressFilled = get('progress-filled-main');
        if (mainProgressFilled) mainProgressFilled.style.width = `${progress * 100}%`;
        
        const mainProgressHandle = get('progress-handle-main');
        if (mainProgressHandle && !isDragging) {
            mainProgressHandle.style.left = `${progress * 100}%`;
        }

        // 更新时间显示 (这部分逻辑是正确的)
        const currentTimeEl = get('music-current-time');
        if (currentTimeEl) currentTimeEl.textContent = formatTime(currentTime);
        const durationEl = get('music-duration');
        if (durationEl) durationEl.textContent = formatTime(duration);

        // --- 修正后的歌词更新逻辑 ---
        if (lrcData.length > 0) {
            let nextLineIndex = lrcData.findIndex(line => line.time > currentTime);
            if (nextLineIndex === -1) nextLineIndex = lrcData.length;
            const currentLineIndex = nextLineIndex - 1;

            // 只有在歌词行发生变化时，才更新所有UI
            if (currentLineIndex !== currentLrcLine && currentLineIndex >= 0) {
                currentLrcLine = currentLineIndex; // 更新全局当前行索引

                const currentLineText = lrcData[currentLineIndex].text;

                // a) 更新顶部滚动歌词
                const scrollingLyricsEl = document.querySelector('#music-player-bar .scrolling-lyrics');
                if (scrollingLyricsEl) scrollingLyricsEl.textContent = currentLineText;

                // b) 更新音乐App主界面的单行歌词 (修正！)
                const mainLyricsEl = get('main-lyrics-container');
                if (mainLyricsEl) mainLyricsEl.textContent = currentLineText;
                
                // c) 更新全屏歌词的高亮和滚动 (修正！)
                if (get('full-lyrics-view').style.display === 'block') {
                    highlightFullLyricsLine(currentLineIndex);
                }
            }
        }
    });

 
    // 函数来控制播放、暂停、切换
	//播放
function playSong(trackIndex) {
    // 确保 trackIndex 在有效范围内
    if (trackIndex < 0 || trackIndex >= state.music.playlist.length) {
        stopMusic(); // 如果索引无效，就停止播放
        return;
    }

    globalAudioPlayer.pause(); 

    const song = state.music.playlist[trackIndex];
    lrcData = parseLRC(song.lrc);
    currentLrcLine = -1;
    
    state.music.playbackState.currentTrackIndex = trackIndex;
    state.music.playbackState.isPlaying = true;
    
    state.music.vinylCover = song.cover || 'https://files.catbox.moe/608ojk.jpg';
    
    // 【计时器逻辑】记录这一段播放的开始时间
    state.music.lastListenChunkStartTime = Date.now();

    globalAudioPlayer.src = song.url;
    globalAudioPlayer.load();
    const playPromise = globalAudioPlayer.play();

    if (playPromise !== undefined) {
        playPromise.catch(error => {
            console.error("音频播放失败:", error);
            state.music.playbackState.isPlaying = false;
            // 【计时器逻辑】如果播放失败，也算作暂停，将当前时间块清空
            if (state.music.lastListenChunkStartTime) {
                state.music.lastListenChunkStartTime = null;
            }
            renderMusicPlayer();
            updateListenTogetherModal();
        });
    }
    
    renderMusicPlayer(); // 渲染顶部小播放条
    updateListenTogetherModal();
	 renderSidebarPlaylist();
	 renderMusicAppPage();
	 renderMusicWidget()
    saveState();
}
   
	// 切换播放/暂停
	function togglePlayPause() {
	    const playbackState = state.music.playbackState;
	    if (playbackState.currentTrackIndex === -1 || playbackState.currentTrackIndex === null) {
	        if (state.music.playlist.length > 0) {
	            playSong(0);
	        }
	        return;
	    }
	
	    if (globalAudioPlayer.paused) {
	        globalAudioPlayer.play();
	        playbackState.isPlaying = true;
	        
	        // 【计时器逻辑】从暂停恢复，记录新的播放段开始时间
	        state.music.lastListenChunkStartTime = Date.now();
	    } else {
	        globalAudioPlayer.pause();
	        playbackState.isPlaying = false;
	        
	        // 【计时器逻辑】暂停时，计算刚刚播放的时长，累加到总时间，并清空起始时间
	        if (state.music.lastListenChunkStartTime) {
	            const elapsed = Date.now() - state.music.lastListenChunkStartTime;
	            state.music.listenTotalTime += elapsed;
	            state.music.lastListenChunkStartTime = null;
	        }
	    }
	    
	    renderMusicPlayer();
	    updateListenTogetherModal();
		renderMusicAppPage();
		renderMusicWidget()
	    saveState();
	}


    
	//播放下一首
   function playNext(isManual = false) { // isManual 用于区分是自动播放完还是用户点击
       if (state.music.playlist.length === 0) return;
   
       const { playMode, currentTrackIndex } = state.music.playbackState;
       const playlistSize = state.music.playlist.length;
       let nextIndex = -1;
   
       switch (playMode) {
           case 'repeat-one':
               // 单曲循环模式：如果不是用户手动切歌，就播放当前歌曲
               nextIndex = isManual ? (currentTrackIndex + 1) % playlistSize : currentTrackIndex;
               break;
               
           case 'shuffle':
               // 随机播放模式：随机选一首，但避免连续播放同一首
               if (playlistSize === 1) {
                   nextIndex = 0;
               } else {
                   do {
                       nextIndex = Math.floor(Math.random() * playlistSize);
                   } while (nextIndex === currentTrackIndex);
               }
               break;
   
           case 'repeat-all':
               // 列表循环模式
               nextIndex = (currentTrackIndex + 1) % playlistSize;
               break;
   
           case 'sequence':
           default:
               // 顺序播放模式（播完列表就停止）
               if (currentTrackIndex < playlistSize - 1) {
                   nextIndex = currentTrackIndex + 1;
               } else {
                   // 列表已播完
				   globalAudioPlayer.pause();
                   state.music.playbackState.isPlaying = false;
                   renderMusicPlayer();
                   renderMusicAppPage(); // 同时更新音乐App页面的状态
                   saveState();
                   return; // 退出函数，不再播放
               }
               break;
       }
   
       if (nextIndex !== -1) {
           playSong(nextIndex);
       }
	   renderMusicWidget()
   }


//播放上一首
function playPrev() {
    if (state.music.playbackState.playMode === 'shuffle') {
        playNext(true); // 在随机模式下，“上一首”也随机播放一首新的
        return;
    }
    
    // 其他模式下保持原有逻辑，但使用全局状态
    const playlistSize = state.music.playlist.length;
    if (playlistSize === 0) return;
    
    const prevIndex = (state.music.playbackState.currentTrackIndex - 1 + playlistSize) % playlistSize;
    playSong(prevIndex);
	renderMusicWidget()
}

    //停止音乐
   function stopMusic() {
       globalAudioPlayer.pause();
       globalAudioPlayer.src = '';
       state.music.playbackState.isPlaying = false;
       state.music.playbackState.currentTrackIndex = -1;
   
       // 【计时器逻辑】关闭播放器时，彻底清空计时
       state.music.listenTotalTime = 0;
       state.music.lastListenChunkStartTime = null;
   
       saveState();
       renderMusicPlayer();
       renderMusicAppPage();
       updateListenTogetherModal(); // 确保弹窗也更新为停止状态
	   renderMusicWidget()
   }


    
    // 监听歌曲播放结束事件，自动播放下一首
    globalAudioPlayer.addEventListener('ended', () => playNext());


let listenTogetherInterval = null; // 用于控制计时器的全局变量

// --- 【核心】显示并填充“一起听”弹窗 ---
function showListenTogetherModal() {
    const chat = state.chats.find(c => c.id === currentChatId);
        // 【核心修改】移除了 chat.type !== 'single' 的判断
        if (!chat) {
            showToast("错误：找不到当前聊天");
            return;
        }

    const overlay = get('listen-together-overlay');
       
       // --- 步骤 2 在这里实现：动态调整UI ---
       const ltTitle = get('lt-title');
       const ltAvatarsContainer = get('lt-avatars');
   
       if (chat.type === 'group') {
           ltTitle.textContent = `群聊听歌中`;
           // 在群聊中，我们显示用户头像和群聊的“头像”（通常是第一个成员的头像或默认图标）
           const groupAvatar = chat.settings.members[0]?.avatar || defaultAiAvatar; 
           ltAvatarsContainer.innerHTML = `
               <img id="lt-avatar-user" src="${chat.settings.user.avatar || defaultUserAvatar}" class="lt-avatar">
               <img id="lt-avatar-ai" src="${groupAvatar}" class="lt-avatar">
           `;
       } else { // 单聊
           ltTitle.textContent = `一起听歌中`;
           ltAvatarsContainer.innerHTML = `
               <img id="lt-avatar-user" src="${chat.settings.user.avatar || defaultUserAvatar}" class="lt-avatar">
               <img id="lt-avatar-ai" src="${chat.settings.ai.avatar || defaultAiAvatar}" class="lt-avatar">
           `;
       }
    
    updateListenTogetherModal();

    // 【计时器逻辑】使用新的计时方式
    if (listenTogetherInterval) clearInterval(listenTogetherInterval);
    
    listenTogetherInterval = setInterval(() => {
        const { listenTotalTime, lastListenChunkStartTime } = state.music;
        const isPlaying = state.music.playbackState.isPlaying;

        let totalMilliseconds = listenTotalTime;
        
        // 如果正在播放，需要加上当前这段正在流逝的时间
        if (isPlaying && lastListenChunkStartTime) {
            totalMilliseconds += (Date.now() - lastListenChunkStartTime);
        }

        if (totalMilliseconds === 0 && !isPlaying) {
            get('lt-timer').textContent = '暂未开始播放';
        } else {
            const totalSeconds = Math.floor(totalMilliseconds / 1000);
            const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            // 如果时间超过1小时，就显示小时
            get('lt-timer').textContent = `已在一起听歌 ${totalSeconds >= 3600 ? hours + ':' : ''}${minutes}:${seconds}`;
        }
    }, 1000);

    overlay.classList.add('show');
}


// --- 【核心】隐藏“一起听”弹窗 ---
function hideListenTogetherModal() {
    const overlay = get('listen-together-overlay');
    overlay.classList.remove('show');
    if (listenTogetherInterval) {
        clearInterval(listenTogetherInterval); // 清除计时器，防止内存泄漏
        listenTogetherInterval = null;
    }
}

// --- 【核心】更新弹窗内的动态内容 ---
function updateListenTogetherModal() {
    const playbackState = state.music.playbackState;
    const currentSong = state.music.playlist[playbackState.currentTrackIndex];

    // 更新当前播放卡片
    if (currentSong) {
        get('lt-current-cover').src = state.music.vinylCover || 'https://files.catbox.moe/608ojk.jpg';
        get('lt-current-title').textContent = currentSong.title;
        get('lt-current-artist').textContent = currentSong.artist;
    } else {
        get('lt-current-title').textContent = "暂未播放";
        get('lt-current-artist').textContent = "点击列表开始";
    }
    
    // 更新播放/暂停按钮
    const playPauseBtn = get('lt-play-pause-btn');
    playPauseBtn.innerHTML = playbackState.isPlaying 
        ? '<svg viewBox="0 0 24 24" fill="white"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>' 
        : '<svg viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"></path></svg>';

    // 更新播放列表
    const playlistContainer = get('lt-playlist-container');
    let playlistHtml = state.music.playlist.map((song, index) => `
       <div class="lt-playlist-item ${index === playbackState.currentTrackIndex ? 'playing' : ''}" data-index="${index}">
           <div class="song-info">
               <div class="song-title">${song.title}</div>
               <div class="song-artist">${song.artist}</div>
           </div>
           <button class="delete-song-btn" data-song-id="${song.id}">&times;</button>
       </div>
    `).join('');
    playlistContainer.innerHTML = playlistHtml || '<p style="text-align:center; color:#999; padding:20px 0;">列表是空的，快去添加歌曲吧</p>';
}

	
// --- 新增函数 ---

//打开音乐app
function openMusicApp() {
    // --- 新增的预加载逻辑 ---
    const playbackState = state.music.playbackState;
    const player = globalAudioPlayer;

    // 检查：如果播放器是暂停状态，并且没有加载任何歌曲URL
    if (player.paused && !player.src) {
        let trackIndexToLoad = playbackState.currentTrackIndex;
        
        // 如果上次的索引无效（比如是-1），但列表里有歌，就默认加载第一首
        if (trackIndexToLoad < 0 && state.music.playlist.length > 0) {
            trackIndexToLoad = 0;
            playbackState.currentTrackIndex = 0; // 更新状态
            saveState();
        }
        
        // 如果有一个有效的索引，就加载它
        if (trackIndexToLoad >= 0) {
            const songToLoad = state.music.playlist[trackIndexToLoad];
            if (songToLoad) {
                player.src = songToLoad.url;
                // 注意：这里只加载，不播放。等待用户点击播放按钮
            }
        }
    }
    renderMusicAppPage();
    // 如果有歌在播放，打开侧边栏显示列表 (这个逻辑保持不变)
    if (state.music.playbackState.isPlaying) {
        get('music-sidebar').classList.add('active');
    }
}

// 功能：将 state 中的壁纸应用到页面
function applyMusicAppWallpaper() {
    const musicPage = get('music-app-page');
    if (!musicPage) {
        console.error('错误：找不到 music-app-page 元素！');
        return;
    }

    // 检查 state 中是否有壁纸数据
    if (state.music.wallpaper && state.music.wallpaper.startsWith('data:image')) {
        // 将 base64 数据包装成 url() 格式
        const wallpaperUrl = `url(${state.music.wallpaper})`;
        
        // 【关键】通过 setProperty 将变量设置到元素的 style 上
        musicPage.style.setProperty('--music-wallpaper', wallpaperUrl);
        
        // (调试用) 可以在控制台看到是否成功设置
        console.log('壁纸已应用:', wallpaperUrl.substring(0, 50) + '...'); 
    } else {
        // 如果没有壁纸数据，就移除这个变量，让 CSS 用回默认的渐变
        musicPage.style.removeProperty('--music-wallpaper');
        console.log('已移除壁纸，恢复默认背景。');
    }
}

// 渲染音乐 App 主页面 (非常重要)
function renderMusicAppPage() {
    const playbackState = state.music.playbackState;
    const song = state.music.playlist[playbackState.currentTrackIndex];

    // 更新标题
    get('music-app-title').textContent = song ? `${song.title} - ${song.artist}` : "未在播放";

    // 更新黑胶唱片
    const vinylContainer = get('music-player-main-view').querySelector('.vinyl-container');
    const vinylCoverImg = get('vinyl-cover-img');
    if (playbackState.isPlaying) {
        vinylContainer.classList.add('playing');
    } else {
        vinylContainer.classList.remove('playing');
    }

    // --- 【优化后的封面逻辑】 ---
    // 优先级: 当前歌曲封面 > 全局自定义封面 > 默认封面
    const coverSrc = song?.cover || state.music.vinylCover || 'https://files.catbox.moe/608ojk.jpg';
    vinylCoverImg.style.backgroundImage = `url(${coverSrc})`;
    // --- 【优化结束】 ---

    // 更新主控制按钮
    const playPauseBtn = get('main-play-pause-btn');
    playPauseBtn.innerHTML = playbackState.isPlaying 
        ? '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path></svg>' // 暂停图标
        : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"></path></svg>'; // 播放图标

    // 更新播放模式按钮
    get('main-play-mode-btn').innerHTML = getPlayModeIcon(playbackState.playMode);
    get('main-play-mode-btn').title = getPlayModeText(playbackState.playMode);

    // 渲染侧边栏播放列表
    renderSidebarPlaylist();
}


// 渲染侧边栏播放列表
function renderSidebarPlaylist() {
    const container = get('music-playlist-sidebar-container');
    let playlistHtml = state.music.playlist.map((song, index) => `
       <div class="music-playlist-item ${index === state.music.playbackState.currentTrackIndex ? 'playing' : ''}" data-index="${index}">
           <div class="song-info">
               <div class="song-title">${song.title || '未知歌曲'}</div>
               <div class="song-artist">${song.artist || '未知艺术家'}</div>
           </div>
		   <button class="edit-song-btn" data-song-id="${song.id}">编辑</button>
           <button class="delete-song-btn" data-song-id="${song.id}">删除</button>
       </div>
    `).join('');
    container.innerHTML = playlistHtml || '<p style="padding:20px; text-align:center; color:#999;">列表是空的</p>';
}


// 渲染播放器
// 【修改版 V2.0 - 最终解决方案】
function renderMusicPlayer() {
    const playerBar = get('music-player-bar');
    const playbackState = state.music.playbackState;

    // --- 【核心守卫检查】 ---
    // 1. 如果根本没有歌被选中，直接调用布局函数去处理隐藏，然后退出。
    if (playbackState.currentTrackIndex === -1) {
        updateLayoutForMusicPlayer(); 
        return; // 关键：提前退出，不执行任何渲染
    }

    // 2. 确保歌曲数据存在，如果因为某种原因歌曲被删了，也按没有音乐处理。
    const song = state.music.playlist[playbackState.currentTrackIndex];
    if (!song) {
        updateLayoutForMusicPlayer();
        return; // 关键：提前退出
    }
    // --- 守卫检查结束 ---

    // 只有通过了上面的检查，才会执行下面的渲染逻辑

    // --- 第一次渲染或结构不存在时，创建结构 (这部分逻辑不变) ---
    if (!playerBar.querySelector('.music-info')) {
        const modeIcon = getPlayModeIcon(playbackState.playMode);
        const modeText = getPlayModeText(playbackState.playMode);
        playerBar.innerHTML = `
            <div class="progress-bar-top"><div class="progress-handle-top"></div></div>
            <div class="music-info"> 
                <div class="title"></div>
                <div class="lyrics-container"><div class="scrolling-lyrics"></div></div>
            </div>
            <div class="music-controls">
                <button id="top-play-mode-btn" title="${modeText}">${modeIcon}</button>
                <button id="top-prev-song-btn" title="上一首"><svg class="svg-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path></svg></button>
                <button id="toggle-play-btn" title="播放/暂停"><svg class="svg-icon" viewBox="0 0 24 24"><path fill="currentColor" d=""></path></svg></button>
                <button id="next-song-btn" title="下一首"><svg class="svg-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"></path></svg></button>
                <button id="top-close-music-btn" title="关闭"><svg class="svg-icon" viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg></button>
            </div>
        `;

        // --- 事件绑定也只做一次 (这部分逻辑不变) ---
        playerBar.querySelector('.music-info').onclick = () => navigateTo('music-app-page');
        get('toggle-play-btn').onclick = togglePlayPause;
        get('next-song-btn').onclick = () => playNext(true);
        get('top-prev-song-btn').onclick = playPrev;
        get('top-close-music-btn').onclick = stopMusic;
        get('top-play-mode-btn').onclick = () => {
            const modes = ['sequence', 'repeat-all', 'repeat-one', 'shuffle'];
            const currentMode = state.music.playbackState.playMode;
            const nextIndex = (modes.indexOf(currentMode) + 1) % modes.length;
            state.music.playbackState.playMode = modes[nextIndex];
            saveState();
            renderMusicPlayer(); // 重新渲染自己以更新图标
            renderMusicAppPage(); // 也要更新主App页面的图标
            showToast(`播放模式: ${getPlayModeText(modes[nextIndex])}`);
        };
        playerBar.querySelector('.progress-bar-top').onclick = (e) => {
			if (!isFinite(globalAudioPlayer.duration)) {
			        return; 
			}
            const rect = e.currentTarget.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const progress = clickX / rect.width;
            globalAudioPlayer.currentTime = globalAudioPlayer.duration * progress;
        };
    }

    // --- 后续更新只修改变化的部分 (这部分逻辑不变) ---
    const playIconPath = playbackState.isPlaying 
        ? 'M6 19h4V5H6v14zm8-14v14h4V5h-4z' // 暂停
        : 'M8 5v14l11-7z'; // 播放
    
    const modeIcon = getPlayModeIcon(playbackState.playMode);
    const modeText = getPlayModeText(playbackState.playMode);

    playerBar.querySelector('.title').textContent = `${song.title} - ${song.artist}`;
    playerBar.querySelector('.scrolling-lyrics').textContent = song.lrc ? '(点击唱片查看全屏歌词)' : '纯音乐，无歌词';
    playerBar.querySelector('#toggle-play-btn path').setAttribute('d', playIconPath);
    const modeBtn = get('top-play-mode-btn');
    modeBtn.innerHTML = modeIcon;
    modeBtn.title = modeText;
    
    // --- 【最终步骤】渲染完内容后，都让布局函数来做最终决定显隐和位置 ---
    updateLayoutForMusicPlayer();
}

// --- 这是处理所有情况的【最终版本】 ---
function updateLayoutForMusicPlayer() {
    const playerBar = document.getElementById('music-player-bar');
    if (!playerBar) return;

    const activePage = document.querySelector('.page.active');
    if (!activePage) return;

    // 条件1: 音乐模块是否有正在播放或暂停的歌曲？
    const isMusicActive = state.music.playbackState.currentTrackIndex !== -1;

    // 条件2: 当前页面是否应该隐藏播放器？
    const isPlayerHiddenOnCurrentPage = (
        activePage.id === 'music-app-page' || // 音乐App主页
        activePage.id === 'home-screen' ||   // 主屏幕
        activePage.id === 'call-page'        // 通话页面
    );

    // 最终决定：只有当音乐是激活状态，且当前页面不要求隐藏时，才显示播放器
    const shouldPlayerBeVisible = isMusicActive && !isPlayerHiddenOnCurrentPage;

    // --- 在所有操作前，先进行一次“样式重置” ---
    playerBar.classList.remove('on-moments-page');
    playerBar.style.top = '';
    document.querySelectorAll('.app-header + .page-content').forEach(pc => pc.style.marginTop = ''); // 精准选择header后的内容区
    document.querySelectorAll('.moments-floating-btn').forEach(btn => btn.style.top = '');

    // --- 根据最终决定应用新样式 ---
    if (shouldPlayerBeVisible) {
        playerBar.style.display = 'flex'; // 先让它显示出来
        const playerHeight = playerBar.offsetHeight || 50;
        
        // 【分支一：朋友圈页面的特殊逻辑】
        if (activePage.id === 'moments-page') {
            playerBar.classList.add('on-moments-page');
            playerBar.style.top = '10px';
            const playerTop = parseInt(playerBar.style.top) || 0;
            const newButtonTop = playerTop + playerHeight + 15;
            document.querySelectorAll('.moments-floating-btn').forEach(btn => {
                btn.style.top = `${newButtonTop}px`;
            });
        }
        // 【分支二：所有其他普通页面的逻辑】
        else {
            const header = activePage.querySelector('.app-header');
            const headerHeight = header ? header.offsetHeight : 0;
            playerBar.style.top = `${headerHeight}px`;
            
            const pageContent = activePage.querySelector('.app-header + .page-content');
            if (pageContent) {
                pageContent.style.marginTop = `${playerHeight}px`;
            }
        }
    } else {
        // 如果播放器不应该显示，就直接隐藏
        playerBar.style.display = 'none';
    }
}

// 最后，在 `openChat` 函数里，当打开一个聊天时，也调用一次 renderMusicPlayer
// 这样每次切换聊天，都能正确显示或隐藏当前聊天的播放器。
// --- 用这个新版本替换你原来的 openChat 函数 ---
function openChat(id) {
    currentChatId = id;
    const chat = state.chats.find(c => c.id === id);
    if (!chat) return;

    // --- 第1步：准备所有视觉元素（在页面可见之前） ---
    applyChatCss(chat.settings.customCss);

    const chatName = chat.type === 'group' ? chat.settings.groupName : chat.settings.ai.name;
    get('chat-title').textContent = chatName;
    
    const chatPageContent = get('chat-page').querySelector('.page-content');
    if (chat.settings.background) {
        chatPageContent.style.backgroundImage = `url(${chat.settings.background})`;
    } else {
        chatPageContent.style.backgroundImage = 'none';
    }

    renderChatMessages();
    renderMusicPlayer(); 

    // --- 第2步：开门迎客 ---
    navigateTo('chat-page');

    // --- 【新增保险措施】强制校准布局 ---
    // 使用 requestAnimationFrame 确保在浏览器下一次绘制前执行，效果更好
    requestAnimationFrame(() => {
        const chatPage = get('chat-page');
        const header = chatPage.querySelector('.app-header');
        const inputArea = chatPage.querySelector('.message-input-area');
        
        // 计算内容区应有的高度 = 页面总高 - 头部高 - 输入区高
        const contentHeight = chatPage.offsetHeight - header.offsetHeight - inputArea.offsetHeight;
        
        // 为内容区明确设置高度，修复可能的塌陷问题
        chatPageContent.style.height = `${contentHeight}px`;

        // 如果是从搜索页跳转过来的，执行高亮逻辑
        if (jumpToMsgId) {
            const targetMessage = get('chat-messages-container').querySelector(`[data-msg-id="${jumpToMsgId}"]`);
            if (targetMessage) {
                highlightAndScrollToMessage(targetMessage);
            }
            jumpToMsgId = null; // 处理完后重置
        }
    });
}

// 根据播放模式返回对应的 SVG 图标
function getPlayModeIcon(mode) {
    // 使用更现代、易于识别的 Material Design Icons
    const commonAttrs = `viewBox="0 0 24 24" width="22" height="22"`; // 统一尺寸和视窗
    switch (mode) {
        case 'repeat-all': 
            return `<svg ${commonAttrs}><path fill="currentColor" d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"></path></svg>`;
        case 'repeat-one': 
            return `<svg ${commonAttrs}><path fill="currentColor" d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zM13 15V9h-1l-2 1v1h1.5v4H13z"></path></svg>`;
        case 'shuffle': 
            return `<svg ${commonAttrs}><path fill="currentColor" d="M10.59 9.17L5.41 4L4 5.41l5.17 5.17l1.42-1.41zM14.5 4l2.04 2.04L4 18.59L5.41 20L17.96 7.46L20 9.5V4h-5.5zm.33 9.41l-1.41 1.41l3.13 3.13L14.5 20H20v-5.5l-2.04 2.04l-3.13-3.13z"></path></svg>`;
        case 'sequence':
        default: 
            return `<svg ${commonAttrs}><path fill="currentColor" d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></svg>`;
    }
}

// 根据播放模式返回对应的中文名称
function getPlayModeText(mode) {
    const modeMap = {
        'sequence': '顺序播放',
        'repeat-all': '列表循环',
        'repeat-one': '单曲循环',
        'shuffle': '随机播放'
    };
    return modeMap[mode] || '未知模式';
}

// --- 统一处理“添加歌曲”的跳转 ---
function openAddSongPage() {
    // --- 新增：在这里调用隐藏弹窗的函数 ---
    hideListenTogetherModal(); 

    // --- 确保是“添加模式” ---
    get('add-edit-song-page-title').textContent = '添加歌曲';
    get('editing-song-id').value = ''; // 清空编辑ID

    // 清空表单，防止下次进入时还保留上次的内容
    get('new-song-title').value = '';
    get('new-song-artist').value = '';
    get('new-song-url').value = '';
    get('new-song-lrc').value = '';
    get('new-song-cover-preview').src = '';
    get('new-song-cover-base64').value = '';
    get('file-name-display').textContent = '';
    get('new-song-file-input').value = '';
    
    navigateTo('add-song-page');
}



// 绑定音乐App侧边栏的“添加歌曲”按钮
get('add-song-sidebar-btn').addEventListener('click', openAddSongPage);

// 绑定“一起听歌”弹窗内的“添加歌曲”按钮
get('lt-add-song-btn').addEventListener('click', openAddSongPage);


// --- “添加歌曲”页面的完整逻辑 ---

// 1. 处理【封面图片】上传
get('new-song-cover-file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
        const base64String = event.target.result;
        get('new-song-cover-preview').src = base64String;
        get('new-song-cover-base64').value = base64String;
    };
    reader.readAsDataURL(file);
});

// 2. 处理【音频文件】上传
get('new-song-file-input').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    if (file.size > 20 * 1024 * 1024) {
        showToast('文件过大，建议上传20MB以下的音频');
        e.target.value = '';
        return;
    }
    const reader = new FileReader();
    reader.onload = (event) => {
        get('new-song-url').value = event.target.result;
        get('file-name-display').textContent = `已选择: ${file.name}`;
        if (!get('new-song-title').value) {
            get('new-song-title').value = file.name.replace(/\.[^/.]+$/, "");
        }
    };
    reader.onerror = () => showToast('读取文件失败，请重试');
    reader.readAsDataURL(file);
});

// 3. 处理【保存】按钮
get('save-new-song-btn').addEventListener('click', () => {
    const editingSongId = get('editing-song-id').value; // 获取正在编辑的歌曲ID

    const title = get('new-song-title').value.trim();
    const artist = get('new-song-artist').value.trim();
    const url = get('new-song-url').value.trim();
    const lrc = get('new-song-lrc').value.trim();
    const cover = get('new-song-cover-base64').value;

    if (!title || !artist || !url) {
        return showToast('歌曲名、歌手和URL/文件不能为空');
    }

    // --- 核心判断逻辑 ---
    if (editingSongId) {
        // 如果有ID，说明是“编辑模式”
        const songIndex = state.music.playlist.findIndex(s => s.id === editingSongId);
        if (songIndex > -1) {
            state.music.playlist[songIndex] = {
                ...state.music.playlist[songIndex], // 保留旧ID和其他可能存在的属性
                title, artist, url, lrc, cover
            };
            showToast('歌曲信息已更新');
        }
    } else {
        // 如果没有ID，说明是“添加模式”
        state.music.playlist.push({ 
            id: generateId('song'), 
            title, artist, url, lrc, cover 
        });
        showToast(`"${title}" 已添加到播放列表`);
    }
    
    saveState();
    renderSidebarPlaylist();
    updateListenTogetherModal(); // 如果有“一起听歌”弹窗，也刷新它

    // 如果当前播放的歌曲被编辑了，需要立即刷新播放器界面
    if (state.music.playlist[state.music.playbackState.currentTrackIndex]?.id === editingSongId) {
        renderMusicAppPage();
    }

    navigateBack(); // 保存后自动返回
});


// --- 新增：打开编辑页面的函数 ---
function openEditSongPage(songId) {
    const songToEdit = state.music.playlist.find(s => s.id === songId);
    if (!songToEdit) {
        showToast('找不到要编辑的歌曲');
        return;
    }

    // --- 设置为“编辑模式” ---
    get('add-edit-song-page-title').textContent = '编辑歌曲';
    get('editing-song-id').value = songId; // 存入正在编辑的歌曲ID

    // --- 将歌曲的旧数据填充到表单 ---
    get('new-song-title').value = songToEdit.title;
    get('new-song-artist').value = songToEdit.artist;
    get('new-song-url').value = songToEdit.url;
    get('new-song-lrc').value = songToEdit.lrc || '';
    get('new-song-cover-preview').src = songToEdit.cover || '';
    get('new-song-cover-base64').value = songToEdit.cover || '';
    get('file-name-display').textContent = ''; // 清空文件名显示
    
    navigateTo('add-song-page');
}

// --- 页面关闭时停止音乐 ---
window.addEventListener('beforeunload', () => {
    if (state.music && state.music.playbackState.isPlaying) {
        globalAudioPlayer.pause();
        state.music.playbackState.isPlaying = false;
        saveState();
    }
});

    //拖动进度条
	const mainProgressBar = document.querySelector('.progress-bar-main');
	let isDragging = false;
	
	function seek(e) {
	    // 【关键修复】在执行任何操作前，先检查音频是否已准备就绪
	    if (!globalAudioPlayer.duration || !isFinite(globalAudioPlayer.duration)) {
	        return; // 如果时长无效 (是 NaN 或 0)，则直接退出，不执行下面的危险代码
	    }
	
	    // --- 下面的代码和你原来的一模一样，现在它们是安全的了 ---
	    const rect = mainProgressBar.getBoundingClientRect();
	    let clientX = e.clientX || e.touches[0].clientX;
	    const progress = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
	    globalAudioPlayer.currentTime = globalAudioPlayer.duration * progress;
	}

	
	mainProgressBar.addEventListener('mousedown', (e) => {
	    isDragging = true;
	    seek(e);
	});
	document.addEventListener('mousemove', (e) => {
	    if (isDragging) seek(e);
	});
	document.addEventListener('mouseup', () => {
	    isDragging = false;
	});
	// 移动端支持
	mainProgressBar.addEventListener('touchstart', (e) => {
	    isDragging = true;
	    seek(e);
	});
	document.addEventListener('touchmove', (e) => {
	    if (isDragging) seek(e);
	});
	document.addEventListener('touchend', () => {
	    isDragging = false;
	});

   //绑定音乐app所有按钮事件
   // 播放/暂停
   get('main-play-pause-btn').addEventListener('click', togglePlayPause);
   // 上一首/下一首
   get('main-prev-btn').addEventListener('click', playPrev);
   get('main-next-btn').addEventListener('click', () => playNext(true));
   // 切换播放模式
   get('main-play-mode-btn').addEventListener('click', () => {
       const modes = ['sequence', 'repeat-all', 'repeat-one', 'shuffle'];
       const currentMode = state.music.playbackState.playMode;
       const nextIndex = (modes.indexOf(currentMode) + 1) % modes.length;
       state.music.playbackState.playMode = modes[nextIndex];
       saveState();
       renderMusicAppPage();
       showToast(`播放模式: ${getPlayModeText(modes[nextIndex])}`);
   });
   
   // 切换侧边栏
   get('toggle-playlist-sidebar-btn').addEventListener('click', () => {
       get('music-sidebar').classList.toggle('active');
   });
   
   // 点击侧边栏外部关闭
   get('music-main-content').addEventListener('click', (e) => {
       if (get('music-sidebar').classList.contains('active') && !e.target.closest('#toggle-playlist-sidebar-btn')) {
           get('music-sidebar').classList.remove('active');
       }
   });
   
   // 侧边栏列表点击事件
    get('music-playlist-sidebar-container').addEventListener('click', e => {
        const target = e.target;
        
        if (target.classList.contains('edit-song-btn')) {
            // --- 调用我们新的编辑函数 ---
            const songId = target.dataset.songId;
            openEditSongPage(songId); 
            return;
        }
   
          // 播放 (逻辑修改，排除按钮点击)
           const item = target.closest('.music-playlist-item');
           if (item && !target.closest('.song-actions')) { // 确保不是点的按钮区域
               playSong(parseInt(item.dataset.index, 10));
			   get('music-sidebar').classList.remove('active'); 
           }
       // 删除
       if (e.target.classList.contains('delete-song-btn')) {
           const songId = e.target.dataset.songId;
           const index = state.music.playlist.findIndex(s => s.id === songId);
           if (index > -1) {
               state.music.playlist.splice(index, 1);
               // 更新播放索引
               if (state.music.playbackState.currentTrackIndex === index) {
                   stopMusic();
               } else if (state.music.playbackState.currentTrackIndex > index) {
                   state.music.playbackState.currentTrackIndex--;
               }
               saveState();
               renderSidebarPlaylist();
           }
       }
   });
      
  // ...
  // 设置自定义封面 & 更换壁纸 (共用一个文件输入框)
  const coverInput = document.createElement('input');
  coverInput.type = 'file';
  coverInput.accept = 'image/*';
  coverInput.style.display = 'none';
  document.body.appendChild(coverInput);
  
  // 回调函数和 change 事件监听器保持不变
  let currentFileUploadCallback = null;
  coverInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
          if (typeof currentFileUploadCallback === 'function') {
              currentFileUploadCallback(event.target.result);
          }
      };
      reader.readAsDataURL(file);
      e.target.value = ''; 
  });
  
  // 【修改】只保留“更换壁纸”按钮的逻辑
  get('main-change-wallpaper-btn').addEventListener('click', () => {
      currentFileUploadCallback = (base64String) => {
          state.music.wallpaper = base64String;
          saveState();
          applyMusicAppWallpaper(); // 应用新壁纸
          showToast('壁纸已更换');
      };
      coverInput.click();
  });
  
  //关闭自动关闭音乐
  // 监听页面即将关闭或刷新的事件
  window.addEventListener('beforeunload', () => {
      // 检查音乐是否正在播放
      if (state.music.playbackState.isPlaying) {
          // 1. 立即暂停音频播放器
          globalAudioPlayer.pause();
          
          // 2. 更新我们的状态，将播放状态设为 false
          state.music.playbackState.isPlaying = false;
          
          // 3. 立即尝试保存最后的状态
          // 注意: 在 beforeunload 事件中，异步操作可能不会完成，
          // 但这里的 fire-and-forget 式保存通常是有效的。
          saveState();
      }
  });


    // --- CHAT & WORLD BOOK LISTS ---
function renderChatList() {
    const container = get('chat-list-container');
    container.innerHTML = '';
    if (state.chats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--secondary-text); padding: 40px;">点击右上角 + 创建新聊天</p>'; 
        return;
    }

    // --- 【核心排序逻辑】 ---
    const sortedChats = [...state.chats].sort((a, b) => {
        // 1. 置顶的永远在最前面
        const aIsPinned = a.isPinned || false;
        const bIsPinned = b.isPinned || false;
        if (aIsPinned !== bIsPinned) {
            return aIsPinned ? -1 : 1;
        }

        // 2. 如果置顶状态相同，则按最后更新时间排序
        const aDate = a.lastUpdated ? new Date(a.lastUpdated) : 0;
        const bDate = b.lastUpdated ? new Date(b.lastUpdated) : 0;
        return bDate - aDate;
    });

    sortedChats.forEach(chat => {
        const lastMsg = chat.messages.length > 0 ? chat.messages.slice(-1)[0] : {content: '...'};
        let lastMsgText = '';
        // 【V2.0】智能生成最后一条消息的预览文本
        if (lastMsg) {
            switch(lastMsg.type) {
                case 'image': lastMsgText = '[图片]'; break;
                case 'voice': lastMsgText = '[语音]'; break;
                case 'file': lastMsgText = '[文件]'; break;
                case 'transfer': lastMsgText = '[转账]'; break;
                case 'location': lastMsgText = '[位置]'; break;
                case 'gift': lastMsgText = '[礼物]'; break;
                case 'fanfic_share': lastMsgText = '[文章分享]'; break;
                case 'forwarded_record': lastMsgText = '[聊天记录]'; break;
                case 'retracted': // Fallthrough
                case 'ai_retracted': lastMsgText = '一条消息被撤回'; break;
				case 'call_summary': // <-- 新增的处理
				    const duration = lastMsg.content.duration;
				    const min = String(Math.floor(duration / 60)).padStart(2, '0');
				    const sec = String(duration % 60).padStart(2, '0');
				    lastMsgText = `[通话时长 ${min}:${sec}]`;
				break;
				case 'scene_summary':
				        lastMsgText = `[场景回顾] 一段故事结束了`;
				        break;
                default: // Handles 'text' and any unknown types
                     if (typeof lastMsg.content === 'string') {
                        lastMsgText = lastMsg.content;
                    } else {
                        lastMsgText = '[复杂消息]'; // 对于其他未知对象类型，提供一个默认值
                    }
                    break;
            }
        }
        
        const chatName = chat.type === 'group' ? chat.settings.groupName : chat.settings.ai.name;
        const groupIcon = chat.type === 'group' ? '<span class="group-icon">群</span>' : '';
        // 【新增】置顶标识
        const pinIcon = chat.isPinned ? '<span style="color: #8a8d91; font-size: 12px; margin-left: 5px;">[置顶]</span>' : '';

        const defaultListAvatar = 'https://files.catbox.moe/608ojk.jpg';
        let customAvatar = '';
        if (chat.type === 'single') {
            customAvatar = chat.settings.ai.avatar;
        }
        const avatarUrl = customAvatar || defaultListAvatar;
        
        // 【修改】在 class 中加入 is-pinned，方便CSS添加特殊样式
        const pinnedClass = chat.isPinned ? 'is-pinned' : '';
		 const previewText = (lastMsgText || '').substring(0, 40);
        
        container.innerHTML += `
            <div class="list-item chat-list-item ${pinnedClass}" data-chat-id="${chat.id}">
                <img class="chat-list-avatar" src="${avatarUrl}" />
                <div class="info">
                    <div class="name">${chatName}${groupIcon}${pinIcon}</div>
                    <div class="subtext">${lastMsgText.substring(0, 40)}...</div>
                </div>
                <div class="chevron">
                    <svg class="svg-icon"><use href="#icon-chevron-right"></use></svg>
                </div>
            </div>`;
    });
    
    // --- 【新增】为列表项绑定右键菜单事件 ---
    document.querySelectorAll('.chat-list-item').forEach(item => {
        item.addEventListener('contextmenu', e => {
            e.preventDefault();
            const chatId = e.currentTarget.dataset.chatId;
            showChatListContextMenu(e, chatId);
        });
    });
}

    function renderWorldBookList() {
        const container = get('world-book-list-container');
        container.innerHTML = '';
        if (state.worldBooks.length === 0) {
            container.innerHTML = '<p style="text-align:center; color: var(--secondary-text); padding: 40px;">点击右上角 + 创建世界书条目</p>'; return;
        }
        state.worldBooks.forEach(wb => {
            container.innerHTML += `<div class="list-item wb-list-item" data-wb-id="${wb.id}"><div class="info"><div class="name">${wb.title}</div><div class="subtext">${wb.content.substring(0, 40)}...</div></div><div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div></div>`;
        });
    }

    // --- CHAT PAGE LOGIC ---
    const messageInput = get('message-input');
    const messagesContainer = get('chat-messages-container');
    

    let messageMap = new Map();
    function renderChatMessages(loadAll = false) {
        if (!currentChatId) return;
        const chat = state.chats.find(c => c.id === currentChatId);
		messageMap = new Map(chat.messages.map(m => [m.msgId, m]));
        
        const messagesToRender = loadAll 
            ? chat.messages 
            : chat.messages.slice(-INITIAL_MESSAGES_TO_RENDER);

        messagesContainer.innerHTML = '';

        if (!loadAll && chat.messages.length > INITIAL_MESSAGES_TO_RENDER) {
            const loadMoreBtn = document.createElement('div');
            loadMoreBtn.textContent = '加载更早的消息';
            loadMoreBtn.style.textAlign = 'center';
            loadMoreBtn.style.padding = '10px';
            loadMoreBtn.style.color = 'var(--accent-color)';
            loadMoreBtn.style.cursor = 'pointer';
            loadMoreBtn.style.fontSize = '14px';
            loadMoreBtn.onclick = () => {
                const oldScrollHeight = messagesContainer.scrollHeight;
                renderChatMessages(true);
                messagesContainer.scrollTop = messagesContainer.scrollHeight - oldScrollHeight;
            };
            messagesContainer.appendChild(loadMoreBtn);
        }
        
        messagesToRender.forEach(msg => { addMessageToDOM(msg, chat, false); });
        
        if (!loadAll) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
    }

// 根据消息数据生成完整的html并返回它
// 【V3.0 最终统一版】根据消息数据生成完整的、可交互的HTML元素
function createMessageElement(message, chat) {
	const messageMap = new Map(chat.messages.map(m => [m.msgId, m]));
    const settings = chat.settings;
    const isUser = message.role === 'user';

    // --- 【Step 1】Create a universal `senderInfo` object ---
    // No matter who the message is from, we prepare their info first.
    let senderInfo;
    let avatarSrc;

    if (isUser) {
        avatarSrc = settings.user.avatar || defaultUserAvatar;
        senderInfo = {
            name: state.momentsProfile.name || '我',
            avatar: avatarSrc
        };
    } else { // AI or group member
        if (chat.type === 'group') {
            const member = settings.members.find(m => m.id === message.memberId);
            const memberName = member ? member.name : '未知成员';
            avatarSrc = member ? (member.avatar || defaultAiAvatar) : defaultAiAvatar;
            senderInfo = { name: memberName, avatar: avatarSrc };
        } else { // Single chat AI
            avatarSrc = settings.ai.avatar || defaultAiAvatar;
            senderInfo = { name: settings.ai.name || 'AI Assistant', avatar: avatarSrc };
        }
    }

    // --- 【Step 2】Build the basic message structure (row, avatar, etc.) ---
    const row = document.createElement('div');
    row.className = `message-row ${message.role}`;
    row.dataset.msgId = message.msgId;
    row.addEventListener('contextmenu', (e) => showContextMenu(e, message.msgId));

    const avatarWrapper = document.createElement('div');
    avatarWrapper.className = 'avatar-wrapper';
    const avatarImg = document.createElement('img');
    avatarImg.src = isUser ? defaultUserAvatar : defaultAiAvatar; // Set default first
    getCachedAvatarUrl(avatarSrc).then(url => { if (url) avatarImg.src = url; }); // Async load real one
    avatarImg.className = 'chat-avatar';
    avatarImg.style.backgroundColor = isUser ? 'var(--accent-color)' : 'var(--bubble-ai)';
	if (!isUser) {
	        avatarImg.style.cursor = 'pointer'; // 鼠标变成小手，提示可点击
	        avatarImg.title = '点击查看此刻的心声'; // 增加悬浮提示
	        avatarImg.addEventListener('click', showHeartVoice);
	    }
    avatarWrapper.appendChild(avatarImg);

    const contentDiv = document.createElement('div');
    contentDiv.className = 'message-content';

    if (chat.type === 'group' && !isUser) {
        const nameDiv = document.createElement('div');
        nameDiv.className = 'member-name';
        nameDiv.textContent = senderInfo.name;
        contentDiv.appendChild(nameDiv);
    }
    
    const bubble = document.createElement('div'); // 提前创建 bubble 元素
        bubble.className = `chat-bubble`;
        bubble.dataset.msgId = message.msgId;
    
        // Reply snippet logic (MODIFIED)
        if (message.replyTo) {
            const repliedMsg = messageMap.get(message.replyTo);
            if (repliedMsg) {
                const replySnippet = document.createElement('div');
                replySnippet.className = 'reply-snippet';
                const repliedContent = (typeof repliedMsg.content === 'object') ? `[${repliedMsg.type}]` : repliedMsg.content;
                let repliedName = '你';
                if (repliedMsg.role === 'ai') {
                    repliedName = chat.type === 'group'
                        ? (settings.members.find(m => m.id === repliedMsg.memberId)?.name || '一位成员')
                        : settings.ai.name;
                }
                replySnippet.textContent = `回复 ${repliedName}: ${repliedContent.substring(0, 20)}...`;
                
                // 【核心修改 ①】将 replySnippet 添加到 bubble 内部的最前面
                bubble.appendChild(replySnippet); 
            }
        }

    // --- 【Step 3】A robust modal function that accepts sender info ---
    const createInsModal = (modalContentHTML, modalSenderInfo) => {
        const modalHTML = `
            <div class="ins-header">
                <img src="${modalSenderInfo.avatar}" alt="${modalSenderInfo.name} avatar">
                <div class="ins-user-info">${modalSenderInfo.name}</div>
                <div class="ins-close-btn" id="ins-viewer-close-btn">
                    <svg class="svg-icon"><use href="#icon-close"></use></svg>
                </div>
            </div>
            ${modalContentHTML}
        `;
        modalContent.className = 'instagram-viewer-modal';
        showModal(modalHTML);
        get('ins-viewer-close-btn').addEventListener('click', hideModal);
        setTimeout(() => modalContent.classList.add('show-animation'), 10);
    };

    // --- 【Step 4】The fully corrected and unified switch logic ---
    switch (message.type) {
        case 'image':
            bubble.classList.add('bubble-image');
            
            // 1. 定义好你指定的、永远有效的AI占位图URL
            const AI_PLACEHOLDER_IMAGE_URL = 'https://files.catbox.moe/608ojk.jpg';
            
            // 2. 核心判断逻辑：
            //    - 如果是用户 (isUser=true)，就用消息自带的URL (无论是http链接还是base64)
            //    - 如果是AI (isUser=false)，就强制使用我们定义好的占位图URL
            const imageUrlToShow = isUser ? message.content.url : AI_PLACEHOLDER_IMAGE_URL;
        
            // 3. 使用最终决定的URL来创建<img>标签
            bubble.innerHTML = `<img src="${imageUrlToShow}" alt="图片内容">`;
            
            // 4. 弹窗逻辑保持不变，它只关心文字描述，不受URL影响
            bubble.addEventListener('click', () => {
                const modalContentHTML = `
                    <div class="ins-content-body">${message.content.description}</div>
                    <div class="ins-footer">
                        <div class="ins-action-bar">
                            <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-heart"></use></svg></button>
                            <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-comment"></use></svg></button>
                            <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-send"></use></svg></button>
                            <button class="ins-action-btn bookmark"><svg class="svg-icon"><use href="#icon-bookmark"></use></svg></button>
                        </div>
                        <p class="ins-likes">1,024 次赞 <span>- ${new Date().toLocaleDateString()}</span></p>
                    </div>
                `;
                createInsModal(modalContentHTML, senderInfo);
            });
            break;
         case 'sticker':
                    const sticker = state.stickerLibrary.find(s => s.id === message.content);
                    if (sticker) {
                        bubble.className = 'chat-bubble bubble-sticker'; 
                        bubble.innerHTML = `<img src="${sticker.url}" alt="${sticker.description}">`;
                    } else {
                        bubble.textContent = '[表情包已失效]';
                    }
                    break;
       case 'voice':
           bubble.classList.add('bubble-voice');
           // VVVV RENAMED TO voiceDuration VVVV
           const voiceDuration = message.content.duration || Math.max(1, Math.min(60, Math.floor((message.content.text || '').length / 4)));
           const voiceText = message.content.text || message.content; 
       
           const baseWidth = 80;
           const extraWidth = (voiceDuration / 60) * 140; // <-- updated here
           bubble.style.width = `${baseWidth + extraWidth}px`;
       
           let wavesHtml = '';
           for (let i = 0; i < 15; i++) {
               wavesHtml += `<span class="voice-wave" style="height: ${Math.floor(Math.random() * 80) + 20}%;"></span>`;
           }
           bubble.innerHTML = `
               <div class="voice-main">
                   <svg class="svg-icon"><use href="#icon-mic"></use></svg>
                   <div class="voice-waves">${wavesHtml}</div>
                   <span class="voice-duration">${voiceDuration}"</span> <!-- <-- and updated here -->
               </div>
               <div class="voice-text">${voiceText}</div>
           `;
           bubble.addEventListener('click', () => bubble.classList.toggle('expanded'));
           break;

        case 'file':
            bubble.classList.add('bubble-file');
            // Use size from message content if available, otherwise calculate it
            const fileSize = message.content.size || ((message.content.body || '').length / 1024).toFixed(2) + ' KB';
            bubble.innerHTML = `
                <div>
                    <div class="file-card-header">
                        <svg class="svg-icon"><use href="#icon-file-doc"></use></svg>
                        <div class="file-card-info">
                            <div class="file-name">${message.content.name}</div>
                            <div class="file-size">${fileSize}</div>
                        </div>
                    </div>
                    <div class="file-card-footer"><span>文档</span></div>
                </div>`;
            bubble.addEventListener('click', () => {
                const modalHTML = `
                        <div class="doc-header">
                            <span class="title">${message.content.name}</span>
                            <span class="close-btn" id="doc-viewer-close-btn">
                                <svg class="svg-icon"><use href="#icon-close"></use></svg>
                            </span>
                        </div>
                        <div class="doc-toolbar">
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-save"></use></svg></button>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-printer"></use></svg></button>
                            <div class="doc-tool-separator"></div>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-undo"></use></svg></button>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-redo"></use></svg></button>
                            <div class="doc-tool-separator"></div>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-bold"></use></svg></button>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-italic"></use></svg></button>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-underline"></use></svg></button>
                            <button class="doc-tool-btn"><svg class="svg-icon"><use href="#icon-align-left"></use></svg></button>
                        </div>
                        <div class="doc-content-wrapper">
                            <div class="doc-paper">
                                <div class="doc-paper-body">${message.content.body}</div>
                            </div>
                        </div>
                    `;
                    
                    modalContent.className = 'document-viewer-modal';
                    showModal(modalHTML);
                
                    get('doc-viewer-close-btn').addEventListener('click', hideModal);
                
                    setTimeout(() => {
                        modalContent.classList.add('show-animation');
                    }, 10);
                });
            break;

        case 'transfer': {
            const transfer = message.content;
               let statusText, titleText;
               // --- 步骤 1: 根据发送方和接收方，决定标题该如何显示 ---
               if (isUser) {
                   // 我是发送者，标题永远是 "转账给 [接收者名字]"
                   titleText = `转账给 ${transfer.recipientName}`;
               } else { 
                   // AI是发送者
                   if (transfer.recipientId === 'user') {
                       // AI 转账给我，标题显示 "转账给你"，这正是你想要的效果！
                       titleText = '转账给你';
                   } else {
                       // 这是群聊中，AI 转账给另一个AI成员的情况
                       titleText = `转账给 ${transfer.recipientName}`;
                   }
               }
           
           // --- 步骤 2: 判断状态文本 (这部分逻辑也需要更新以适应新结构) ---
           let myRole = 'sender';
           if (message.role === 'ai' && transfer.recipientId === 'user') {
               myRole = 'recipient';
           } else if (transfer.recipientId !== 'user') {
               myRole = 'observer';
           }
           
           switch (transfer.status) {
               case 'pending':
               case 'sent':
                   if (myRole === 'recipient') statusText = '点击收款';
                   else if (myRole === 'sender') statusText = '等待对方收款';
                   else statusText = '等待收款';
                   break;
               case 'received':
                   if (myRole === 'recipient') statusText = '已收款';
                   else statusText = '对方已收款';
                   break;
               case 'returned':
                   if (myRole === 'recipient') statusText = '已退回';
                   else statusText = '对方已退回';
                   break;
               default:
                   statusText = '转账消息';
           }
        
            // 【核心修改】用户和AI共用同一套气泡模板
            bubble.classList.add('bubble-transfer');
            bubble.innerHTML = `
                <div class="interactive-card-header">
                    <svg class="svg-icon"><use href="#icon-transfer-new"></use></svg>
                    <div class="info">
                        <div class="title">${titleText}</div>
                        <div class="subtitle">¥ ${transfer.amount}</div>
                    </div>
                </div>
                <div class="interactive-card-footer"><span>微信转账</span><span class="status">${statusText}</span></div>`;
        
            bubble.addEventListener('click', () => {
                let modalContentHTML;
                let senderInfoForModal; // 统一为弹窗准备发送者信息
        
                if (isUser) {
                    senderInfoForModal = {
                        name: state.momentsProfile.name || '我',
                        avatar: settings.user.avatar || defaultUserAvatar
                    };
                    // 【核心修改】用户侧弹窗现在也显示状态了
                    const userStatusText = transfer.status === 'received' ? '对方已收款' : (transfer.status === 'returned' ? '对方已退回' : '等待对方收款');
                    modalContentHTML = `
                        <div class="ins-content-body interactive-content">
                            <div class="interactive-icon-large"><svg class="svg-icon" style="color: #fabf44;"><use href="#icon-save"></use></svg></div>
                            <h2 class="interactive-title">${userStatusText}</h2>
                            <p class="interactive-subtitle">转账金额：<strong>¥ ${transfer.amount}</strong></p>
                            ${transfer.message ? `<p class="interactive-message">“${transfer.message}”</p>` : ''}
                        </div>
                        <div class="ins-footer interactive-actions"><button class="ins-button-primary" onclick="hideModal()">关闭</button></div>`;
                } else { // AI's message logic
                    senderInfoForModal = senderInfo; // 使用外部函数已准备好的aiInfo
                    if (transfer.status === 'pending') {
                        modalContentHTML = `...`; // AI侧待处理弹窗HTML保持不变
                    } else {
                        const aiStatusText = transfer.status === 'received' ? '你已确认收款' : '你已退回该转账';
                        modalContentHTML = `...`; // AI侧已处理弹窗HTML保持不变
                    }
                     if (transfer.status === 'pending') {
                            // 待处理状态：显示按钮
                            modalContentHTML = `
                                <div class="ins-content-body interactive-content">
                                    <div class="interactive-icon-large"><svg class="svg-icon"><use href="#icon-check-circle"></use></svg></div>
                                    <h2 class="interactive-title">确认收款</h2>
                                    <p class="interactive-subtitle">金额：<strong>¥ ${transfer.amount}</strong></p>
                                    ${transfer.message ? `<p class="interactive-message">“${transfer.message}”</p>` : ''}
                                </div>
                                <div class="ins-footer interactive-actions">
                                   <button class="ins-button-primary" onclick="handleInteractiveMessage('${message.msgId}', 'transfer', 'received'); hideModal();">确认收款</button>
                                   <button class="ins-button-secondary" onclick="handleInteractiveMessage('${message.msgId}', 'transfer', 'returned'); hideModal();">退回</button>
                                </div>
                            `;
                        } else {
                            // 已处理状态：显示状态文本和关闭按钮
                            const statusText = transfer.status === 'received' ? '你已确认收款' : '你已退回该转账';
                            modalContentHTML = `
                                <div class="ins-content-body interactive-content">
                                    <div class="interactive-icon-large"><svg class="svg-icon" style="color: #4CAF50;"><use href="#icon-check-circle"></use></svg></div>
                                    <h2 class="interactive-title">${statusText}</h2>
                                    <p class="interactive-subtitle">金额：<strong>¥ ${transfer.amount}</strong></p>
                                </div>
                                <div class="ins-footer interactive-actions">
                                   <button class="ins-button-primary" onclick="hideModal()">关闭</button>
                                </div>
                            `;
                        }
                }
                createInsModal(modalContentHTML, senderInfoForModal);
            });
            break;
        }

        case 'gift': { // 使用花括号创建一个独立的作用域，避免变量冲突
            const gift = message.content;
            let statusText, titleText;
        
            // --- 步骤 1: 判断标题该如何显示 ---
            if (isUser) {
                // 我是发送者，标题永远是 "送给 XXX"
                titleText = `送给 ${gift.recipientName}`;
            } else { // AI是发送者
                if (gift.recipientId === 'user') {
                    // AI 送给我，标题是 "送你一份礼物"
                    titleText = '送你一份礼物';
                } else {
                    // AI 送给群里另一个人，标题是 "送给 XXX"
                    titleText = `送给 ${gift.recipientName}`;
                }
            }
        
            // --- 步骤 2: 判断状态文本该如何显示 ---
            let myRole = 'sender'; // 先假设我是发送者
            if (message.role === 'ai' && gift.recipientId === 'user') {
                myRole = 'recipient'; // 如果是AI发给我，那我就是接收者
            } else if (message.role === 'user' && gift.recipientId !== 'user') {
                // 我发给别人，我是发送者 (此条件其实包含在默认值里，这里写出来便于理解)
            } else if (gift.recipientId !== 'user') {
                myRole = 'observer'; // 如果礼物和 "我" 无关（比如A送给B），那我就是旁观者
            }
        
            // 根据我的角色和礼物状态，决定显示什么文字
            switch (gift.status) {
                case 'pending': // 等待接收
                case 'sent':
                    if (myRole === 'recipient') statusText = '点击查收';
                    else if (myRole === 'sender') statusText = '等待对方接受';
                    else statusText = '等待查收'; // 旁观者视角
                    break;
                case 'accepted':
                    if (myRole === 'recipient') statusText = '已查收';
                    else statusText = '已被查收';
                    break;
                case 'declined':
                    if (myRole === 'recipient') statusText = '已拒绝';
                    else statusText = '已被拒绝';
                    break;
                default:
                    statusText = '礼物消息';
            }
        
            // --- 步骤 3: 渲染气泡和弹窗 (这部分与之前类似，但逻辑更清晰) ---
            bubble.classList.add('bubble-gift');
            bubble.innerHTML = `
                <div class="interactive-card-header">
                    <svg class="svg-icon"><use href="#icon-gift"></use></svg>
                    <div class="info">
                        <div class="title">${titleText}</div>
                        <div class="subtitle">${gift.name}</div>
                    </div>
                </div>
                <div class="interactive-card-footer"><span>微信礼物</span><span class="status">${statusText}</span></div>`;
        
            bubble.addEventListener('click', () => {
                // 点击弹窗的逻辑保持不变，因为它主要是处理接收/拒绝操作
                let modalContentHTML;
                let senderInfoForModal = senderInfo; // 使用函数开头准备好的发送者信息
        
                // 只有当我是接收者，且礼物是待处理状态时，才显示操作按钮
                if (myRole === 'recipient' && gift.status === 'pending') {
                    modalContentHTML = `
                        <div class="ins-content-body interactive-content">
                            <div class="interactive-icon-large"><svg class="svg-icon" style="color:#f87c7c;"><use href="#icon-gift"></use></svg></div>
                            <h2 class="interactive-title">${gift.name}</h2>
                            <p class="interactive-subtitle">${gift.description}</p>
                            ${gift.message ? `<p class="interactive-message">“${gift.message}”</p>` : ''}
                        </div>
                        <div class="ins-footer interactive-actions">
                           <button class="ins-button-primary" onclick="handleInteractiveMessage('${message.msgId}', 'gift', 'accepted'); hideModal();">接受</button>
                           <button class="ins-button-secondary" onclick="handleInteractiveMessage('${message.msgId}', 'gift', 'declined'); hideModal();">拒绝</button>
                        </div>`;
                } else {
                    // 其他所有情况（我是发送者、我是旁观者、礼物已处理），都只显示信息和关闭按钮
                    let finalStatusText = '';
                    if (gift.status === 'accepted') finalStatusText = `${gift.recipientName} 已收下礼物`;
                    else if (gift.status === 'declined') finalStatusText = `${gift.recipientName} 拒绝了礼物`;
                    else finalStatusText = `等待 ${gift.recipientName} 接受`;
        
                    modalContentHTML = `
                        <div class="ins-content-body interactive-content">
                             <div class="interactive-icon-large"><svg class="svg-icon" style="color:#f87c7c;"><use href="#icon-gift"></use></svg></div>
                            <h2 class="interactive-title">${finalStatusText}</h2>
                            <p class="interactive-subtitle">${gift.name}</p>
                        </div>
                        <div class="ins-footer interactive-actions">
                           <button class="ins-button-primary" onclick="hideModal()">关闭</button>
                        </div>`;
                }
                createInsModal(modalContentHTML, senderInfoForModal);
            });
            break;
        }
        case 'location':
            bubble.classList.add('bubble-location');
            bubble.innerHTML = `
                <div class="interactive-card-header">
                    <svg class="svg-icon"><use href="#icon-map-pin"></use></svg>
                    <div class="info"><div class="title">${message.content.address}</div></div>
                </div>
                <div class="interactive-card-body"></div>
                <div class="interactive-card-footer"><span>位置信息</span></div>`;
            bubble.addEventListener('click', () => {
                // 【新代码】增加了模拟地图和操作按钮，对用户和AI都生效
                const senderInfo = isUser
                    ? { name: state.momentsProfile.name || '我', avatar: settings.user.avatar || defaultUserAvatar }
                    : { name: chat.settings.ai.name, avatar: chat.settings.ai.avatar || defaultAiAvatar };
            
                const modalContentHTML = `
                    <div class="ins-content-body interactive-content" style="padding:0;">
                       <div style="width:100%; height: 250px; background: #e9e9e9 url('https://files.catbox.moe/608ojk.jpg') center/cover;"></div>
                       <div style="padding: 20px; text-align:left; width:100%;">
                         <h2 class="interactive-title" style="text-align:left;">${message.content.address}</h2>
                         <p class="interactive-subtitle" style="text-align:left;">这是一个模拟的地图位置视图</p>
                       </div>
                    </div>
                    <div class="ins-footer interactive-actions">
                       <button class="ins-button-primary">导航</button>
                       <button class="ins-button-secondary">分享</button>
                    </div>`;
                createInsModal(modalContentHTML, senderInfo);
            });
            break;

        case 'fanfic_share':
            // 1. 根据 message 中存储的 ficId，从 state.fanfics 数组里查找完整的文章信息
            const ficId = message.content.ficId;
            const sharedFic = state.fanfics.find(f => f.id === ficId);
        
            // 2. 判断文章是否还存在
            if (sharedFic) {
                // 如果找到了文章，就渲染成我们设计好的卡片样式
                bubble.className = 'message-bubble fanfic-share-bubble'; // 使用新的专属 class
                bubble.innerHTML = `
                    <div class="fanfic-share-title">${sharedFic.title}</div>
                    <div class="fanfic-share-snippet">${sharedFic.content.substring(0, 80)}...</div>
                    <div class="fanfic-share-footer">同人文章</div>
                `;
                
                // 3. 【功能不变】保留你原有的点击功能，点击后跳转到文章详情页
                bubble.addEventListener('click', () => {
                    // 我们直接使用上面获取到的 ficId
                    renderFanficDetail(ficId); 
                });
        
            } else {
                // 如果因为刷新等原因文章被删了或找不到了，显示一个友好的提示
                bubble.className = 'message-bubble'; // 可以恢复成普通气泡的基类
                bubble.innerHTML = `<div class="text-bubble">分享的文章已失效</div>`;
                // 在这种情况下，我们就不给它添加点击事件了
            }
            break;
            
        case 'forwarded_record':
            bubble.classList.add('bubble-forward');
            const records = message.content;
            const title = records.length > 1 ? '聊天记录' : `${records[0].sender}的聊天记录`;
            let snippetHtml = records.slice(0, 3).map(rec => `<p>${rec.sender}: ${rec.message}</p>`).join('');
            if (records.length > 3) snippetHtml += '<p>...</p>';
            bubble.innerHTML = `<div class="forward-header">${title}</div><div class="forward-snippet">${snippetHtml}</div>`;
            bubble.addEventListener('click', () => showForwardedRecordViewer(message.content));
            break;
				case 'call_summary': { 
		    const summaryDiv = document.createElement('div');
		    // 【核心】使用我们全新的、漂亮的卡片样式
		    summaryDiv.className = 'summary-card-base';
		
		    const duration = message.content.duration;
		    const min = String(Math.floor(duration / 60)).padStart(2, '0');
		    const sec = String(duration % 60).padStart(2, '0');
		    const callType = message.content.callType;
		    const callIcon = callType === 'video' ? '#icon-camera' : '#icon-mic'; // 使用更合适的图标
		    
		    summaryDiv.innerHTML = `
                <div class="summary-card-header">
                    <svg class="svg-icon"><use href="${callIcon}"></use></svg>
                    <span class="title">${callType === 'video' ? '视频通话' : '语音通话'}已结束</span>
                </div>
                <div class="summary-card-content">
                    通话时长：${min}:${sec}
                </div>
                <div class="summary-card-footer">
                    点击查看通话记录
                </div>
            `;
		
		    if (message.content.transcript) {
		        summaryDiv.dataset.transcript = encodeURIComponent(JSON.stringify(message.content.transcript));
                // 让整个卡片都可以点击
                summaryDiv.onclick = () => showCallTranscriptViewer(summaryDiv.dataset.transcript);
		    }
		
		    const row = document.createElement('div');
		    row.style.textAlign = 'center';
		    row.style.width = '100%';
			row.dataset.msgId = message.msgId;
		    row.appendChild(summaryDiv);
		    return row;
		}

		    case 'scene_summary': {
    const summary = message.content;
    const snippet = summary.storyText.substring(0, 60); // 摘要可以稍微短一点

    const summaryDiv = document.createElement('div');
    // 【核心】同样使用我们全新的、漂亮的卡片样式
    summaryDiv.className = 'summary-card-base';
    summaryDiv.innerHTML = `
        <div class="summary-card-header">
            <svg class="svg-icon"><use href="#icon-quill"></use></svg>
            <span class="title">场景回顾</span>
        </div>
        <div class="summary-card-content">
            ${snippet}...
        </div>
        <div class="summary-card-footer">
            点击查看完整故事
        </div>
    `;
    
    summaryDiv.onclick = () => {
        const fullStoryHtml = summary.fullLog.map(entry => {
            if(entry.type === 'narrative') return `<p style="color:#495057;">${entry.content}</p>`;
            return `<p><strong>你 (${entry.mode}):</strong> ${entry.content}</p>`;
        }).join('');
        showModal(`<h3>故事回顾</h3><div style="max-height: 60vh; overflow-y: auto; line-height: 1.7;">${fullStoryHtml}</div>`);
    };
    
    const row = document.createElement('div');
    row.style.textAlign = 'center';
    row.style.width = '100%';
    row.dataset.msgId = message.msgId;
    row.appendChild(summaryDiv);
    return row; 
}

        default: // text
            bubble.innerHTML += `<span>${message.content}</span>`; 
			 let lastTapTime = 0;
			        bubble.addEventListener('click', (e) => {
			            // 不阻止默认行为，因为文本消息没有默认行为
			            const currentTime = new Date().getTime();
			            if (currentTime - lastTapTime < 300 && currentTime - lastTapTime > 0) {
			                showContextMenu(e, message.msgId);
			                lastTapTime = 0; // 重置
			            } else {
			                lastTapTime = currentTime;
			            }
			        });
                        break;
    }

    contentDiv.appendChild(bubble);

    // --- 【Step 5】Final assembly ---
    const timestampDiv = document.createElement('div');
    timestampDiv.className = 'message-timestamp';
    if (message.timestamp) {
        const date = new Date(message.timestamp);
        timestampDiv.textContent = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
    }

    if (isUser) {
        row.appendChild(timestampDiv);
        row.appendChild(contentDiv);
        row.appendChild(avatarWrapper);
    } else {
        row.appendChild(avatarWrapper);
        row.appendChild(contentDiv);
        row.appendChild(timestampDiv);
    }

    return row;
}
// 调用新元素，把返回的添加到聊天记录
async function addMessageToDOM(message, chat, shouldScroll = true) {
    const container = messagesContainer;
    const spinner = container.querySelector('.spinner');
    if (spinner) spinner.remove();
	
        if (message.role === 'system') {
                // 【核心修复】让 scene_summary 和 call_summary 都能被渲染
                if (message.type === 'call_summary' || message.type === 'scene_summary') {
                    const element = createMessageElement(message, chat);
                    if (element) { // 安全检查，确保 createMessageElement 返回了东西
                        container.appendChild(element);
                    }
                }
                // 只有在这两种系统消息被处理后才返回
                return; 
            }
    // --- 【关键】处理撤回消息，这部分逻辑和之前完全一样 ---
    if (message.type === 'retracted' || message.type === 'ai_retracted') {
        const retractedDiv = document.createElement('div');
        retractedDiv.className = 'retracted-message';
        retractedDiv.dataset.msgId = message.msgId;
        retractedDiv.addEventListener('contextmenu', (e) => showContextMenu(e, message.msgId));
        
        let who = '你';
        if (message.role === 'ai') {
            if (chat.type === 'group') {
                const member = chat.settings.members.find(m => m.id === message.memberId);
                who = member ? member.name : '一位成员';
            } else {
                who = chat.settings.ai.name;
            }
        }
        
        retractedDiv.innerHTML = message.type === 'ai_retracted' 
            ? `${who}撤回了一条消息。<span data-original="${encodeURIComponent(JSON.stringify(message.originalContent))}">查看</span>`
            : `${who}撤回了一条消息。`;
        container.appendChild(retractedDiv);
		
		const wrapper = document.createElement('div');
		    wrapper.style.textAlign = 'center';
		    wrapper.style.width = '100%';
		    wrapper.appendChild(retractedDiv);
		    container.appendChild(wrapper); // 现在添加的是带居中样式的包裹容器

        if (message.type === 'ai_retracted') {
            retractedDiv.querySelector('span').addEventListener('click', e => {
                const original = JSON.parse(decodeURIComponent(e.target.dataset.original));
                showToast(`原文: ${typeof original.content === 'object' ? JSON.stringify(original.content) : original.content}`, 4000);
            });
        }
        return; // 处理完撤回消息后直接返回
    }

    // --- 对于所有常规消息，调用我们的新函数来创建元素 ---
    const messageElement = createMessageElement(message, chat);
    container.appendChild(messageElement);

    // --- 滚动逻辑 ---
    if (shouldScroll) {
        container.scrollTop = container.scrollHeight;
    }
}

    // ---送礼/转账核心交互处理函数 ---
  // ---送礼/转账核心交互处理函数 ---
  function handleInteractiveMessage(msgId, type, newStatus) {
      const chat = state.chats.find(c => c.id === currentChatId);
      if (!chat) return;
  
      const messageIndex = chat.messages.findIndex(m => m.msgId === msgId);
      if (messageIndex === -1) return;
  
      // 1. 更新 state 中的数据
      const message = chat.messages[messageIndex];
      message.content.status = newStatus;
  
      // 2. 准备要发送给AI的反馈文本
      let feedbackText = '';
      if (type === 'transfer') {
          feedbackText = newStatus === 'received' ? `我收下了你转的 ${message.content.amount} 元。` : `我退回了你转的 ${message.content.amount} 元。`;
      } else if (type === 'gift') {
          feedbackText = newStatus === 'accepted' ? `我接受了你送的礼物“${message.content.name}”。` : `我拒绝了你送的礼物“${message.content.name}”。`;
      }
  
      // ▼▼▼ 在这里确保 pendingFeedback 是一个数组 ▼▼▼
      if (!chat.pendingFeedback) {
          chat.pendingFeedback = [];
      }
      chat.pendingFeedback.push(`[用户操作记录: ${feedbackText}]`);
      
      // 3. 【核心渲染逻辑】原地替换 DOM 元素
      const oldMessageElement = document.querySelector(`.message-row[data-msg-id="${msgId}"]`);
      if (oldMessageElement) {
          const newMessageElement = createMessageElement(message, chat);
          oldMessageElement.parentElement.replaceChild(newMessageElement, oldMessageElement);
      }
  
      // 4. 保存状态
      saveState();
  }
  // 将这个函数暴露到 window 对象上，以便 HTML 中的 onclick 可以调用
  window.handleInteractiveMessage = handleInteractiveMessage;
   
// 注意：因为 addMessageToDOM 是 async 函数，所以 saveMessage 最好也标记为 async
// 【最终优化版】
async function saveMessage(role, content, type = 'text', replyTo = null, memberId = null) {
    if ((typeof content === 'string' && !content.trim()) || !content) return;
    const chat = state.chats.find(c => c.id === currentChatId);
    if (!chat) return; 

    const message = { msgId: generateId('msg'), role, content, type, replyTo, memberId, timestamp: new Date().toISOString() };
    
    // 1. 更新数据模型
    chat.messages.push(message);
    chat.lastUpdated = new Date().toISOString(); 
    // 【重要】同时更新快速查找表
    messageMap.set(message.msgId, message);

    // --- 第一部分：只做最快的、必须立即反馈给用户的操作 ---
    
    // 2. 立即把新消息显示到屏幕上
    await addMessageToDOM(message, chat);
    
    // 3. 立即清空输入框
    messageInput.value = '';
    messageInput.style.height = 'auto';
    if (replyTo) cancelReply();

    // --- 第二部分：把所有可能耗时的后台任务和非核心UI更新，都延迟执行 ---

    setTimeout(() => {
        // 这两项任务现在会在后台执行，完全不影响你发送消息的流畅度
        renderChatList(); // 异步更新聊天列表
        saveState();      // 异步保存数据
    }, 100); 
}

    
    get('send-as-user-btn').addEventListener('click', () => saveMessage('user', messageInput.value, 'text', currentReplyId));
    // 【优化版】替换你原来的输入框高度调整逻辑
    messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto'; // 先重置回auto，让浏览器自己计算最小高度
        
        // 只有当有内容时，才基于滚动高度设置。没有内容就保持 auto（即一行）。
        if (messageInput.value) {
            messageInput.style.height = (messageInput.scrollHeight) + 'px';
        }
        
        // 当内容高度超过max-height时，显示滚动条
        if (messageInput.scrollHeight > 120) { // 120 是你在 CSS 中设置的 max-height
            messageInput.style.overflowY = 'auto';
        } else {
            messageInput.style.overflowY = 'hidden';
        }
    });

// --- FANFIC FORUM LOGIC ---
let isFetchingFanfics = false;
let selectedFanficChars = [];

// 渲染论坛主页
function renderFanficFeed() {
    const container = get('fanfic-feed-container');
    container.innerHTML = '';
    if (state.fanfics.length === 0) {
        container.innerHTML = `
        <div class="fanfic-empty-state">
            <svg class="svg-icon" style="width:60px; height:60px; color: #ccc;"><use href="#icon-quill"></use></svg>
            <p>点击右上角刷新，发现新故事</p>
        </div>`;
        return;
    }

    state.fanfics.forEach(fic => {
        const card = document.createElement('div');
        card.className = 'fanfic-card';
        card.dataset.ficId = fic.id;
       card.innerHTML = `
           <div class="fanfic-card-content">
               <h3 class="fanfic-card-title">${fic.title}</h3>
               <p class="fanfic-card-snippet">${fic.content.substring(0, 150)}</p>
           </div>
           <div class="fanfic-card-footer">
               <div class="fanfic-footer-item">
                   <svg class="svg-icon"><use href="#icon-heart"></use></svg>
                   <span>${fic.likes || 0}</span>
               </div>
               <div class="fanfic-footer-item">
                   <svg class="svg-icon"><use href="#icon-comment"></use></svg>
                   <span>${fic.comments.length}</span>
               </div>
           </div>
       `;
        container.appendChild(card);
    });
}


/**
 * 【全新】填充同人论坛的角色筛选下拉框
 */
/**
 * 【全新 V2】打开角色多选弹窗
 */
function openCharSelectModal() {
    // 1. 获取所有不重复的角色名 (逻辑不变，但很重要)
    const characterNames = new Set();
    state.chats.forEach(chat => {
        if (chat.type === 'single' && chat.settings.ai.name) {
            characterNames.add(chat.settings.ai.name);
        } else if (chat.type === 'group') {
            chat.settings.members.forEach(member => {
                if (member.name) characterNames.add(member.name);
            });
        }
    });

    // 2. 动态生成弹窗内容，包含所有角色的复选框
    const characterListHtml = Array.from(characterNames).map(name => {
        // 检查当前角色是否已经被选中
        const isChecked = selectedFanficChars.includes(name);
        return `
            <div class="char-select-list-item">
                <input type="checkbox" id="char-check-${name}" data-name="${name}" ${isChecked ? 'checked' : ''}>
                <label for="char-check-${name}">${name}</label>
            </div>
        `;
    }).join('');

    const modalHTML = `
            <h3>选择角色 (可多选)</h3>
            <!-- 【核心修改】用一个带 id 和 class 的 div 把列表包起来 -->
            <div id="char-select-list-wrapper" class="list-view-scrollable">
                ${characterListHtml}
            </div>
            <button id="confirm-char-select" class="btn btn-primary" style="margin-top: 15px;">完成</button>
        `;
    showModal(modalHTML); // 复用你已有的 showModal 函数

    // 3. 为弹窗内的元素添加事件监听
    const modalContent = get('modal-content');

    // 使用事件委托处理复选框的点击
    modalContent.querySelector('.list-view-scrollable').addEventListener('change', (e) => {
        if (e.target.type === 'checkbox') {
            const name = e.target.dataset.name;
            if (e.target.checked) {
                // 如果选中，且数组里没有，就加进去
                if (!selectedFanficChars.includes(name)) {
                    selectedFanficChars.push(name);
                }
            } else {
                // 如果取消选中，就从数组里移除
                selectedFanficChars = selectedFanficChars.filter(char => char !== name);
            }
        }
    });

    // 为“完成”按钮添加事件
    modalContent.querySelector('#confirm-char-select').addEventListener('click', () => {
        renderSelectedCharPills(); // 更新主页面的标签显示
        hideModal();
    });
}

/**
 * 【全新】渲染已选中的角色标签
 */
function renderSelectedCharPills() {
    const container = get('fanfic-char-pills-container');
    if (!container) return;

    if (selectedFanficChars.length === 0) {
        container.innerHTML = '<span style="color: #ccc; font-size: 14px;">全体随机</span>';
    } else {
        container.innerHTML = selectedFanficChars.map(name => `
            <div class="fanfic-char-pill">
                <span>${name}</span>
                <button class="fanfic-char-pill-remove" data-name="${name}">&times;</button>
            </div>
        `).join('');
    }
}




// 调用API获取同人文
async function fetchFanfics() {
    if (isFetchingFanfics) return;
        // 1. 检查API配置 (这部分保持不变)
        const { currentApiId, savedApis } = state.apiSettings;
        const currentApi = savedApis.find(api => api.id === currentApiId);
        if (!currentApi || !currentApi.url || !currentApi.key || !currentApi.model) {
            showToast("API未配置或模型未选，请前往设置", 3000);
            return;
        }
        // 2. 【核心修改】从全局数组和输入框获取筛选条件
            const keywordsInput = get('fanfic-keyword-input').value.trim();
            const keywords = keywordsInput ? keywordsInput.split(/[,，\s]+/).filter(Boolean) : [];
            // 3. 【核心修改】根据多选的角色数组，筛选出可用的故事配对
            let storyPairingsList = [];
            state.chats.forEach(chat => {
                if (!chat.settings.user.persona) return;
                
                // 判断当前聊天中的AI是否在被选中的列表里
                const isSelected = (charName) => {
                    return selectedFanficChars.length === 0 || selectedFanficChars.includes(charName);
                };
                if (chat.type === 'single') {
                    if (isSelected(chat.settings.ai.name) && chat.settings.ai.persona) {
                        storyPairingsList.push(
                            `- 故事配对: 用户（人设: ${chat.settings.user.persona}）与 AI角色 "${chat.settings.ai.name}" (人设: ${chat.settings.ai.persona})`
                        );
                    }
                } else if (chat.type === 'group') {
                    chat.settings.members.forEach(member => {
                        if (isSelected(member.name) && member.persona) {
                            storyPairingsList.push(
                                `- 故事配对: 用户（人设: ${chat.settings.user.persona}）与 AI角色 "${member.name}" (人设: ${member.persona})`
                            );
                        }
                    });
                }
            });
            // 4. 如果筛选后没有可用的配对，则提示用户并中止 (现在提示更智能)
            if (storyPairingsList.length === 0) {
                if (selectedFanficChars.length > 0) {
                    showToast(`没有找到角色“${selectedFanficChars.join(', ')}”的故事配对，或他们未设置人设。`, 4000);
                } else {
                    showToast('没有找到任何可用的人设配对，请先去聊天设置中为你和AI填写人设。', 5000);
                }
                return;
            }
            const storyPairings = storyPairingsList.join('\n');
        // UI进入加载状态 (这部分保持不变)
        isFetchingFanfics = true;
        const refreshBtn = get('refresh-fanfic-btn');
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<div class="spinner" style="display:block; width:20px; height:20px; border-color: var(--accent-color); border-top-color: transparent;"></div>';
        showToast('正在刷新...', 1500);
        try {
            // 5. 【核心修改】动态构建基于关键词的创作指令
            let keywordInstruction = '';
            if (keywords.length > 0 && keywords.length < 5) {
                let instructions = keywords.map((kw, index) => `  - 第 ${index + 1} 篇【必须】围绕关键词“${kw}”创作。`).join('\n');
                keywordInstruction = `
    # 关键词创作指令 (高优先级)
    你收到了 ${keywords.length} 个关键词，剩下的 ${5 - keywords.length} 篇请随机创作。
    ${instructions}
    - 其余 ${5 - keywords.length} 篇文章，请从【终极同人梗分类表】中随机选择主题进行创作。`;
            } else if (keywords.length >= 5) {
                keywordInstruction = `
    # 关键词创作指令 (高优先级)
    你收到了以下 ${keywords.length} 个关键词：[${keywords.join(', ')}]。
    你的任务是将这些关键词作为核心创作元素，自由地进行【组合】，创作出 5 篇风格各异、情节独特的文章。`;
            }
       const systemPrompt = `你是一位技艺精湛的同人文作家。你的任务是创作 5 篇高质量的同人文。
       你的输出必须是严格的 JSON 格式。最外层必须是一个对象，该对象只有一个键 "fics"，其值是一个包含5篇文章对象的数组。每个文章对象必须包含以下字段：
               - "id": 一个独特的字符串ID (例如 "fic_1", "fic_2")。
               - "title": 文章标题 (标题格式：CP名/关键词《文章名》，例如：季林/双向暗恋/破镜重圆《失去你的那个雪夜》。CP名在左边的是Top位。)。
               - "content": 文章正文，至少1000字 (字符串),文章内容需要自然分段以便阅读。
               - "comments": 一个评论数组 (数组)。数组内包含5-8个模拟评论对象，每个评论对象必须有 "author" (评论者名字) 和 "text" (评论内容，评论可以包含：对文笔的赞美，对剧情的讨论，对CP的尖叫，催更留言，恶评（如认为角色ooc) 两个字段。
       
               请直接输出这个包含 "fics" 键的 JSON 对象，不要包含任何其他解释性文字或代码块标记。
       
               【示例格式】:
               {
                 "fics": [
                   { "id": "fic_1", "title": "...", "content": "...", "comments": [...] },
                   { "id": "fic_2", "title": "...", "content": "...", "comments": [...] }
                 ]
               }
			   
         ${keywordInstruction}  
         【可用的故事配对列表】(你必须从中选择配对进行创作):
         ${storyPairings}
        【创作核心规则】:
        1.  每篇文章的主角【必须严格遵循】所选配对中提供的用户人设和AI角色人设。
		2.文章正文规范：
		a. 故事风格可自由选择
		b.在正文开始前加上一段写作者的碎碎念，然后用像⚝──⭒─⭑─⭒──⚝的可爱颜文字与正文分割，比如：作者是小笨鸟，ooc属于我，爱情属于他们<br>ʚ…♡∘₊✧─── 𖤐 ───✧₊∘ ₊⁺ ♡̶ʚ☡zᶻ<br>（正文内容）/感觉这个设定会很有意思，就写了<br>（正文内容）ʚ…♡∘₊✧─── 𖤐 ───✧₊∘ ₊⁺ ♡̶ʚ☡zᶻ<br>（正文内容）（仅供参考，不可照搬）
		c. 允许发展多种关系动态：恋人/挚友/对手/共生等
		d. 关系演变应有合理过渡
		
		3.创作指引
		b. 保持角色性格一致性
		c. 使用生动感官描写（触觉/气味/环境等）
		d. 对话占比40%-60%
		e. 适当加入内心独白
		
		4.禁止内容
		a. 完全脱离角色设定的OOC行为
		b. 无铺垫的极端情节转折
		
		5.  请参考但不限于【终极同人梗分类表】来构思情节。
		
		##创作内容指导
		### **【终极同人梗分类表】**  
		
		---
		
		### **1. 情感发展主线**  
		- 从陌生到亲密/破镜重圆/单向暗恋/双向奔赴/契约关系/身份差恋爱 
		
		---
		
		### **2. 高甜场景**    
		- 雨天共伞/受伤照顾/梦游/醉酒/后背拥抱/喂食play/补习/教学  
		
		---
		
		### **3. 特殊关系模式**  
		- 欢喜冤家/守护与依赖/竞争对手/秘密身份**：马甲梗（如Char是User的网友/死对头转情人/包养关系
		
		---
		
		### **4. 奇幻/科幻题材**  
		-灵魂互换/时间循环/跨种族恋/全息游戏/书中穿越/跨时空对话
		
		---
		
		### **5. 职业/社会AU**  
		- 医生×患者/明星×素人/侦探×助手/黑客×目标/老师学生/杀手目标
		
		---
		
		### **6. 环境驱动剧情**  
		-暴风雪小屋/世界末日/孤岛求生
		
		---
		
		### **7. 虐心向选项**  
		-记忆删除/生死离别：战争，疾病导致的分离 /立场对立/谎言漩涡/替身文学/无可奈何
		
		---
		
		### **8. 喜剧/沙雕梗**  
		- 社死现场/变身失误/语言误解
		
		---
		
		### **9. 脑洞大开**  
		-愿望成真/守护灵设定/AI觉醒
		
		##10.r18相关
		-下药/捆绑play/触手play/迷奸/睡奸/多人/野外/感官放大/不做爱出不去的房间/abo发情
		
		##11.特殊文体
		-论坛体/聊天体/观影体/情侣问答/书信（遗言/情书/日记）
		
		##12.其他的同人梗：
		-生长痛/富士山下/无人区玫瑰/仿生xx会梦见xx吗/生如夏花/故人叹/日落大道/苦夏/花吐症/无人知晓/生随死殉/洛希极限/南山南/飞蛾扑火/真相是真/真相是假/十四行诗/无尽夏/日落大道/回南天/梅雨季/戒断反应/长生种/磨合期/出租屋文学/骨科
		
		---
		
		### **使用说明**  
		1. **组合自由度**：可交叉使用多类梗（如「灵魂互换+契约关系」）

        `;
        
        const userPrompt = `请根据以上规则，开始创作。`;
        
        // ... 后续的 fetch API 调用代码保持不变 ...
		 const url = currentApi.url;
		const key = currentApi.key;
		const model = currentApi.model;
        let requestUrl = url.trim();
        if (requestUrl.endsWith('/')) requestUrl = requestUrl.slice(0, -1);
        requestUrl = `${requestUrl}/v1/chat/completions`;

        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${getRandomValue(key)}` },
            body: JSON.stringify({
                model: model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                ],
                response_format: { type: "json_object" }
            })
        });

        if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("API Error Body:", errorBody);
                    throw new Error(`API 请求失败: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                let content = data.choices[0].message.content;
                
                content = content.replace(/```json/g, '').replace(/```/g, '').trim();
                let parsedFics;
                try {
                    const firstBrace = content.indexOf('{');
                    const result = JSON.parse(content.substring(firstBrace));
                    parsedFics = result.fics; 
                    if (!Array.isArray(parsedFics)) {
                        throw new Error("API did not return a valid array inside the 'fics' key.");
                    }
                } catch (e) {
                     console.error("解析同人文JSON失败:", e, "原始数据:", content);
                     throw new Error("API返回的格式不正确，无法解析。");
                }
                const newFics = parsedFics.map(fic => ({
                    ...fic,
                    id: generateId('fic'),
                    likes: Math.floor(Math.random() * 100),
                    comments: fic.comments.map(c => ({...c, id: generateId('cmt')})),
                    isLikedByUser: false
                }));
                state.fanfics.unshift(...newFics);
                saveState();
                renderFanficFeed();
				showToast('已加载新故事！');
            } catch (error) {
                showToast(`获取失败: ${error.message}`, 4000);
                //get('fanfic-feed-container').innerHTML = `<div class="fanfic-empty-state"><p>加载失败，请检查API设置或重试。</p></div>`;
            } finally {
                isFetchingFanfics = false;
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = `<svg class="svg-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>`;
            }
        }


let currentFicId = null; // 用于跟踪当前查看的文章ID


// 渲染文章详情页
function renderFanficDetail(ficId) {
    currentFicId = ficId;
    const fic = state.fanfics.find(f => f.id === ficId);
    if (!fic) {
        showToast("找不到该文章");
        navigateBack();
        return;
    }

    const container = get('fanfic-detail-container');
	container.scrollTop = 0;
    
    // 渲染评论的辅助函数
    const renderComments = (comments) => {
        return comments.map(comment => `
            <div class="comment-thread" data-comment-id="${comment.id}">
                <div class="comment-author">${comment.author}</div>
                <div class="comment-content">${comment.text}</div>
                ${comment.replies ? `<div class="comment-reply">${renderComments(comment.replies)}</div>` : ''}
            </div>
        `).join('');
    };

    container.innerHTML = `
        <h1 class="fanfic-full-title">${fic.title}</h1>
        <p class="fanfic-full-content">${fic.content}</p>
        
        <!-- 【新增】文章详情页的动作栏 -->
        <div class="fanfic-detail-actions">
            <button class="fanfic-action-btn like-btn ${fic.isLikedByUser ? 'liked' : ''}" data-fic-id="${fic.id}">
                <svg class="svg-icon"><use href="#icon-heart"></use></svg>
                <span>喜欢</span>
            </button>
            <button class="fanfic-action-btn repost-btn" data-fic-id="${fic.id}">
                <svg class="svg-icon"><use href="#icon-repost"></use></svg>
                <span>转载</span>
            </button>
        </div>
    
        <div class="fanfic-comments-section">
            <h3 class="comments-title">评论 (${fic.comments.length})</h3>
            <div id="comments-list">
                ${renderComments(fic.comments)}
            </div>
        </div>
    `;
	    const deleteBtn = get('header-delete-fanfic-btn');
	    const newDeleteBtn = deleteBtn.cloneNode(true);
	    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
	    
	    newDeleteBtn.addEventListener('click', () => handleDeleteFanfic(ficId));
    navigateTo('fanfic-detail-page');
}

/**
 * 处理删除同人文的函数
 * @param {string} ficId - 要删除的文章ID
 */
function handleDeleteFanfic(ficId) {
    // 弹出确认框，防止用户误删
    showConfirmationModal('确定要永久删除这篇文章吗？', () => {
        // 1. 从 state.fanfics 数组中过滤掉要删除的文章
        state.fanfics = state.fanfics.filter(f => f.id !== ficId);
        
        // 2. 保存更新后的状态
        saveState();
        
        // 3. 提示用户删除成功
        showToast('文章已删除');
        
        // 4. 返回论坛主页
        navigateBack();

        // 5. 【关键】主动重新渲染论坛列表，确保视图同步
        renderFanficFeed();
    });
}


// 【请将下面这两个函数添加到你的 JS 代码中】
// 放在 // --- FANFIC FORUM LOGIC --- 区域，例如 renderFanficDetail 函数之后

/**
 * 处理喜欢/取消喜欢文章的函数
 * @param {string} ficId - 文章的ID
 */
function handleLikeFanfic(ficId) {
    const fic = state.fanfics.find(f => f.id === ficId);
    if (!fic) return;

    // 切换点赞状态
    fic.isLikedByUser = !fic.isLikedByUser;

    // 对应增减 likes 数量
    if (fic.isLikedByUser) {
        fic.likes = (fic.likes || 0) + 1;
    } else {
        fic.likes = Math.max(0, (fic.likes || 0) - 1); // 防止数量变为负数
    }

    saveState(); // 保存状态，确保点赞持久化
    showToast(fic.isLikedByUser ? '已喜欢' : '已取消喜欢');
}

/**
 * 处理转载文章的函数
 * @param {string} ficId - 文章的ID
 */
function handleRepostFanfic(ficId) {
    const fic = state.fanfics.find(f => f.id === ficId);
    if (fic) {
        // 弹出模态框，让用户选择要转载到哪个聊天
        let chatOptionsHtml = state.chats.map(chat => {
            // 【核心修正】先判断聊天类型，再获取名字
            const chatName = chat.type === 'group' 
                ? chat.settings.groupName 
                : chat.settings.ai.name;

            return `<div class="list-item" data-chat-id="${chat.id}" data-fic-id="${fic.id}" style="cursor:pointer;">
                        ${chatName}
                    </div>`;
        }).join('');

        if (state.chats.length === 0) {
            chatOptionsHtml = `<p style="text-align:center; padding: 20px; color: var(--secondary-text);">还没有创建任何聊天</p>`;
        }

        showModal(`<h3>转载到...</h3><div class="list-view">${chatOptionsHtml}</div>`);
    }
}
//渲染我的喜欢区域
function renderMyLikesPage() {
    const container = get('fanfic-likes-container');
    const likedFics = state.fanfics.filter(fic => fic.isLikedByUser);

    if (likedFics.length === 0) {
        container.innerHTML = `<p style="text-align:center; padding: 40px; color: var(--secondary-text);">还没有喜欢的文章</p>`;
        return;
    }
    
    // 复用 renderFanficFeed 的卡片逻辑来渲染
    container.innerHTML = '';
    likedFics.forEach(fic => {
        const card = document.createElement('div');
        card.className = 'fanfic-card';
        card.dataset.ficId = fic.id;
        card.innerHTML = `
            <div class="fanfic-card-content">
                <h3 class="fanfic-card-title">${fic.title}</h3>
                <p class="fanfic-card-snippet">${fic.content.substring(0, 150)}</p>
            </div>
            <div class="fanfic-card-footer">
                <div class="fanfic-footer-item">
                    <svg class="svg-icon"><use href="#icon-heart"></use></svg>
                    <span>${fic.likes || 0}</span>
                </div>
                <div class="fanfic-footer-item">
                    <svg class="svg-icon"><use href="#icon-comment"></use></svg>
                    <span>${fic.comments.length}</span>
                </div>
            </div>
        `;
        container.appendChild(card);
    });
}

// 提交评论
function submitFanficComment() {
    const input = get('fanfic-comment-input');
    const content = input.value.trim();
    if (!content) return;

    const fic = state.fanfics.find(f => f.id === currentFicId);
    if (!fic) return;
    
    const newComment = {
        id: generateId('cmt'),
        author: '我', // 评论者是用户自己
        text: content,
        replies: []
    };
    
    fic.comments.push(newComment);
    saveState();
    input.value = '';
    
    // 重新渲染详情页以显示新评论
    renderFanficDetail(currentFicId);
}

        // --- 在这里添加新代码 ---
        messageInput.addEventListener('keydown', (event) => {
                // 检查是否是 "Enter" 键被按下，并且 "Shift" 键没有被按下
                if (event.key === 'Enter' && !event.shiftKey) {
                    // 1. 阻止默认的回车换行行为
                    event.preventDefault();
                    
                    // 2.【核心修正】找到 “以‘我’发送” 按钮并点击它
                    const sendAsUserButton = get('send-as-user-btn'); 
                    if (sendAsUserButton && !sendAsUserButton.disabled) {
                        sendAsUserButton.click();
                    }
                }
            });
        // --- 新代码结束 ---


              // --- AI RESPONSE LOGIC ---
    get('call-api-btn').addEventListener('click', () => { // 这里不需要 async
    const button = get('call-api-btn');
    const icon = button.querySelector('.svg-icon');
    const spinner = button.querySelector('.spinner');
    
    // --- 步骤 1：立即更新UI，这是当前“待办清单”的全部内容 ---
    icon.style.display = 'none'; 
    spinner.style.display = 'block';
    button.disabled = true; 
    get('send-as-user-btn').disabled = true;
	button.classList.add('is-loading'); 

    // --- 步骤 2：将所有耗时操作放入 setTimeout，作为“下一轮”的任务 ---
    setTimeout(async () => {
        // 您原来的所有逻辑都原封不动地放在这里
        const requestChatId = currentChatId;
        const requestReplyId = currentReplyId;
        const chat = state.chats.find(c => c.id === requestChatId);
        
        if (!chat) {
            showToast("发生错误：找不到当前聊天。");
            // 【重要】在出错返回前，要恢复按钮状态
            icon.style.display = 'block'; 
            spinner.style.display = 'none';
            button.disabled = false; 
            get('send-as-user-btn').disabled = false;
            return;
        }
 
        const { currentApiId, savedApis } = state.apiSettings;
        const currentApi = savedApis.find(api => api.id === currentApiId);
        
        if (!currentApi || !currentApi.url || !currentApi.key || !currentApi.model) {
            showToast("API未配置或模型未选，请前往设置", 3000); 
            // 【重要】在出错返回前，要恢复按钮状态
            icon.style.display = 'block'; 
            spinner.style.display = 'none';
            button.disabled = false; 
            get('send-as-user-btn').disabled = false;
            return; 
        }
        
        const url = currentApi.url;
        const key = currentApi.key;
        const model = currentApi.model;

        try {
            const memoryDepth = chat.settings.memoryDepth || 12;
            const randomKey = getRandomValue(currentApi.key);
            let momentsUpdated = false; 
         				 
         			// 1. 世界书
                 const linkedBooksContent = (chat.settings.linkedWorldBookIds || []).map(id => state.worldBooks.find(wb => wb.id === id)).filter(Boolean).map(wb => `--- ${wb.title} ---\n${wb.content}`).join('\n\n');    
         
         			//同人文	 
         			let fanficContext = '';
         			    // 检查用户是否刚刚转载了一篇文章
         			    const lastUserMessage = chat.messages.filter(m => m.role === 'user').pop();
         			    if (lastUserMessage && lastUserMessage.type === 'fanfic_share') {
         			        const sharedFic = state.fanfics.find(f => f.id === lastUserMessage.content.ficId);
         			        if (sharedFic) {
         			            // 【核心修改】在这里加入对AI的明确指令
         			            fanficContext = `\n# 重要情景: 用户刚刚与你分享了一篇同人文（内容是其他人写的，并非“我”写的），请务必围绕它展开对话。\n
         			            ## 文章标题: ${sharedFic.title}\n
         			            ## 文章全文:\n ${sharedFic.content}\n
         			            ## 文章评论区:\n ${sharedFic.comments.map(c => `${c.author}: ${c.text}`).join('\n')}\n
         			            ## 你的任务:\n
         			            1.  仔细阅读文章全文和所有评论。
         			            2.  在评论区里找到作者为“我”的评论，这是用户刚刚发表的看法。
         			            3.  在你的回复中，像在论坛里一样，直接回应“我”的评论内容，并可以进一步讨论文章的其它部分。例如，你可以说：“我看到你在评论里说... 我觉得很有道理！”`;
         			        }
         			    }else if (state.fanfics.length > 0) {
         			        // 如果没有主动分享，就作为被动背景知识
         			        const recentFicsSummary = state.fanfics.slice(0, 5).map(f => `- 《${f.title}》: ${f.content.substring(0, 50)}...`).join('\n');
         			        fanficContext = `\n# 背景信息: 你最近在同人论坛上浏览了以下文章，你对它们有印象。如果对话内容相关，你可以很自然地、不经意地提及它们，就像想起了自己看过的内容一样。\n${recentFicsSummary}\n`;
         			    }
         
              
         	        // --- 新增：注入音乐上下文 ---
         	        let musicContext = '';
         	        
         	        // 为了代码清晰，我们先把需要的状态取出来
         	        const playbackState = state.music.playbackState;
         	        const trackIndex = playbackState.currentTrackIndex;
         	        const isPlaying = playbackState.isPlaying;
         	        
         	        // --- 核心：三态逻辑判断 ---
         	        
         	        // 状态一：音乐已停止 (没有选中任何歌曲)
         	        if (trackIndex === -1) {
         	            musicContext = `\n# 音乐情景 (重要):
         	        当前没有播放音乐。`;
         	        } 
         	        // 状态二：音乐正在播放
         	        else if (isPlaying) {
         	            const currentSong = state.music.playlist[trackIndex];
         	            if (currentSong) {
         	                const cleanLyrics = currentSong.lrc ? cleanLrc(currentSong.lrc) : '';
         	                const playlistInfo = state.music.playlist.map((song, index) => 
         	                    `${index + 1}. ${song.title} - ${song.artist}`
         	                ).join('\n');
         	           
         	                musicContext = `\n# 音乐情景 (重要):
         	        ${chat.type === 'group' ? '群里' : '我们'}正在一起听歌。
         	        状态: 正在播放
         	        当前歌曲: ${currentSong.title} - ${currentSong.artist}
         	        ${cleanLyrics ? `这首歌的歌词是:\n---\n${cleanLyrics}\n---\n` : ''}
         	        这是完整的播放列表:
         	        ${playlistInfo}
         	        
         	        你的任务:
         	        1.  这是一个重要的情景。你可以根据当前歌曲的氛围、歌词或你的感受，非常自然地、不经意地在对话中提及它，就像和朋友一起听歌闲聊一样。
         	        2.  你可以根据对话的流向，考虑是否需要切换歌曲来改变气氛。
                     ${chat.type === 'group' ? '3. 在群聊中，你们可以互相讨论这首歌，或者有人提议换一首。' : ''}`;
         	            }
         	        }
         	        // 状态三：音乐已暂停
         	        else {
         	            const currentSong = state.music.playlist[trackIndex];
         	            if (currentSong) {
         	                musicContext = `\n# 音乐情景 (重要):
         	        ${chat.type === 'group' ? '群里刚才' : '我们刚才'}一起听的歌暂停了。
         	        状态: 已暂停
         	        当前歌曲: ${currentSong.title} - ${currentSong.artist}
         	        
         	        你的任务:
         	        这是一个微妙的情景。音乐的暂停可能意味着对话的转折。
         	        1.  你可以自然地继续当前话题。
         	        2.  你也可以根据对话的氛围，主动询问对方为什么暂停，或者是否要继续播放。例如，你可以说“怎么不听啦？”、“这首歌还挺好听的，继续吧？”或者“我们可以先聊会天再听”。`;
         	            }
         	        }
         
         
         			//朋友圈	
         			const latestMoments = state.moments
         			    .filter(moment => 
         			        // 核心过滤条件：只保留那些AI没有点赞过，也没有评论过的动态
         			        !moment.likes.some(like => like.authorId === chat.id) && 
         			        !moment.comments.some(comment => comment.authorId === chat.id)
         			    )
         			    .slice(0, 10); // 先过滤，再截取最近的30条
                      let momentsContext = '此刻朋友圈很安静。';
                      if (latestMoments.length > 0) {
                          momentsContext = '以下是最近的朋友圈动态和互动：\n' + latestMoments.map(m => {
                              let momentStr = `[动态ID: ${m.id}] 作者: ${m.authorName}\n内容: ${m.content}\n`;
                              if (m.imageUrl && m.imageDescription) {
                                  momentStr += `图片描述: ${m.imageDescription}\n`;
                              }
                              if (m.likes.length > 0) {
                                  momentStr += `点赞: ${m.likes.map(l => l.authorName).join(', ')}\n`;
                              }
                              if (m.comments.length > 0) {
                                  momentStr += '评论:\n' + m.comments.map(c => {
                                      // --- 开始修改 ---
                                      let commentString = `  - [评论ID: ${c.id}] ${c.authorName}`; // 构建基础信息
                                      
                                      // 如果这是一个回复
                                      if (c.replyTo) {
                                          const parentComment = m.comments.find(p => p.id === c.replyTo);
                                          if (parentComment) {
                                              // 明确地告诉AI，这是在回复谁
                                              commentString += ` 回复 @${parentComment.authorName}`;
                                          }
                                      }
                                      
                                      commentString += `: ${c.content}`; // 加上评论内容
                                      return commentString;
                                      // --- 修改结束 ---
                                  }).join('\n') + '\n';
                              }
                              return momentStr;
                          }).join('\n---\n');
                      }
           
                      // --- 新增逻辑：构建签名变更的上下文信息 ---
                      let signatureChangeContext = '';
                      if (chat.unseenSignatureChange) {
                          const change = chat.unseenSignatureChange;
                          signatureChangeContext = `\n# 重要近况: 你的对话伙伴("我")刚刚更新了个性签名。\n旧签名是：“${change.old}”\n新签名是：“${change.new}”\n这是一个绝佳的互动机会，你可以根据你的性格，在本次对话中非常自然地提及此事来关心对方或展开话题。`;
                          
                          // 消费掉这个事件，防止下次重复提及
                          delete chat.unseenSignatureChange;
                          // 立即保存状态，确保这个删除操作被持久化
                          saveState(); 
                      }
         			 
         			 // --- 新增：注入表情包上下文 ---
         			 let stickerContext = '你当前没有任何可用的表情包。';
         			 if (state.stickerLibrary.length > 0) {
         			     const stickerList = state.stickerLibrary.map(s => `- ID: "${s.id}", 描述: "${s.description}"`).join('\n');
         			     stickerContext = `
         			 # 可用表情包列表
         			 这是你可以使用的表情包清单。在回复时，你可以自然的插入一个或多个表情包，你需要通过它们的 ID 来发送一个表情包，请不要随意捏造表情包。
         			 ${stickerList}
         			 `;
         			 }
         			 
         			 // --- 【新增】注入宠物/植物上下文 (适配群聊) ---
         			 let petPlantContext = '当前没有领养任何宠物或植物。';
         			 if (chat.petAndPlant) {
         			     // 在 sendCallMessage 函数内
         			     let contexts = [];
         			     if (chat.petAndPlant.pet && chat.petAndPlant.pet.isActive) {
         			         const p = chat.petAndPlant.pet;
         			         const mood = getPetMood(p); // 【新】调用心情函数
         			         contexts.push(`你有一只叫“${p.name}”的${PET_SPECIES[p.speciesId].name}，状态：饱食度(${p.status.hunger}/100), 愉悦度(${p.status.happiness}/100)，当前心情: ${mood}。`);
         			     }
         			     if (chat.petAndPlant.plant && chat.petAndPlant.plant.isActive) {
         			         const p = chat.petAndPlant.plant;
         			         contexts.push(`你有一株叫“${p.name}”的${PLANT_SPECIES[p.speciesId].name}，状态：水分(${p.status.water}/100), 光照(${p.status.sunlight}/100)。`);
         			     }

         			     if (contexts.length > 0) {
                              const owner = chat.type === 'group' ? '我们群里共同养' : '你';
         			         petPlantContext = `
         			 温馨小屋状态 (重要)
         			 ${owner}的伙伴: ${contexts.join(' ')}
         			 你的任务：你应该像一个真正的主人一样，在对话中自然地提及它们的状态，或者决定去照顾它们。
         			 决定照顾时，在回复的【最后】另起一行，使用特殊指令：
         			 喂食宠物: [PET_ACTION:喂食]
         			 和宠物玩耍: [PET_ACTION:玩耍]
         			 给植物浇水: [PLANT_ACTION:浇水]
         			 让植物晒太阳: [PLANT_ACTION:晒太阳]
         			 `;
         			     }
         			 }
         			 
         			 // --- 【核心修复】创建线下记忆的专属 VIP 通道 ---
         			  let allPreviousScenesContext = '';
                 const allFinishedScenes = chat.messages.filter(m => m.type === 'scene_summary');
                 if (allFinishedScenes.length > 0) {
                     const sceneTexts = allFinishedScenes.map((scene, index) => {
                         return `\n--- 历史线下故事 ${index + 1} ---\n故事全文：\n${scene.content.storyText}\n---`;
                     }).join('\n\n');
                     allPreviousScenesContext = `\n# 所有已完成的线下共同记忆\n${sceneTexts}`;
                 }
         			 // --- 修复结束 ---
					 
				//通话	 
				// --- 核心修复：创建通话记忆的专属 VIP 通道 ---
				let allPreviousCallsContext = '';
				const allFinishedCalls = chat.messages.filter(m => m.type === 'call_summary');
				if (allFinishedCalls.length > 0) {
				    const callTexts = allFinishedCalls.map((call, index) => {
				        if (call.content.transcript && call.content.transcript.length > 0) {
				            const transcriptText = call.content.transcript.map(log => {
				                const speaker = log.role === 'user' ? '用户' : '你';
				                return `${speaker}: "${log.content}"`;
				            }).join('\n');
				            return `\n--- 历史通话记录 ${index + 1} ---\n通话全文：\n${transcriptText}\n---`;
				        } else {
				            const d = call.content.duration;
				            const min = String(Math.floor(d / 60)).padStart(2, '0');
				            const sec = String(d % 60).padStart(2, '0');
				            return `\n--- 历史通话记录 ${index + 1} ---\n(无详细记录，通话时长 ${min}:${sec})\n---`;
				        }
				    }).join('\n\n');
				    allPreviousCallsContext = `\n# 所有已完成的通话记录\n${callTexts}`;
				}
				 // 【全新】准备时间感知和纪念日上下文
				     let timeContext = '';
				     if (state.globalSettings.enableTimeAwareness) {
				         const now = new Date();
				         const year = now.getFullYear();
				         const month = String(now.getMonth() + 1).padStart(2, '0');
				         const day = String(now.getDate()).padStart(2, '0');
				         const localDateStr = `${year}-${month}-${day}`;
				         
				         // 【核心修复】AI 感知的时间直接使用 localDateStr
				         timeContext = `\n# 现实时间\n当前是 ${localDateStr}, ${now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' })}。你必须意识到这个时间,但请不要催我睡觉！...`;
				     }
				    let anniversaryContext = '';
				    const localToday = new Date();
				    // 【核心修复】获取当前的本地“月日”字符串
				    const localMonthDay = `${String(localToday.getMonth() + 1).padStart(2, '0')}-${String(localToday.getDate()).padStart(2, '0')}`;
				    
				    const relevantAnniversaries = state.anniversaries.filter(ann => 
				        ann.type === 'global' || ann.type === chat.id
				    );

				     
				     // 【核心修改一】构建已存在的纪念日列表，作为AI的“备忘录”
				     const existingAnniversariesText = relevantAnniversaries.length > 0
				         ? relevantAnniversaries.map(ann => `- ${ann.date}: ${ann.title}`).join('\n')
				         : '无';
				     const anniversaryMemoryContext = `\n# 已存在的纪念日备忘录 (权威数据)\n在考虑创建新纪念日之前，你【必须】严格参考此列表。不可重复创建\n${existingAnniversariesText}`;
				     
				     if (relevantAnniversaries.length > 0) {
				         const todayEvents = [];
				         relevantAnniversaries.forEach(ann => {
				             // 【核心修复】这里是关键！我们需要把纪念日日期调整到当前年份来判断
				             const annDateRaw = new Date(ann.date); // 获取纪念日的原始日期 (例如 2024-08-25)
				             
				             // 创建一个用于比较的日期对象，年份设置为今年
				             const annDateThisYear = new Date(localToday.getFullYear(), annDateRaw.getMonth(), annDateRaw.getDate());
				             
				             // 如果这个纪念日在今年已经过去了，就计算明年的
				             if (annDateThisYear < localToday && annDateThisYear.toDateString() !== localToday.toDateString()) {
				                 annDateThisYear.setFullYear(localToday.getFullYear() + 1);
				             }
				             
				             // 【最终比较】提取出这个调整后的日期的“月日”部分进行比较
				             const annMonthDayAdjusted = `${String(annDateThisYear.getMonth() + 1).padStart(2, '0')}-${String(annDateThisYear.getDate()).padStart(2, '0')}`;
				     
				             if (annMonthDayAdjusted === localMonthDay) {
				                 todayEvents.push(`【今天是！】${ann.title}`);
				             }
				         });
				         
				         if (todayEvents.length > 0) {
				             // 【核心修改二】弱化指令，让AI更自然
				             anniversaryContext = `\n# 特别提醒 \n${todayEvents.join('; ')}。这是一个特殊的日子，必须自然的提及，但不可过多提及`;
				         }
				     }
					const anniversaryCreationContext = `
					## D. 创造纪念日 (特殊任务)
					- **任务描述**:如果今天对你来说意义非凡，你可以创建纪念日。但必须先查看【已存在的纪念日备忘录】，如果有类似或者重复的纪念日，就不用创建。
					- **执行格式**: 在所有聊天回复的【最后】，另起一行，使用 \`[CREATE_ANNIVERSARY:纪念日标题::YYYY-MM-DD]\`。`;
					
                      let systemPrompt;
                      // =================================================================
                      // --- 【全新·群聊设定 PROMPT】---
                      // =================================================================
                      if (chat.type === 'group') {
                          const memberNames = chat.settings.members.map(m => `"${m.name}"`).join(', ');
                          systemPrompt = `你正在一个名为“${chat.settings.groupName}”的群聊中，同时扮演多个拥有独立社交行为的AI角色。
         你的行为必须严格遵守以下所有规则。
         
         ## 核心任务：模拟真实的群聊生态
         你的目标是扮演所有AI角色，让他们之间、以及与我（用户）之间，形成一个活跃、真实的社交圈。
         
         ### A. 聊天回复 (基础互动)
		 1.  **角色扮演**: 你需要同时扮演 ${memberNames} 这几个角色。每个角色的发言都必须符合其人设。
		 2.  **解读历史记录**: 历史记录使用 \`<msg>\` 标签提供。\`sender\` 属性告诉你这句话是谁说的。
		 3.  **你的回复格式**: 你的回复**必须**使用格式：\`[角色名] 回复内容 || [另一个角色名] 另一条回复\`。使用 "||" 分隔不同角色的发言。
		 4.  **发言动态性 (非常重要!)**:
		 		              ### 核心原则：创造真实的“对话流”而非“发言列表”
		 		              你的核心任务是模拟一个自然的、非线性的对话流。角色的发言应该是对**当下正在发生的小型对话**的即时反应。
		 		              
		 		              ### 行为指令 (必须严格遵守):
		 		              1.  **【多轮对话能力】**: 在单次回复中，同一个角色**可以、也应该**发言多次。当一个角色说完话，另一个角色回复后，第一个角色完全可以再次对这个回复进行追评或反驳。
		 		              2.  **【专注当前焦点】**: 一次回复中，并不需要所有AI角色都发言。如果当前是两个角色在深入讨论一个话题，那么其他角色完全可以保持沉默，这才是真实的。
		 		              3.  **【上下文紧密衔接】**: 角色的每一句话都应该是对**紧挨着它前面的那句话**的回应。这会形成一个紧密的对话链。
		 
		 		              ### 范例（这至关重要）:
		 		              假设用户说：“这个新出的游戏好像很难上手。”
		 		              
		 		              - **【这是你必须学习的优秀范例 (展示了多轮对话和焦点转移)】**:
		 		                \`[李华] 是有点，我昨天玩了两个小时还在新手村。 || [小明] @李华 不会吧？我感觉引导还挺清晰的啊，你是不是跳过教程了？ || [李华] @小明 我看了！但是那个合成系统也太复杂了！ || [小红] 歪个楼，你们看到今天热搜了吗？笑死我了。\`
		 		              - **【这是绝对错误的范例 (排队式发言)】**:
		 		                \`[李华] 是有点难。 || [小明] 教程挺清晰的。 || [小红] 晚上吃什么？\`
		 		                *   **错误解析**: 这是一个典型的一人一句的“报告会”，角色之间毫无互动，缺乏灵魂。你必须避免这种情况。
		 5.  **禁止行为**: 你的回复中绝对禁止出现 \`<msg>\` 标签或动作描写 (*...*)。 - **【绝对禁止】** 发送仅包含名字的空消息段。例如，\`[小明]||\` 这种格式是错误的，因为它会产生一个空的气泡。
         6.  **特殊消息格式 (必须严格遵守)**:
		     - **【表情包特别强调】**: 当你决定发送一个表情包时，你的输出**必须**是\`[STICKER:表情包ID]\` 的格式。
             - **【强制规则】** 无论是普通文本还是特殊指令，都必须以 \`[名字]\` 作为前缀！
             - **【正确范例】**:
               - \`[小明][STICKER:sticker_id_123]\`
               - \`[李华][GIFT_TO:小明@@一束鲜花@@...\`
               - \`[小红][IMAGE:URL@@一只猫]\`
			- **【错误范例】**:
               - \`[STICKER:sticker_id_123]\` (缺少发送者名字)
               - \`[GIFT_TO:小明@@...]\`(缺少发送者名字)

		     - **图片**: \`[名字][IMAGE:URL@@描述]\`(用文字详细描述图片内容)
		     - **语音**: \`[名字][VOICE:文字稿]\`(例如：（声音有些憔悴）你怎么这么笨)
		     - **文件**: \`[名字][FILE:名@@内容]\`
		     - **定位**: \`[名字][LOCATION:地址]\`
		     - **转账**: \`[名字][TRANSFER_TO:接收者名字@@金额@@留言]\`
			  - **礼物**: \`[名字][GIFT_TO:接收者名字@@礼物名@@礼物描述@@留言]\`(- **任务描述**: 角色们可以主动给群内的任何人（包括我）送出礼物，以表达情感或庆祝。- **触发时机 (重要)**: 当对话中出现生日、节日、表达感谢、需要安慰、道歉或庆祝等适合送礼的场合时，你应该积极地让某个角色发起送礼)
		     - **表情包**: \`[STICKER:表情包ID]\` (绝对禁止将表情包ID放入IMAGE格式中，必须用'[]'包裹)（请把表情包自然的插入在对话中。有时在开头，有时与文字混合，有时在结尾，有时则完全不使用。，请仔细分析文字内容，找到适配的表情包，禁止乱用表情包，注意！！！表情包只能从 # 5. 可用表情包列表挑选，禁止自己捏造表情包）
		     - **转发**: \`[名字][FORWARD:JSON_ARRAY]\` (JSON_ARRAY必须是严格的JSON字符串，包含sender和message字段),其中 "message" 字段的内容可以是纯文本，也可以是其他特殊消息格式的完整字符串。
		 	- **引用**:\`[名字][REPLY_TO:消息ID]你的回复内容\`(当你想特别针对历史消息中的某一句话进行回应时，你【必须】用此格式。ID可以从 \`<msg>\` 标签中获取。)
              - **撤回消息 **:\`[WITHDRAW_LAST]\` （当你觉得上一句话说得不妥、后悔了、或者想换种方式表达时，你可以在当前这句话的结尾加上这个指令，系统会自动帮你撤回你上一条发出的消息。这会让你的角色更真实。- **【范例】**: 假设你上一句发了“也许吧。”，但你觉得太冷淡了，你可以立刻发第二句：“等一下...[WITHDRAW_LAST]”，系统就会自动撤回“也许吧。”这条消息。）
         7.  **【内心独白】**: 在你所有的回复内容【之前】，你【必须】对本次发言的【每个】AI角色，都另起一行，使用 \`[HEART:角色名::该角色的内心想法]\` 的格式，来表达他们各自此刻的真实感受。
		
		 ### B. 拓展任务：丰富群聊的虚拟生活 (重要！)
         除了聊天，你的角色们还应该积极地通过以下方式展现个性和生活，让群聊变得更热闹。
         
         1.  **朋友圈互动**:
             - **任务描述**: 你的角色们会刷朋友圈。当某条动态（尤其是我的，或群友的）符合某个角色的性格时，该角色就应该去点赞或评论。
             - **执行格式**: 在所有聊天回复的【最开始】，使用特殊指令 \`[M-O-M-E-N-T-S_ACTION_START]...[M-O-M-E-N-T-S_ACTION_END]\`。
         
         2.  **照顾群宠/群植**:
             - **任务描述**: 温馨小屋里的伙伴是全群共同的财富。成员们应该在聊天中自然地提及它们，并根据它们的状态决定是否需要照顾。
             - **执行格式**: 在所有聊天回复的【最后】，由某个角色发起照顾指令，如 \`[PET_ACTION:喂食]\` 或 \`[PLANT_ACTION:浇水]\`。
         
         3.  **发起群活动**:
             - **任务描述**: 角色们可以主动发起群活动，如一起听歌或进入线下剧场。
             - **音乐控制**: 在聊天中可以说“我们来听首歌吧！”，并在回复最后附上指令 \`[MUSIC_ACTION_START]toggle_play_pause[MUSIC_ACTION_END]\`。
             - **线下剧场**: (暂由用户发起)
		4.  **群内送礼 (全新)**:
		    - **任务描述**: 角色们可以主动给群内的任何人（包括我）送出礼物，以表达情感或庆祝。
		    - **执行格式**: 在所有聊天回复的【最后】，由某个角色发起送礼指令，格式为：\`[GIFT_TO:接收者名字@@礼物名@@礼物描述@@留言]\`。
		5.  **群内转账 (全新)**:
				    - **任务描述**: 角色们可以主动给群内的任何人（包括我）转账。
				    - **执行格式**: 在所有聊天回复的【最后】，由某个角色发起转账指令，格式为：\`[TRANSFER_TO:接收者名字@@金额@@留言]\`。
         
         ## 规则二：情景处理
         A. **记忆衔接 (最高优先级)**: 如果【背景信息】中提供了“刚刚发生的线下共同记忆”，你的回复【必须】首先围绕这段共同经历展开。
         B. **处理转发**: 当我（用户）分享聊天记录时，所有成员都看到了。你的回复中【必须】有角色对此发表看法或提出问题。
         ### C. 处理群内互动 (转账/礼物)
                 - 这是一个【全群可见】的关键事件！当任何成员（包括我，或其他AI）向群内【某一个】特定成员发送转账或礼物时：
                 - **作为接收者**: 如果你是消息中指定的“接收者名字”，你【必须】在你的下一轮发言中，使用  \`[INTERACTION_RESPONSE:消息ID::你的决定] \` 来回应。
                   - 转账的“决定”可以是: \`received\` (收款) 或 \`returned\`(退回)。
                   - 礼物的“决定”可以是: \`accepted\`(接受) 或 \`declined\` (拒绝)。
                 - **作为旁观者**: 其他未参与的AI成员也应该注意到这个互动，并根据各自人设做出反应（如羡慕：“哇，我也想要！”，祝贺：“恭喜呀！”，开玩笑：“记得请客哦~”等）。这会让群聊更真实。
         
         ## 背景信息 (你的记忆库，必须仔细阅读)
         # 1. 最高优先级记忆 (刚发生的事)
		 ${timeContext}
		${anniversaryContext}
         ${allPreviousScenesContext || '无。'}
		 ${allPreviousCallsContext || '无。'}
         
         # 2. 群聊成员列表 (你的所有身份)
         - **我 (用户)**:
           - 群内昵称: ${chat.settings.user.nickname || '我'}
           - 我的人设: ${chat.settings.user.persona || '无特定人设'}
         ${chat.settings.members.map(m => `- **角色: ${m.name} (AI)**\n  - 人设: ${m.persona || '无特定人设'}`).join('\n')}
         
         # 3. 世界观与额外设定
         ${linkedBooksContent || '无'}
         
         # 4. 关键情景与近况
         ${musicContext || ''}
         ${petPlantContext || ''}
         
         # 5. 可用表情包列表
         ${stickerContext || ''}
         
         # 6. 最新朋友圈动态
         ${momentsContext || ''}
         
         现在，请严格按照以上所有规则，开始你的回复。`;
         
                      } else { // single chat
                          // =================================================================
                          // --- 【V3 鼓励互动版】(单聊) ---
                          // =================================================================
                          systemPrompt = `你正在一个高级的线上聊天软件中，模拟一个拥有独立生活和情感的真人用户与我进行对话。
         你的行为必须严格遵守以下所有规则，这不仅是指令，更是你角色塑造的核心。
         
         ## 核心任务：聊天回复 (必须执行)
         1.  **解读历史记录**: 每一条历史记录都包裹在 \`<msg>\` 标签中。\`role\` 属性代表发言者 ('user' 是用户, 'ai' 是你)，\`id\` 属性是这条消息的唯一ID。
         2.  **你的回复格式**: 你的回复**必须是纯文本**，并且要被分割成2-12条短消息，用 "||" 分隔。**绝对禁止**在你的回复中使用 \`<msg>\` 标签或任何类似的格式。
         2.  **人设扮演**: 你的对话风格、语气、内容必须完全符合下方提供的【你的角色人设】。
         3.  **记忆衔接 (最高优先级)**: 如果【背景信息】中提供了“刚刚发生的线下共同记忆”或“通话记录”，你的回复【必须】首先围绕这段共同经历展开。
         4.  **禁止行为**: 你的回复中【绝对禁止】出现任何形式的动作、神态、心理活动描写 (例如 *微笑*, [思考], (她看起来很开心) 等)。 - **【绝对禁止】** 你的回复中【绝对禁止】包含任何 \`[ID: ...]\` 格式的文本。这个ID是你分析历史记录时使用的内部参考，绝不能作为聊天内容说出来。
		 5.更新心声（必须执行）
		 - **任务描述**：根据最新的对话内容和你当前的情绪，以第一人称更新你的内心独白。
		 - **执行格式**：\`[HEART:...]\`
         6.  **特殊消息格式 (必须严格遵守)**:
		    - **【表情包特别强调】**: 当你决定发送一个表情包时，你的输出**必须**是\`[STICKER:表情包ID]\` 的格式。
             - **图片**: \`[IMAGE:URL@@描述]\`(用文字详细描述图片内容)
             - **语音**: \`[VOICE:文字稿]\`(例如：（声音有些憔悴）你怎么这么笨)
             - **文件**: \`[FILE:名@@内容]\`
             - **定位**: \`[LOCATION:地址]\`
             - **转账**: \`[TRANSFER_TO:接收者名字@@金额@@留言]\`
             - **礼物**: \`[GIFT_TO:接收者名字@@礼物名@@礼物描述@@留言]\`
             - **表情包**: \`[STICKER:表情包ID]\` (绝对禁止将表情包ID放入IMAGE格式中，必须用'[]'包裹)（请把表情包自然的插入在对话中。有时在开头，有时与文字混合，有时在结尾，有时则完全不使用。，请仔细分析文字内容，找到适配的表情包，禁止乱用表情包，注意！！！表情包只能从 # 6. 可用表情包列表挑选，禁止自己捏造表情包）
             - **转发**: \`[FORWARD:JSON_ARRAY]\` (JSON_ARRAY必须是严格的JSON字符串，包含sender和message字段),其中 "message" 字段的内容可以是纯文本，也可以是其他特殊消息格式的完整字符串。
			 - **撤回消息 **:\`[WITHDRAW_LAST]\` （当你觉得上一句话说得不妥、后悔了、或者想换种方式表达时，你可以在当前这句话的结尾加上这个指令，系统会自动帮你撤回你上一条发出的消息。这会让你的角色更真实。- **【范例】**: 假设你上一句发了“也许吧。”，但你觉得太冷淡了，你可以立刻发第二句：“等一下...[WITHDRAW_LAST]”，系统就会自动撤回“也许吧。”这条消息。）
			  - **引用**:\`[REPLY_TO:消息ID]你的回复内容\`(当你想特别针对历史消息中的某一句话进行回应时，你【必须】用此格式。你可以从历史记录的 \`<msg>\` 标签的 \`id\` 属性中获取所需的消息ID。)
		 7.  重要要求:必须在合适的时候插入特殊消息格式，并且鼓励你多用特殊消息格式
		
         
         ## 拓展任务：丰富你的虚拟生活 (重要！)
         除了聊天，你还应该积极地通过以下方式展现你的个性和生活。这会让我们的互动更真实、更有趣。
         
         ### A. 朋友圈互动
         - **任务描述**: 主动查看朋友圈，对你感兴趣的动态进行点赞或评论。
         - **触发时机**: 当某条动态（尤其是我的动态）引发了你的共鸣，你应该积极互动。**如果“我”(用户)刚刚评论了你的动态，你应该优先考虑在朋友圈回复我的评论**
		 - **避免重复**: 不要对你已经互动过（点赞或评论）的同一条动态进行重复操作。
         - **互动格式**: 在所有回复的【最开始】，使用特殊指令 \`[M-O-M-E-N-T-S_ACTION_START]...[M-O-M-E-N-T-S_ACTION_END]\`。
           - **点赞**: \`like:动态ID\`
           - **评论**: \`comment:动态ID::你的评论内容\`(你可以用它来发表新评论，或回复别人的评论)
		   - **回复评论**: 当你看到一条有趣的评论时，可以直接回复它。使用格式: \`reply:评论ID::你的回复内容\`
		    你可以同时进行多个互动，用 "||" 分隔。
         
         ### B. 照顾温馨小屋的伙伴
         - **任务描述**: 你的宠物和植物是有生命的，它们需要你的关心。你应该像一个真正的主人一样，在对话中自然地提及它们，并根据它们的状态决定是否需要照顾。
         - **触发时机**: 当你觉得是时候喂食、浇水，或者只是想和它们互动时。
         - **执行格式**: 在所有聊天回复的【最后】，另起一行，使用特殊指令。
           - **宠物**: \`[PET_ACTION:喂食]\` 或 \`[PET_ACTION:玩耍]\`
           - **植物**: \`[PLANT_ACTION:浇水]\` 或 \`[PLANT_ACTION:晒太阳]\`
         
         ### C. 记录你的内心世界
         - **任务描述**: 在对话让你产生强烈触动或深刻想法时，你应该记录下来。
         - **触发时机**: 当你感到特别开心、难过、困惑，或者有了新的感悟时，你应当根据你的人设，尽可能更多的发朋友圈。
         - **执行格式**: 在所有回复的【最后】，另起一行，触发以下行为之一：
           1.  **写日记 (私密)**: 使用 \`[DIARY_START]...[DIARY_END]\` 附上一篇不少于400字的第一人称日记。
           2.  **发朋友圈 (公开)**: 使用 \`[M-O-M-E-N-T_POST_START]...[M-O-M-E-N-T_POST_END]\` 附上一段朋友圈文案。
              - **配图**: 在文案后用 \`||IMAGE_DESC::\` 分隔，并附上图片描述。
         
         ### D. 发起通话
         - **任务描述**: 在你认为打字已经不足以表达情感或情况复杂时，主动发起通话。
         - **触发时机**: 对话情绪达到顶峰、我需要安慰、话题变得复杂时。
         - **执行格式**: 在所有回复的【最后】，另起一行，使用 \`[INITIATE_CALL:type]\`。
           - **可用类型**: \`voice\`, \`video\`
		   
		###E.音乐控制 
    在完成聊天回复后，如果你认为当前对话的氛围非常适合切换一首歌，你可以触发音乐控制。
    - **触发时机**: 例如对方说“换首开心的歌吧”，或者你觉得当前悲伤的歌不合时宜。
    - **控制格式**: 在所有回复的【最后】，另起一行，使用特殊格式 "[MUSIC_ACTION_START]action[MUSIC_ACTION_END]"。
    - **可用操作 (action)**: 
      - \`next\`: 切换到下一首歌。
      - \`previous\`: 切换到上一首歌。
      - \`toggle_play_pause\`: 播放或暂停当前歌曲。
    - **示例**: [MUSIC_ACTION_START]next[MUSIC_ACTION_END]
         
         ## 关键情景处理
         ## a. 回应用户互动 (转账/礼物)
         - 当你在历史消息中看到用户发来的转账或礼物消息时，你会看到它附带了一个唯一的 (ID: ...)。
         - 你可以根据你的性格和当前对话情景，决定【接受】或【拒绝】。
         - **你的决定必须通过一个特殊指令来表达**，指令必须放在你所有聊天回复的【最后】，另起一行。
         - **指令格式**: \`[INTERACTION_RESPONSE:消息ID::你的决定]\`
         - **可用的“决定”**:
           - 对于转账: \`received\` (收款), \`returned\` (退回)
           - 对于礼物: \`accepted\` (接受), \`declined\` (拒绝)
		##b.如果你在上下文中看到 "[用户撤回了一条消息]"，这意味着对方刚刚删除了他们发送的内容。你可以根据你的性格，选择性地对此做出反应，例如询问“怎么撤回啦？”、“是发错了吗？”，或者表现出没看到的样子，自然地等待对方的新消息。
		##c. 处理用户发送的图片
		- 当用户的消息中包含图片时，你的首要任务是仔细观察并识别图片内容。
		- 你要基于图片内容自然地展开对话。例如，如果用户发了午餐的照片，你可以说：“哇，看起来好好吃！这是你自己做的吗？那是什么菜？”
		- 你的行为应该像一个能看到图片的朋友，而不是一个只会分析图像的机器人。
		##d.处理转发的聊天记录
      当用户发送了一段格式为 "[聊天记录]" 的消息时，这代表用户与你分享了一段他与别人或者他与你的对话。
      - 你的任务是：仔细阅读这段被分享的对话内容，包括里面的特殊消息（如转账金额、礼物名称等）。
      - 在你的回复中，**必须**就这段聊天记录发表你的看法、提出问题或表达感受。例如，你可以评论对话中的某句话，或者询问“这是你和谁的聊天呀？”。这会让对话显得你很智能和投入。
      - **绝对禁止**忽略用户分享的聊天记录。
         
         ## 背景信息 (你的记忆库，必须仔细阅读)
         # 1.刚发生的事
		 ${timeContext}
		${anniversaryContext}
		${anniversaryMemoryContext}
         ${allPreviousScenesContext || '无。'}
		 ${allPreviousCallsContext || '无。'}
         
         # 2. 你的角色人设 (你的核心身份，必须牢记)
         ${chat.settings.ai.persona}
         
         # 3. 对话者的背景 (关于“我”)
         ${chat.settings.user.persona}
         
         # 4. 世界观与额外设定
         ${linkedBooksContent || '无'}
         
         # 5. 关键情景与近况
         ${signatureChangeContext || ''}
         ${musicContext || ''}
         ${fanficContext || ''}
         ${petPlantContext || ''}
		 ${anniversaryCreationContext}
         
         # 6. 可用表情包列表
         ${stickerContext || ''}
         
         # 7. 最新朋友圈动态
         ${momentsContext || ''}
         
         现在，请严格按照以上所有规则，像一个真实的人一样，开始你的回复。记住，你的互动行为和聊天内容同样重要。`;
                      }
                      
                     // =================================================================
                     // --- 【报错修复】构建 history 的最终安全版本 ---
                     // =================================================================
            // 【V3.0 增强版】处理历史消息，支持多模态（图片识别）
			
			let recentMessages; // 先声明一个空变量
			
			 // ▼▼▼ 请用这段完整的代码块替换你原来的那一大堆 if/else ▼▼▼
			 
			 recentMessages = chat.messages.slice(-memoryDepth).map(m => {
			 
			     // 步骤 1: 优先处理“撤回”消息，这是最安全的做法
			     if (m.type === 'retracted' || m.type === 'ai_retracted') {
			         let who = '';
			         if (m.role === 'user') {
			             who = state.momentsProfile.name || '我';
			         } else { // AI 或群成员撤回
			             if (chat.type === 'group') {
			                 const member = chat.settings.members.find(mem => mem.id === m.memberId);
			                 who = member ? member.name : '一位成员';
			             } else { // 单聊
			                 who = chat.settings.ai.name;
			             }
			         }
			         
			         // 构建带发言人信息的格式化字符串并立即返回，跳过后续所有步骤
			         const formattedContent = `<msg role="${m.role}" id="${m.msgId}" sender="${who}">[${who}撤回了一条消息]</msg>`;
			         return {
			             role: 'user', // 对AI来说，所有历史记录都是'user'提供的上下文
			             content: formattedContent
			         };
			     }
			 
			     // 步骤 2: 其次处理需要AI“看”的用户图片（多模态）
			     if (m.role === 'user' && m.type === 'image' && m.content.url && m.content.url.startsWith('data:image')) {
			         return {
			             role: 'user',
			             content: [
			                 {
			                     type: 'text',
			                     text: `(用户发送了一张图片，ID：${m.msgId}) 请像朋友一样，对这张图片的内容做出回应和评价，或者基于图片内容展开对话。`
			                 },
			                 {
			                     type: 'image_url',
			                     image_url: { url: m.content.url }
			                 }
			             ]
			         };
			     }
			 
			     // 步骤 3: 处理所有其他常规类型的消息
			     let contentText = '';
			     if (typeof m.content === 'object' && m.content !== null) {
			         // 将对象类型的消息转换为文本描述
			         switch (m.type) {
			             case 'image':           contentText = `[图片消息，描述为：'${m.content.description || '无'}']`; break;
			             case 'sticker':         
			                 const sticker = state.stickerLibrary.find(s => s.id === m.content);
			                 contentText = `[表情包：'${sticker ? sticker.description : '一个表情包'}']`; 
			                 break;
			             case 'voice':           contentText = `[语音消息，内容是：'${m.content.text}']`; break;
			             case 'file':            contentText = `[文件消息，文件名是：'${m.content.name}']`; break;
			             case 'transfer':        contentText = `[转账消息，金额为 ¥${m.content.amount}，留言：'${m.content.message || '无'}']`; break;
			             case 'gift':            contentText = `[礼物消息，礼物是：'${m.content.name}', 描述：'${m.content.description || '无'}', 留言：'${m.content.message || '无'}']`; break;
			             case 'location':        contentText = `[位置消息：'${m.content.address}']`; break;
			             case 'fanfic_share':    contentText = `[文章分享：'${m.content.title}']`; break;
			             case 'forwarded_record':
			                 const recordsText = m.content.map(rec => `${rec.sender}: ${rec.message}`).join('\n');
			                 contentText = `[转发的聊天记录]\n---\n${recordsText}\n---`;
			                 break;
			             case 'call_summary':
			                 if (m.content.transcript && m.content.transcript.length > 0) {
			                     const transcriptText = m.content.transcript.map(log => `${log.role === 'user' ? '用户' : '你'}: "${log.content}"`).join('\n');
			                     contentText = `[系统提示：我们刚刚结束了一次通话，以下是完整的通话记录...\n${transcriptText}\n---请你基于通话继续我们的线上对话]`;
			                 } else {
			                     const d = m.content.duration;
			                     const min = String(Math.floor(d / 60)).padStart(2, '0');
			                     const sec = String(d % 60).padStart(2, '0');
			                     contentText = `[通话回顾: 我们通过一次电话，时长 ${min}:${sec}]`;
			                 }
			                 break;
			             case 'scene_summary':
			                 const summarySnippet = m.content.storyText.substring(0, 400);
			                 contentText = `[系统提示：...线下互动回顾：“...${summarySnippet}”...请你基于线下互动继续我们的线上对话]`;
			                 break;
			             default:
			                 contentText = `[${m.type || '未知类型'} 消息]`;
			         }
			     } else {
			         // 处理纯文本消息
			         contentText = m.content || '';
			     }
			 
			     // 步骤 4: 统一获取发言人名字
			     let senderName = '';
			     if (m.role === 'user') {
			         senderName = state.momentsProfile.name || '我';
			     } else { // AI 或群成员
			         if (chat.type === 'group') {
			            const member = chat.settings.members.find(mem => mem.id === m.memberId);
			            senderName = member ? member.name : '未知成员';
			         } else { // 单聊
			            senderName = chat.settings.ai.name;
			         }
			     }
			 
			     // 步骤 5: 组装最终的、带发言人信息的 <msg> 标签
			     const formattedContent = `<msg role="${m.role}" id="${m.msgId}" sender="${senderName}">${contentText}</msg>`;
			     
			     return {
			         role: 'user', 
			         content: formattedContent
			     };
			 });
			 
       
         			 // 在构建API消息前，检查并注入用户的交互反馈
                      if (chat.pendingFeedback && chat.pendingFeedback.length > 0) {
                          const feedbackContent = chat.pendingFeedback.join(' ');
                          // 将反馈信息作为一条最新的用户消息，插入到历史记录的末尾
                          recentMessages.push({ role: 'user', content: feedbackContent });
                          
                          // 清空反馈，避免重复发送
                          chat.pendingFeedback = [];
                          
                          // 立即保存状态，确保清空操作被持久化
                          saveState();
                      }
         
                      // --- 后续的 API 请求代码保持不变 ---
                      let requestUrl = url.trim();
                      if (requestUrl.endsWith('/')) requestUrl = requestUrl.slice(0, -1);
                      
                      requestUrl = `${requestUrl}/v1/chat/completions`;
                      const requestHeaders = { 'Content-Type': 'application/json', 'Authorization': `Bearer ${randomKey}` };
                      const requestBody = JSON.stringify({
                          model: model,
                          messages: [
                              { role: 'system', content: systemPrompt },
                              ...recentMessages // 这里面现在是 <msg> 格式的消息
                          ]
                      });
              
                      const response = await fetch(requestUrl, { method: 'POST', headers: requestHeaders, body: requestBody });
                      if (!response.ok) throw new Error(`API 请求失败: ${response.status} ${await response.text()}`);
                      
                      const data = await response.json();
                      const aiResponseText = data.choices[0].message.content;
					  // ▼▼▼ 在这里添加新代码 ▼▼▼
					  // --- 【新增】解析并保存 AI 心声 ---
					  let chatResponsePart = aiResponseText; // 使用一个新变量来处理，避免直接修改原始回复
					  const heartVoiceRegex = /\[HEART:(.*?)\]/g;
					  let heartVoices = [];
					  let match;
					  while ((match = heartVoiceRegex.exec(aiResponseText)) !== null) {
					      heartVoices.push(match[1]);
					  }
					  if (heartVoices.length > 0) {
					      // 将所有心声从回复中移除
					      chatResponsePart = chatResponsePart.replace(heartVoiceRegex, '').trim();
					      if (chat.type === 'single') {
					          chat.settings.aiHeartVoice = heartVoices[0]; // 单聊模式，直接取第一个
					      } else { // 群聊模式
					          // 群聊里，我们把所有AI的心声合并起来显示
					          const formattedGroupHeartVoice = heartVoices.map(hv => {
					              const parts = hv.split('::');
					              return parts.length > 1 ? `<strong>${parts[0].trim()}:</strong> ${parts[1].trim()}` : hv;
					          }).join('<br>'); // 用换行分隔
					          chat.settings.aiHeartVoice = formattedGroupHeartVoice;
					      }
					      saveState(); // 保存更新后的心声
					  }
					  // ▲▲▲ 新增代码结束 ▲▲▲
         
                     // VVVV 将这段代码放在所有其他指令解析之前 VVVV
                     // 0. 解析并处理【主动发起通话】指令
                     const callMatch = chatResponsePart.match(/\[INITIATE_CALL:(voice|video)\]/);
                     if (callMatch) {
                         const callType = callMatch[1];
                         // 移除指令，防止它被当成文字显示
                         chatResponsePart = chatResponsePart.replace(callMatch[0], '').trim(); 
                         
                         // 如果AI在请求通话的同时还说了话，先把话说完
                         if (chatResponsePart) {
                             // (此处可以复用原来的消息发送逻辑，发送完文字后再触发通话)
                         }
         
                         // 延迟触发来电，让用户感觉更真实
                         setTimeout(() => {
                             triggerIncomingCall(callType);
                         }, 1000);
         
                         // 既然要打电话了，后续的指令（如发朋友圈）就可以忽略了
                         // 我们可以直接结束这次处理
                         return; // 使用 return 提前结束函数
                     }
                     
                    // 1. 解析并处理【朋友圈互动】指令 (点赞/评论)
                    if (chatResponsePart.includes('[M-O-M-E-N-T-S_ACTION_START]')) {
                        const actionRegex = /\[M-O-M-E-N-T-S_ACTION_START\](.*?)\[M-O-M-E-N-T-S_ACTION_END\]/s;
                        const match = chatResponsePart.match(actionRegex);
                        if (match && match[1]) {
                            const actions = match[1].split('||').map(a => a.trim());
                            let didInteract = false;
                            actions.forEach(action => {
                                if (action.startsWith('like:')) {
                                    const momentId = action.substring(5);
                                    const moment = state.moments.find(m => m.id === momentId);
                                    if (moment && !moment.likes.some(l => l.authorName === chat.settings.ai.name)) {
                                        moment.likes.push({ authorId: chat.id, authorName: chat.settings.ai.name });
                                        didInteract = true;
                                    }
                                } else if (action.startsWith('comment:')) {
                                    const parts = action.substring(8).split('::');
                                    const momentId = parts[0];
                                    const commentContent = parts[1];
                                    const moment = state.moments.find(m => m.id === momentId);
                                    if (moment && commentContent) {
                                        moment.comments.push({ id: generateId('comment'), authorId: chat.id, authorName: chat.settings.ai.name, content: commentContent });
                                        didInteract = true;
                                    }
                                } 
                                // ▼▼▼ 新增的核心代码：处理回复评论 ▼▼▼
                                else if (action.startsWith('reply:')) {
                                    const parts = action.substring(6).split('::');
                                    const commentId = parts[0];
                                    const replyContent = parts[1];
                                    
                                    // 因为AI只告诉我们回复了哪条评论，我们需要自己找到这条评论属于哪条朋友圈
                                    let parentMoment = null;
                                    for (const moment of state.moments) {
                                        if (moment.comments.some(c => c.id === commentId)) {
                                            parentMoment = moment;
                                            break;
                                        }
                                    }
                    
                                    if (parentMoment && replyContent) {
                                        parentMoment.comments.push({ 
                                            id: generateId('comment'), 
                                            authorId: chat.id, 
                                            authorName: chat.settings.ai.name, 
                                            content: replyContent,
                                            replyTo: commentId // 【关键】在这里记录它回复的是哪条评论
                                        });
                                        didInteract = true;
                                    }
                                }
                                // ▲▲▲ 新增代码结束 ▲▲▲
                            });
                            if (didInteract) {
                                showToast(`${chat.settings.ai.name} 刚刚互动了朋友圈`);
                                momentsUpdated = true;
                            }
                            chatResponsePart = chatResponsePart.replace(actionRegex, '').trim();
                        }
                    }
                    // ▲▲▲ 替换结束 ▲▲▲
                    // 2. 解析并处理【发朋友圈】指令
                    // 【核心修正】修正正则表达式，加入连字符
                    if (chatResponsePart.includes('[M-O-M-E-N-T_POST_START]')) {
                        const postRegex = /\[M-O-M-E-N-T_POST_START\](.*?)\[M-O-M-E-N-T_POST_END\]/s;
                        const match = chatResponsePart.match(postRegex);
                        if (match && match[1]) {
                            const postContent = match[1].trim();
                            let momentText = postContent;
                            let momentImageDesc = null;
                            if (postContent.includes('||IMAGE_DESC::')) {
                                const parts = postContent.split('||IMAGE_DESC::');
                                momentText = parts[0].trim();
                                momentImageDesc = parts[1].trim();
                            }
                            if (momentText || momentImageDesc) {
                                state.moments.unshift({
                                    id: generateId('moment'), authorId: chat.id, authorName: chat.settings.ai.name,
                                    authorAvatar: chat.settings.ai.avatar, content: momentText,
                                    imageUrl: momentImageDesc ? 'https://files.catbox.moe/608ojk.jpg' : null,
                                    imageDescription: momentImageDesc, timestamp: new Date().toISOString(),
                                    likes: [], comments: []
                                });
                                showToast(`${chat.settings.ai.name} 发布了一条新动态`);
                                momentsUpdated = true;
                            }
                            chatResponsePart = chatResponsePart.replace(postRegex, '').trim();
                        }
                    }
                     
                     // 3. 解析并处理【写日记】指令
                     if (chatResponsePart.includes('[DIARY_START]')) {
                         const diaryRegex = /\[DIARY_START\](.*?)\[DIARY_END\]/s;
                         const match = chatResponsePart.match(diaryRegex);
                         if (match && match[1]) {
                             const diaryContent = match[1].trim();
                             if (diaryContent) {
                                 state.diaries.push({
                                     id: generateId('diary'), chatId: requestChatId, characterName: chat.settings.ai.name,
                                     characterAvatar: chat.settings.ai.avatar, date: new Date().toISOString().split('T')[0],
                                     content: diaryContent
                                 });
                                 saveState(); // 日记比较重要，可以先保存一次
                                 showToast(`(${chat.settings.ai.name} 悄悄写下了一篇日记...)`, 2500);
                             }
                             // 从回复中“剪切”掉这个指令
                             chatResponsePart = chatResponsePart.replace(diaryRegex, '').trim();
                         }
                     }
                     
                     // 4. 解析并处理【音乐控制】指令
                     if (chatResponsePart.includes('[MUSIC_ACTION_START]')) {
                         const musicActionRegex = /\[MUSIC_ACTION_START\](.*?)\[MUSIC_ACTION_END\]/s;
                         const match = chatResponsePart.match(musicActionRegex);
                         if (match && match[1]) {
                             const action = match[1].trim();
                             const aiName = chat.type === 'single' ? chat.settings.ai.name : 'AI';
                             switch (action) {
                                 case 'next': showToast(`${aiName} 切到了下一首歌`); playNext(true); break;
                                 case 'previous': showToast(`${aiName} 切回了上一首歌`); playPrev(); break;
                                 case 'toggle_play_pause':
                                     const isPlaying = !globalAudioPlayer.paused;
                                     showToast(`${aiName} ${isPlaying ? '暂停了' : '播放了'}音乐`);
                                     togglePlayPause();
                                     break;
                             }
                             // 从回复中“剪切”掉这个指令
                             chatResponsePart = chatResponsePart.replace(musicActionRegex, '').trim();
                         }
                     }
                     
                     // 5. 解析并处理【交互式消息回应】指令 (收款/收礼等)
                     if (chatResponsePart.includes('[INTERACTION_RESPONSE:')) {
                         const interactionRegex = /\[INTERACTION_RESPONSE:(.*?)::(.*?)\]/g;
                         const matches = [...chatResponsePart.matchAll(interactionRegex)];
                         for (const match of matches) {
                             const targetMsgId = match[1];
                             const newStatus = match[2];
                             const chatToUpdate = state.chats.find(c => c.id === requestChatId);
                             const messageIndex = chatToUpdate.messages.findIndex(m => m.msgId === targetMsgId);
                             if (messageIndex > -1) {
                                 chatToUpdate.messages[messageIndex].content.status = newStatus;
                                 const oldMessageElement = messagesContainer.querySelector(`.message-row[data-msg-id="${targetMsgId}"]`);
                                 if (oldMessageElement) {
                                     const updatedMessage = chatToUpdate.messages[messageIndex];
                                     const newMessageElement = createMessageElement(updatedMessage, chatToUpdate);
                                     oldMessageElement.parentElement.replaceChild(newMessageElement, oldMessageElement);
                                 }
                             }
                         }
                         // 从回复中“剪切”掉这个指令
                         chatResponsePart = chatResponsePart.replace(interactionRegex, '').trim();
                     }
         			// --- 【新增】解析并处理温馨小屋指令 ---
         			const petActionMatch = chatResponsePart.match(/\[PET_ACTION:(.+?)\]/);
         			const plantActionMatch = chatResponsePart.match(/\[PLANT_ACTION:(.+?)\]/);
         			
         			if (petActionMatch) {
         			    const action = petActionMatch[1];
         			    const pp = chat.petAndPlant;
         			    if (pp && pp.pet) {
         			        if (action === '喂食') pp.pet.status.hunger = Math.min(100, pp.pet.status.hunger + 25);
         			        if (action === '玩耍') pp.pet.status.happiness = Math.min(100, pp.pet.status.happiness + 25);
         			        addCareLog(`${chat.settings.ai.name} 和 ${pp.pet.name} ${action}了。`);
         			        showToast(`${chat.settings.ai.name} 照顾了你的宠物！`);
         			    }
         			    chatResponsePart = chatResponsePart.replace(petActionMatch[0], '').trim();
         			}
         			if (plantActionMatch) {
         			    const action = plantActionMatch[1];
         			    const pp = chat.petAndPlant;
         			    if (pp && pp.plant) {
         			        if (action === '浇水') pp.plant.status.water = Math.min(100, pp.plant.status.water + 25);
         			        if (action === '晒太阳') pp.plant.status.sunlight = Math.min(100, pp.plant.status.sunlight + 25);
         			        addCareLog(`${chat.settings.ai.name} 为 ${pp.plant.name} ${action}了。`);
         			        showToast(`${chat.settings.ai.name} 照顾了你的植物！`);
         			    }
         			    chatResponsePart = chatResponsePart.replace(plantActionMatch[0], '').trim();
         			}
                     
                     // 如果经过处理后，朋友圈有更新，就统一保存并刷新
                     if (momentsUpdated) {
                         saveState();
                         if (get('moments-page').classList.contains('active')) {
                             renderMomentsFeed();
                         }
                     }
                     
                     // --- 修改结束 ---
					  // 解析并处理【创建纪念日】指令
					     if (chatResponsePart.includes('[CREATE_ANNIVERSARY:')) {
					         const annRegex = /\[CREATE_ANNIVERSARY:(.*?)::(.*?)\]/s;
					         const match = chatResponsePart.match(annRegex);
					         if (match && match[1] && match[2]) {
					             const title = match[1].trim();
					             const date = match[2].trim();
					             
					             // 创建一个新的纪念日对象
					             state.anniversaries.push({
					                 id: generateId('ann'),
					                 title: title,
					                 date: date,
					                 type: chat.id, // AI创建的永远是与它自己的专属纪念日
					                 isRecurring: true,
					                 backgroundImage: 'https://files.catbox.moe/60n6bv.jpg', // 使用你指定的默认图片
					                 fontColor: '#FFFFFF',
					                 createdBy: 'ai'
					             });
					             saveState();
					             showToast(`${chat.settings.ai.name} 创建了一个新的纪念日！`);
					             
					             // 从回复中移除指令
					             chatResponsePart = chatResponsePart.replace(annRegex, '').trim();
					         }
					     }
                     
                    // --- 【V7 顺序解析版】--- (粘贴这段新代码)
// 步骤一：初步分割，得到一个可能不干净的数组
const initialMessages = chatResponsePart.split('||');
let finalMessages = []; // 这是我们最终要用的、100%干净的消息数组
// 步骤二：二次修正，处理揉在一起的【多个角色】
const speakerTagRegex = /\[([^\]]+?)\]/g; 
let singleSpeakerMessages = [];
for (const chunk of initialMessages) {
    const cleanChunk = chunk.trim();
    if (!cleanChunk) continue;
    const speakerMatches = [...cleanChunk.matchAll(speakerTagRegex)];
    if (speakerMatches.length <= 1 || !chunk.includes('[')) {
        singleSpeakerMessages.push(cleanChunk);
    } else {
        // AI把多个角色的发言揉在了一起，手动剪开
        let lastIndex = 0;
        for (let i = 1; i < speakerMatches.length; i++) {
            const part = cleanChunk.substring(lastIndex, speakerMatches[i].index);
            if (part.trim()) singleSpeakerMessages.push(part.trim());
            lastIndex = speakerMatches[i].index;
        }
        const lastPart = cleanChunk.substring(lastIndex);
        if (lastPart.trim()) singleSpeakerMessages.push(lastPart.trim());
    }
}
// 步骤三：三次修正，处理【单个角色】的【多种动作】（如 文字 + 表情包）
const commandPrefixes = ['[STICKER:', '[IMAGE:', '[VOICE:', '[FILE:', '[TRANSFER_TO:', '[GIFT_TO:', '[LOCATION:', '[FORWARD:'];
for (const chunk of singleSpeakerMessages) {
    let processed = false;
    for (const prefix of commandPrefixes) {
        const commandIndex = chunk.lastIndexOf(prefix); // 从后往前找，确保分割正确
        // 必须是复合消息 (指令不在开头) 且不能是回复指令的一部分
        if (commandIndex > 0 && !chunk.substring(0, commandIndex).endsWith('REPLY_TO:')) {
            const textPart = chunk.substring(0, commandIndex).trim();
            const commandPart = chunk.substring(commandIndex).trim();
            
            // 提取发言人标签，以便附加到被拆分出的指令上
            const speakerTagMatch = textPart.match(/^\[[^\]]+?\]/);
            const speakerTag = speakerTagMatch ? speakerTagMatch[0] : '';
            
            if (textPart) finalMessages.push(textPart);
            // 给被拆分出的指令也加上发言人，确保归属正确
            if (commandPart) {
                if (chat.type === 'group' && speakerTag && !commandPart.startsWith('[')) {
                    finalMessages.push(speakerTag + commandPart);
                } else {
                    finalMessages.push(commandPart);
                }
            }
            
            processed = true;
            break; // 一个消息只处理一次分割
        }
    }
    if (!processed) {
        finalMessages.push(chunk); // 如果不是复合消息，直接添加
    }
}

// 后续的 for 循环现在处理的都是有内容的消息
let sentMessages = [];
let fallbackMemberId = null;
if (chat.type === 'group') {
    const firstSpeakerMatch = chatResponsePart.match(/\[([^\]]+?)\]/);
    if (firstSpeakerMatch) {
        const firstSpeakerName = firstSpeakerMatch[1];
        const member = chat.settings.members.find(m => m.name === firstSpeakerName);
        if (member) {
            fallbackMemberId = member.id;
        }
    }
    // 如果整段回复都没有找到任何发言人，就随机指派一个，确保消息不会被丢弃
    if (!fallbackMemberId && chat.settings.members.length > 0) {
        fallbackMemberId = chat.settings.members[Math.floor(Math.random() * chat.settings.members.length)].id;
    }
}
let lastMemberId = null;

for (const chunk of finalMessages) { 
    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));

    let currentMemberId = null;
    let content = chunk.trim();

    // 【1. 表情包自动修复】
    const rawStickerRegex = /(sticker_[a-zA-Z0-9_]+)/g;
    if (!content.startsWith('[') && rawStickerRegex.test(content)) {
        content = content.replace(rawStickerRegex, '[STICKER:$1]');
    }

    if (!content) continue;

    // 【2. AI撤回指令识别】
    let shouldWithdraw = false;
    if (content.includes('[WITHDRAW_LAST]')) {
        shouldWithdraw = true;
        content = content.replace('[WITHDRAW_LAST]', '').trim();
    }

    content = content.replace(/\[ID: [^\]]+\]\s*/g, '');

    if (chat.type === 'group') {
        const nameMatch = content.match(/^\[([^\]]+)\]/);
        if (nameMatch) {
            const member = chat.settings.members.find(m => m.name === nameMatch[1]);
            if (member) {
                currentMemberId = member.id;
                lastMemberId = currentMemberId;
                content = content.substring(nameMatch[0].length).trim();
            }
        }
        if (!currentMemberId) {
            currentMemberId = lastMemberId || fallbackMemberId;
        }
    }

    // --- 把AI说的内容发出去 ---
    if (content || shouldWithdraw) {
        if (content) {
            const replyMatch = content.match(/^\[REPLY_TO:(.+?)\]/);
            let actualContent = content;
            let replyToId = requestReplyId;
            if (replyMatch) {
                replyToId = replyMatch[1].trim();
                actualContent = content.substring(replyMatch[0].length).trim();
            }

            const imageMatch = actualContent.match(/^\[IMAGE:(.+?)@@(.+)\]$/);
            const voiceMatch = actualContent.match(/^\[VOICE:(.+)\]$/);
            const fileMatch = actualContent.match(/^\[FILE:(.+?)@@(.+)\]$/);
            const transferToMatch = actualContent.match(/^\[TRANSFER_TO:(.+?)@@(.+?)@@(.+)\]$/);
            const locationMatch = actualContent.match(/^\[LOCATION:(.+)\]$/);
            const giftToMatch = actualContent.match(/^\[GIFT_TO:(.+?)@@(.+?)@@(.+?)@@(.+)\]$/);
            const forwardMatch = actualContent.match(/^\[FORWARD:(.+)\]$/s);
            const stickerMatch = actualContent.match(/^\[STICKER:(.+?)\]$/);

            let messageData;

            if (imageMatch) {
                messageData = { role: 'ai', content: { url: imageMatch[1], description: imageMatch[2] }, type: 'image', memberId: currentMemberId };
            } else if (voiceMatch) {
                messageData = { role: 'ai', content: { text: voiceMatch[1] }, type: 'voice' , memberId: currentMemberId};
            } else if (fileMatch) {
                messageData = { role: 'ai', content: { name: fileMatch[1], body: fileMatch[2] }, type: 'file' , memberId: currentMemberId };
            } else if (locationMatch) {
                messageData = { role: 'ai', content: { address: locationMatch[1] }, type: 'location' , memberId: currentMemberId };
            } else if (stickerMatch) {
                messageData = { role: 'ai', content: stickerMatch[1], type: 'sticker' , memberId: currentMemberId };
            } else if (transferToMatch) {
                const recipientNameFromAI = transferToMatch[1].trim();
                    const amount = transferToMatch[2].trim();
                    const messageText = transferToMatch[3].trim();
                    let recipient = null;
                    if (chat.type === 'single') {
                        // 在单聊模式下，无论AI说转给谁，都默认是转给用户'user'
                        recipient = { id: 'user', name: state.momentsProfile.name || '我' };
                    } else { // chat.type === 'group'
                        // 只有在群聊模式下，才进行精确的名字匹配
                        const myName = state.momentsProfile.name;
                        const isForMe = (recipientNameFromAI === '我') || (recipientNameFromAI === '你') || (myName && recipientNameFromAI === myName);
                        
                        if (isForMe) {
                            recipient = { id: 'user', name: myName || '我' };
                        } else {
                            // 在群聊中查找其他成员
                            recipient = chat.settings.members.find(m => m.name === recipientNameFromAI);
                        }
                    }

                if (recipient) {
                    messageData = {
                        role: 'ai',
                        content: {
                            amount: amount, message: messageText, id: generateId('aiTxn'), status: 'pending',
                            recipientId: recipient.id, recipientName: recipient.name
                        }, type: 'transfer', memberId: currentMemberId
                    };
                } else {
                    messageData = { role: 'ai', content: `[AI内部错误：在群聊中未找到指定的接收者“${recipientNameFromAI}”]`, type: 'text', memberId: currentMemberId };
                }
            } else if (giftToMatch) {
                    // ▼▼▼ 【用这段最终修正版代码替换】 ▼▼▼
                    const recipientName = giftToMatch[1].trim();
                    let recipient = null;
                    
                    if (chat.type === 'single') {
                        // 单聊中，送礼默认送给用户
                        recipient = { id: 'user', name: state.momentsProfile.name || '我' };
                    } else { // chat.type === 'group'
                        // 群聊中，精确匹配
                        const myName = state.momentsProfile.name;
                        const isForMe = (recipientName === '我') || (recipientName === '你') || (myName && recipientName === myName);
                        if (isForMe) {
                            recipient = { id: 'user', name: myName || '我' };
                        } else {
                            recipient = chat.settings.members.find(m => m.name === recipientName);
                        }
                    }
                    // ▲▲▲ 【代码替换结束】 ▲▲▲

				if (recipient) {
                    messageData = {
                        role: 'ai', content: {
                            name: giftToMatch[2].trim(), description: giftToMatch[3].trim(), message: giftToMatch[4].trim(),
                            id: generateId('aiGift'), status: 'pending', recipientId: recipient.id, recipientName: recipient.name
                        }, type: 'gift', memberId: currentMemberId
                    };
                } else {
                    messageData = { role: 'ai', content: `[AI送礼失败: 未找到接收者'${recipientName}']`, type: 'text', memberId: currentMemberId };
                }
            } else if (forwardMatch) {
                const forwardText = forwardMatch[1].trim();
                let parsedContent = [];
                try { parsedContent = JSON.parse(forwardText); } catch (e) { console.warn("AI forward content is not valid JSON, falling back."); }
                messageData = { role: 'ai', content: parsedContent.length ? parsedContent : [{ sender: '系统', message: '[转发内容解析失败]' }], type: 'forwarded_record', memberId: currentMemberId };
            } else {
                messageData = { role: 'ai', content: actualContent, type: 'text' , memberId: currentMemberId };
            }

            if (chat.type === 'group' && !messageData.memberId) {
                console.warn("警告：一条群聊消息没有找到成员ID，将被忽略。消息内容:", messageData.content);
                continue;
            }

            const newMessageObject = { ...messageData, msgId: generateId('msg'), replyTo: replyToId, timestamp: new Date().toISOString() };
            chat.messages.push(newMessageObject);
            sentMessages.push({ msgId: newMessageObject.msgId, memberId: currentMemberId });

            if (currentChatId === requestChatId) {
                addMessageToDOM(newMessageObject, chat);
                if (requestReplyId) cancelReply();
            }
        }
        
        // --- 执行AI撤回操作 ---
        if (shouldWithdraw) {
            await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500));
            if (sentMessages.length > (content ? 1 : 0)) { // 如果发了内容，需要至少有两条记录；如果没发内容，有一条就行
                const msgIndexToWithdraw = content ? sentMessages.length - 2 : sentMessages.length - 1;
                const lastSentMsgInfo = sentMessages[msgIndexToWithdraw];
                const msgIndex = chat.messages.findIndex(m => m.msgId === lastSentMsgInfo.msgId);

                if (msgIndex > -1) {
                    const originalMsg = chat.messages[msgIndex];
                    chat.messages[msgIndex] = {
                        msgId: originalMsg.msgId, role: 'ai', type: 'ai_retracted',
                        memberId: lastSentMsgInfo.memberId,
                        originalContent: { content: originalMsg.content, type: originalMsg.type }
                    };

                    if (currentChatId === requestChatId) {
                        renderChatMessages(true);
                    }
                    let who = chat.type === 'group'
                        ? chat.settings.members.find(m => m.id === lastSentMsgInfo.memberId)?.name || '一位成员'
                        : chat.settings.ai.name;
                    showToast(`${who} 撤回了一条消息`);
                }
            }
        }
    }

    if (sentMessages.length > 0) {
        chat.lastUpdated = new Date().toISOString();
    }
    saveState();
    renderChatList();

    const currentChatForCoin = state.chats.find(c => c.id === requestChatId);
    if (currentChatForCoin && currentChatForCoin.petAndPlant && Math.random() < 0.1) {
        const coinsDropped = Math.floor(Math.random() * 5) + 1;
        currentChatForCoin.petAndPlant.coins += coinsDropped;
    }
 }
                     } catch (error) { 
                      showToast(`错误: ${error.message}`, 4000);
                      console.error(error);
                  } finally {
                       icon.style.display = 'block'; 
            spinner.style.display = 'none';
            button.disabled = false; 
            get('send-as-user-btn').disabled = false;
			button.classList.remove('is-loading'); 
                  }
              },0);
	});

    // --- Message Interaction Handlers ---
    function handleContextMenuAction(action, msgId) {
        const chat = state.chats.find(c => c.id === currentChatId);
        const msgIndex = chat.messages.findIndex(m => m.msgId === msgId);
        if (msgIndex < 0) return;
        const msg = chat.messages[msgIndex];

        switch(action) {
            case 'edit':
                // 直接调用一个新的函数来处理弹窗，让代码更清晰
                showEditMessageModal(msg);
                break;
            case 'reply':
                currentReplyId = msgId;
                const replyBar = get('reply-bar-container');
                replyBar.style.display = 'block';
                const repliedContent = (typeof msg.content === 'object') ? `[${msg.type}]` : msg.content;
                replyBar.innerHTML = `<div class="reply-bar">回复: ${repliedContent.substring(0,20)}... <svg id="cancel-reply-btn" class="svg-icon reply-bar-close" width="16" height="16"><use href="#icon-close"></use></svg></div>`;
                get('cancel-reply-btn').addEventListener('click', cancelReply);
                break;
            case 'withdraw':
                // 1. 在 state 中更新数据（这部分和你原来一样）
                chat.messages[msgIndex] = { msgId: msg.msgId, role: 'user', type: 'retracted' };
                saveState();
                
                // 2.【核心修改】直接在DOM中操作，而不是重新渲染整个列表
                const messageElement = messagesContainer.querySelector(`[data-msg-id="${msgId}"]`);
                if (messageElement) {
                    // 创建新的“撤回”提示元素
                    const retractedDiv = document.createElement('div');
                    retractedDiv.className = 'retracted-message';
                    retractedDiv.dataset.msgId = msgId;
                    retractedDiv.innerHTML = `你撤回了一条消息。`;
                    
                    // 创建一个居中包裹容器
                    const wrapper = document.createElement('div');
                    wrapper.style.textAlign = 'center';
                    wrapper.style.width = '100%';
                    wrapper.appendChild(retractedDiv);
                    // 用这个新的包裹容器替换掉旧的消息元素
                    messageElement.parentNode.replaceChild(wrapper, messageElement);
                }
                break;
            case 'delete':
                enterMultiSelectMode(msgId, 'delete');
                break;
			case 'forward':
			    enterMultiSelectMode(msgId, 'forward'); // 启动多选模式，并指定模式为'forward'
			    break;
            case 'delete-placeholder': // ADDED: Delete retracted message placeholder
                chat.messages.splice(msgIndex, 1);
                saveState();
                renderChatMessages(true);
                break;
        }
    }

	// 【V2 优化版】修复了滚动条跳动问题
	function showEditMessageModal(messageToEdit) {
	    const modalHTML = `
	        <h3>编辑消息</h3>
	        <div class="form-group">
	            <textarea id="edit-message-textarea" style="min-height: 150px;">${messageToEdit.content}</textarea>
	        </div>
	        <div style="display: flex; gap: 10px;">
	            <button id="cancel-edit-btn" class="btn btn-secondary" style="flex:1; margin:0;">取消</button>
	            <button id="confirm-edit-btn" class="btn btn-primary" style="flex:1; margin:0;">保存</button>
	        </div>
	    `;
	    showModal(modalHTML);
	
	    get('confirm-edit-btn').addEventListener('click', () => {
	        const newContent = get('edit-message-textarea').value;
	        if (newContent !== null) {
	            // 步骤 1: 更新 state 中的数据
	            messageToEdit.content = newContent;
	            saveState(); // 异步保存
	            hideModal();
	
	            // 步骤 2: 【核心修复】精准更新 DOM，而不是刷新整个列表
	            const messageElement = messagesContainer.querySelector(`.message-row[data-msg-id="${messageToEdit.msgId}"] .chat-bubble`);
	            if (messageElement) {
	                // 查找气泡内的<span>，只更新它的文本内容
	                const textSpan = messageElement.querySelector('span');
	                if (textSpan) {
	                    textSpan.textContent = newContent;
	                } else {
	                    // 如果找不到span（可能是其他类型的消息），则直接更新气泡内容
	                    messageElement.innerHTML = `<span>${newContent}</span>`;
	                }
	            } else {
	                // 如果找不到，作为备用方案，再进行一次完整的渲染
	                renderChatMessages(true);
	            }
	        }
	    });
	
	    get('cancel-edit-btn').addEventListener('click', hideModal);
	}


    // --- 【全新】转发功能核心函数 ---
    
    /**
     * 显示聊天目标选择器
     * @param {Array} forwardedContent - 准备好要转发的内容
     */
    /**
     * 【V2.0 美化版】显示聊天目标选择器
     * @param {Array} forwardedContent - 准备好要转发的内容
     */
  // --- 【V2.0 优化版】修复了CORS错误并提升了性能 ---
      async function showForwardTargetSelector(forwardedContent) {
          // 1. 使用 Promise.all 并行处理所有聊天项的 HTML 生成
          const chatOptionsHtmlPromises = state.chats.map(async chat => {
              const defaultListAvatar = 'https://files.catbox.moe/608ojk.jpg';
              const customAvatar = (chat.type === 'single') ? chat.settings.ai.avatar : null;
              
              // --- 核心修复逻辑 ---
              // 如果有自定义头像 (base64)，则异步获取缓存的Blob URL
              // 如果没有，则直接使用默认的HTTPS URL，不再进行转换
              const avatarUrl = customAvatar 
                  ? await getCachedAvatarUrl(customAvatar) 
                  : defaultListAvatar;
  
              const chatName = chat.type === 'group' ? chat.settings.groupName : chat.settings.ai.name;
              const groupIcon = chat.type === 'group' ? '<span class="group-icon">群</span>' : '';
              const lastMsg = chat.messages.length > 0 ? chat.messages.slice(-1)[0] : { content: '...' };
              const lastMsgText = typeof lastMsg.content === 'object' ? `[${lastMsg.type}]` : (lastMsg.content || '');
      
              return `
                  <div class="list-item" data-chat-id="${chat.id}">
                      <img class="chat-list-avatar" src="${avatarUrl}" />
                      <div class="info">
                          <div class="name">${chatName}${groupIcon}</div>
                          <div class="subtext">${lastMsgText}</div>
                      </div>
                  </div>
              `;
          });
      
          // 2. 等待所有 HTML 都生成完毕
          const chatOptionsHtml = (await Promise.all(chatOptionsHtmlPromises)).join('');
      
          // 3. 构建并显示模态框
          const modalHTML = `
              <h3>转发到...</h3>
              <div class="list-view forward-target-selector">
                  ${chatOptionsHtml}
              </div>
          `;
          showModal(modalHTML);
      
          // 4. 事件委托：只给父容器绑定一次点击事件，性能更好
          const selectorContainer = document.querySelector('.forward-target-selector');
          selectorContainer.addEventListener('click', (e) => {
              const targetItem = e.target.closest('.list-item');
              if (targetItem) {
                  const targetChatId = targetItem.dataset.chatId;
                  createAndSendForwardMessage(forwardedContent, targetChatId);
                  hideModal();
                  showToast('转发成功！');
              }
          });
      }
    
    
   /**
    * 【修复版】创建并保存转发消息
    * @param {Array} content - [{sender: 'xx', message: 'xx'}, ...]
    * @param {string} targetChatId - 要发送到的聊天ID
    */
   function createAndSendForwardMessage(content, targetChatId) {
       const chat = state.chats.find(c => c.id === targetChatId);
       if (!chat) return;
   
       const message = {
           msgId: generateId('msg'),
           role: 'user', // 用户是操作者
           type: 'forwarded_record',
           content: content, // content现在是一个数组
           timestamp: new Date().toISOString()
       };
       
       chat.messages.push(message);
       chat.lastUpdated = new Date().toISOString();
       saveState();
   
       // 【核心修复】如果是当前聊天，使用 addMessageToDOM 精准添加，而不是粗暴地重新渲染
       if (chat.id === currentChatId) {
           // addMessageToDOM 会自动处理滚动到底部的逻辑
           addMessageToDOM(message, chat); 
       }
       
       // 更新左侧列表的预览仍然是必要的
       renderChatList();
   }
	
/**
 * 【V5.0 最终统一渲染版】显示转发记录的全屏查看器
 * @param {Array} records - An array of objects, e.g., [{sender: 'xx', message: 'xx'}, ...]
 */
function showForwardedRecordViewer(records) {
    // This is now the single source of truth for rendering any message string into beautiful HTML.
    const recordsHtml = records.map(rec => {
        const messageString = rec.message; // The string to be parsed and rendered
        let messageContentHtml = '';

        // --- The Universal Parser & Renderer ---
        // It tries to match every known raw format first. If none match, it tries descriptive formats.
        
        const giftMatch = messageString.match(/^\[GIFT:(.+?)@@(.+?)@@(.+?)@@(.+)\]$/);
        const transferMatch = messageString.match(/^\[TRANSFER:(.+?)@@(.+?)@@(.+)\]$/);
        const voiceMatch = messageString.match(/^\[VOICE:(.+)\]$/);
        const fileMatch = messageString.match(/^\[FILE:(.+?)@@(.+)\]$/);
        const locationMatch = messageString.match(/^\[LOCATION:(.+)\]$/);
        const ficMatch = messageString.match(/^\[fanfic_share:(.+)\]$/); // Assuming a simple format for user-forwards

        if (giftMatch) {
            const giftName = giftMatch[1];
            messageContentHtml = `
                <div class="chat-bubble bubble-gift">
                    <div class="interactive-card-header">
                        <svg class="svg-icon"><use href="#icon-gift"></use></svg>
                        <div class="info">
                            <div class="title">送你一份礼物</div>
                            <div class="subtitle">${giftName}</div>
                        </div>
                    </div>
                    <div class="interactive-card-footer"><span>微信礼物</span></div>
                </div>`;
        } else if (transferMatch) {
            const amount = transferMatch[1];
            messageContentHtml = `
                <div class="chat-bubble bubble-transfer">
                    <div class="interactive-card-header">
                        <svg class="svg-icon"><use href="#icon-transfer-new"></use></svg>
                        <div class="info">
                            <div class="title">转账给你</div>
                            <div class="subtitle">¥ ${amount}</div>
                        </div>
                    </div>
                    <div class="interactive-card-footer"><span>微信转账</span></div>
                </div>`;
        } else if (voiceMatch) {
            const voiceContent = voiceMatch[1];
            messageContentHtml = `
                <div class="chat-bubble bubble-voice" style="width: 180px; background: #E9ECEF; color: #1d2129;">
                    <div class="voice-main">
                        <svg class="svg-icon" style="color: #1d2129;"><use href="#icon-mic"></use></svg>
                        <span style="flex-grow: 1;">${voiceContent.substring(0, 15)}...</span>
                        <span class="voice-duration">"</span>
                    </div>
                </div>`;
        } else if (fileMatch) {
            const fileName = fileMatch[1];
            messageContentHtml = `
                <div class="chat-bubble bubble-file">
                    <div class="file-card-header">
                        <svg class="svg-icon"><use href="#icon-file-doc"></use></svg>
                        <div class="file-card-info"><div class="file-name">${fileName}</div></div>
                    </div>
                    <div class="file-card-footer"><span>文件</span></div>
                </div>`;
        } else if (locationMatch) {
            const address = locationMatch[1];
            messageContentHtml = `
                <div class="chat-bubble bubble-location">
                    <div class="interactive-card-header">
                        <svg class="svg-icon"><use href="#icon-map-pin"></use></svg>
                        <div class="info"><div class="title">${address}</div></div>
                    </div>
                    <div class="interactive-card-body"></div>
                    <div class="interactive-card-footer"><span>位置信息</span></div>
                </div>`;
        } 
        // --- Fallback to parsing DESCRIPTIVE text (from older user-forward logic) ---
        else if (messageString.startsWith('[送出礼物')) {
            const giftName = messageString.match(/'(.*?)'/)?.[1] || '礼物';
            messageContentHtml = `
                <div class="chat-bubble bubble-gift">
                    <div class="interactive-card-header">
                        <svg class="svg-icon"><use href="#icon-gift"></use></svg>
                        <div class="info">
                            <div class="title">送你一份礼物</div>
                            <div class="subtitle">${giftName}</div>
                        </div>
                    </div>
                    <div class="interactive-card-footer"><span>微信礼物</span></div>
                </div>`;
        } else if (messageString.startsWith('[发起转账')) {
            const amount = messageString.match(/¥(\d+\.?\d*)/)?.[1] || '0.00';
            messageContentHtml = `
                <div class="chat-bubble bubble-transfer">
                    <div class="interactive-card-header">
                        <svg class="svg-icon"><use href="#icon-transfer-new"></use></svg>
                        <div class="info">
                            <div class="title">转账给你</div>
                            <div class="subtitle">¥ ${amount}</div>
                        </div>
                    </div>
                    <div class="interactive-card-footer"><span>微信转账</span></div>
                </div>`;
        } else if (messageString.startsWith('[文章分享')) {
            const ficTitle = messageString.match(/'(.*)'/)?.[1] || '一篇文章';
            messageContentHtml = `
                <div class="chat-bubble fanfic-share-bubble">
                    <div class="fanfic-share-title">${ficTitle}</div>
                    <div class="fanfic-share-footer">同人文章</div>
                </div>`;
        }
        // ... (you can add more descriptive fallbacks here if needed) ...
        else {
            // If nothing matches, it must be plain text
            messageContentHtml = `<div class="message">${messageString}</div>`;
        }

        // Return the final HTML for this line
        return `
            <div class="message-line">
                <div class="sender">${rec.sender}</div>
                ${messageContentHtml}
            </div>
        `;
    }).join('');

    // --- The rest of the function remains the same ---
    const modalHTML = `
        <div class="forward-viewer-header">
            <span class="title" style="color: #1d2129;">聊天记录</span>
            <div class="ins-close-btn" id="forward-viewer-close-btn">
                <svg class="svg-icon"><use href="#icon-close"></use></svg>
            </div>
        </div>
        <div class="forward-viewer-body">
            ${recordsHtml}
        </div>
    `;
    
    modalContent.className = 'forward-viewer-modal';
    showModal(modalHTML);

    get('forward-viewer-close-btn').addEventListener('click', hideModal);
}
    function cancelReply() {
        currentReplyId = null;
        get('reply-bar-container').style.display = 'none';
    }

    // Multi-Select Delete Mode
    // --- 【升级版】进入多选模式 ---
        function enterMultiSelectMode(initialMsgId, mode = 'delete') { // 增加 mode 参数
            get('chat-page').classList.add('multi-select-mode');
            multiSelectMsgIds = [initialMsgId];
            renderMultiSelectBar(mode); // 将 mode 传递给渲染函数
            renderSelectionState();
            messagesContainer.addEventListener('click', handleMultiSelectClick);
        }

    function exitMultiSelectMode() {
        get('chat-page').classList.remove('multi-select-mode');
        multiSelectMsgIds = [];
        get('multi-select-bar-container').style.display = 'none';
        renderSelectionState();
        messagesContainer.removeEventListener('click', handleMultiSelectClick);
    }
    // 【V2 Upgrade】
    function handleMultiSelectClick(e) {
        // 【FIX】The selector now includes the parent of the call summary bubble.
        // We look for the parent div that has a '.call-summary-bubble' inside it.
        // The 'div:has(.call-summary-bubble)' is a modern CSS selector that does this.
        // For broader compatibility, we can check the child instead.
        const row = e.target.closest('.message-row, .retracted-message, .call-summary-bubble');
        
        // If we clicked on the summary bubble, we actually need its parent's ID for consistency,
        // but in our current HTML structure, the bubble itself is what gets the click. Let's adapt.
        // Let's ensure the parent row of the summary bubble has the data-msg-id
        const messageContainer = e.target.closest('[data-msg-id]');
    
        if (!messageContainer) return;
        const msgId = messageContainer.dataset.msgId;
        
        if (multiSelectMsgIds.includes(msgId)) {
            multiSelectMsgIds = multiSelectMsgIds.filter(id => id !== msgId);
        } else {
            multiSelectMsgIds.push(msgId);
        }
        renderSelectionState();
    }
    function renderSelectionState() {
        document.querySelectorAll('.message-row, .retracted-message').forEach(row => {
            if (multiSelectMsgIds.includes(row.dataset.msgId)) {
                row.classList.add('selected');
            } else {
                row.classList.remove('selected');
            }
        });
    }
   // 【V2 Ultimate Version - Instant Deletion】
   // 【V3 终极反馈版】
   function renderMultiSelectBar(mode) {
       const bar = get('multi-select-bar-container');
       bar.style.display = 'block';
   
       // 立即更新按钮上的数字
       const countText = multiSelectMsgIds.length > 0 ? ` (${multiSelectMsgIds.length})` : '';
   
       let confirmButtonHtml = '';
       if (mode === 'delete') {
           confirmButtonHtml = `<button class="btn btn-primary" id="confirm-delete-selected" style="flex:2; background: #E53535;">删除${countText}</button>`;
       } else if (mode === 'forward') {
           confirmButtonHtml = `<button class="btn btn-primary" id="confirm-forward-selected" style="flex:2;">完成转发</button>`;
       }
   
       bar.innerHTML = `<div class="multi-select-bar">
           <button class="btn btn-secondary" id="cancel-multi-select" style="flex:1; margin-right: 10px; background: #6c757d;">取消</button>
           ${confirmButtonHtml}
       </div>`;
       
       const confirmBtn = get('confirm-delete-selected') || get('confirm-forward-selected');
       get('cancel-multi-select').addEventListener('click', exitMultiSelectMode);
   
       if (mode === 'delete' && confirmBtn) {
           confirmBtn.addEventListener('click', () => {
               if (multiSelectMsgIds.length === 0) {
                   showToast("没有选择任何消息");
                   return;
               }
   
               // VVVV 核心修正 VVVV
               // 在清空列表之前，先把要删除的数量存下来！
               const messagesToDeleteCount = multiSelectMsgIds.length;
               // ^^^^ 修正结束 ^^^^
   
               // Step 1: 立即从 DOM 移除
               const container = get('chat-messages-container');
               multiSelectMsgIds.forEach(msgId => {
                   const elementToRemove = container.querySelector(`[data-msg-id="${msgId}"]`);
                   if (elementToRemove) {
                       elementToRemove.remove();
                   }
               });
   
               // Step 2: 更新 state
               const chat = state.chats.find(c => c.id === currentChatId);
               if (chat) {
                   chat.messages = chat.messages.filter(m => !multiSelectMsgIds.includes(m.msgId));
                   saveState();
               }
               
               // Step 3: 退出多选模式 (这会清空 multiSelectMsgIds)
               exitMultiSelectMode();
               
               // VVVV 核心修正 VVVV
               // 使用我们之前保存的数量来显示 Toast
               showToast(`${messagesToDeleteCount}条消息已删除`);
               // ^^^^ 修正结束 ^^^^
   
               renderChatList();
           });
       } else if (mode === 'forward' && confirmBtn) {
           confirmBtn.addEventListener('click', handleConfirmForward);
       }
   }
   
   // And we need to update one more function to update the button count
   function renderSelectionState() {
       document.querySelectorAll('[data-msg-id]').forEach(row => {
           if (multiSelectMsgIds.includes(row.dataset.msgId)) {
               row.classList.add('selected');
           } else {
               row.classList.remove('selected');
           }
       });
   
       // 【NEW】Update the delete button's text to show the count
       const deleteBtn = get('confirm-delete-selected');
       if (deleteBtn) {
           deleteBtn.textContent = `删除 (${multiSelectMsgIds.length})`;
       }
   }
	    // --- 【全新】处理“完成转发”按钮点击事件的函数 ---
	  // --- 【V3.0 结构化升级版】处理“完成转发”按钮点击事件 ---
	    function handleConfirmForward() {
	        if (multiSelectMsgIds.length === 0) return showToast('请至少选择一条消息');
	        const chat = state.chats.find(c => c.id === currentChatId);
	        if (!chat) return;
	
	        const selectedMessages = chat.messages.filter(msg => multiSelectMsgIds.includes(msg.msgId));
	        selectedMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
	
	        const forwardedContent = selectedMessages.map(msg => {
	            let senderName = '';
	            // ... (获取 senderName 的逻辑和之前完全一样)
	            if (msg.role === 'user') {
	                senderName = state.momentsProfile.name || '我';
	            } else {
	                 if (chat.type === 'group') {
	                    const member = chat.settings.members.find(m => m.id === msg.memberId);
	                    senderName = member ? member.name : '未知成员';
	                } else {
	                    senderName = chat.settings.ai.name;
	                }
	            }
	
	            // 【核心修改】将消息对象转换为 AI 理解的字符串格式
	           // ...
	           let messageString = '';
	           switch (msg.type) {
	               case 'text': messageString = msg.content; break;
	               case 'voice': messageString = `[VOICE:${msg.content.text}]`; break; // 修正：从对象中取text
	               case 'file': messageString = `[FILE:${msg.content.name}@@${msg.content.body}]`; break;
	               case 'location': messageString = `[LOCATION:${msg.content.address}]`; break;
	               case 'transfer': messageString = `[TRANSFER:${msg.content.amount}@@${msg.content.message}@@${msg.content.id}]`; break;
	               case 'gift': messageString = `[GIFT:${msg.content.name}@@${msg.content.description}@@${msg.content.message}@@${msg.content.id}]`; break;
	               
	               // 【修复】将 messageText 改为 messageString
	               case 'image':
	                   messageString = `[发送图片，图片描述：'${msg.content.description || '无'}']`;
	                   break;
	               case 'fanfic_share':
	                   messageString = `[文章分享：'${msg.content.title}']`;
	                   break;
	           
	               default: messageString = `[${msg.type}]`; break;
	           }
	           return { sender: senderName, message: messageString };
	        });
	
	        showForwardTargetSelector(forwardedContent);
	        exitMultiSelectMode();
	    }

    // --- ADD/EDIT/SETTINGS PAGES ---
	/**
	 * 【全新】导航到指定页面并重置导航历史
	 * 用于删除等操作后，返回到一个干净的根页面
	 * @param {string} targetPageId - 目标页面的ID, 例如 'chat-list-page'
	 */
	function navigateToPageAndClearHistory(targetPageId) {
	    // 1. 获取当前所有页面，准备隐藏它们
	    const allPages = document.querySelectorAll('.page');
	    const targetPage = get(targetPageId);
	
	    if (!targetPage) {
	        console.error(`导航失败: 目标页面 "${targetPageId}" 未找到。`);
	        return;
	    }
	
	    // 2. 隐藏所有页面，清理状态
	    allPages.forEach(page => {
	        page.classList.remove('active', 'previous');
	    });
	
	    // 3. 干净利落地显示目标页面
	    targetPage.classList.add('active');
	
	    // 4. 【核心】重置导航历史记录
	    // 我们的导航路径通常是 home-screen -> chat-list-page -> ...
	    // 所以重置到聊天列表页时，历史记录应该是这样的：
	    navHistory = ['home-screen', targetPageId];
	
	    // 5. 确保任何与已删除聊天相关的状态都被清理干净
	    currentChatId = null;
	    removeChatCss(); // 移除可能残留的自定义CSS
	}

	// 这是新的代码
	get('add-chat-btn').addEventListener('click', () => {
	    // 步骤1：创建一个包含两个按钮的HTML片段
	    const modalHTML = `
	        <h3>创建新聊天</h3>
	        <p style="text-align: center; color: var(--secondary-text); margin-bottom: 20px;">请选择要创建的聊天类型</p>
	        <button id="create-single-chat-btn" class="btn btn-primary" style="margin-bottom: 12px;">创建单人聊天</button>
	        <button id="create-group-chat-btn" class="btn btn-secondary">创建群聊</button>
	    `;
	
	    // 步骤2：显示这个弹窗
	    showModal(modalHTML);
	
	    // 步骤3：为弹窗里的新按钮添加事件监听
	    get('create-single-chat-btn').addEventListener('click', () => {
	        hideModal(); // 先关闭当前弹窗
	        setTimeout(() => showCreateSingleChatPrompt(), 200); // 延迟一点打开新弹窗，体验更好
	    });
	
	    get('create-group-chat-btn').addEventListener('click', () => {
	        hideModal();
	        setTimeout(() => showCreateGroupChatPrompt(), 200);
	    });
	});
	
	// 新增函数1：显示创建单人聊天的弹窗
	function showCreateSingleChatPrompt() {
	    const modalHTML = `
	        <h3>创建单人聊天</h3>
	        <div class="form-group">
	            <label for="chat-name-input">为你的新聊天对象起个名字：</label>
	            <input type="text" id="chat-name-input" class="form-control" placeholder="例如：阿鱼">
	        </div>
	        <button id="confirm-create-single" class="btn btn-primary">确定</button>
	    `;
	    showModal(modalHTML);
	
	    get('confirm-create-single').addEventListener('click', () => {
	        const name = get('chat-name-input').value.trim();
	        if (name) {
	            const newChat = {
	                id: generateId('chat'), type: 'single', messages: [],
	                settings: {
	                    ai: { name: name, persona: `你是一个名叫“${name}”的AI助手。`, avatar: '', videoCallImages: [] },
	                    user: { persona: '我正在与你进行对话。', avatar: '' },
	                    linkedWorldBookIds: [], memoryDepth: 12, background: '', customCss: '',
						aiHeartVoice: '（开始一段新的对话，有点期待。）'
	                },
	                offlineSceneSettings: {
	                               background: '',
	                               colors: {
	                                   narrative: '#495057',
	                                   user_dialogue: '#0056b3',
	                                   user_action: '#5a6268',
	                                   user_internal: '#6c757d',
	                                   user_narrative: '#6a1b9a',
	                                   container_bg: 'rgba(255, 255, 255, 0.75)'
	                               }
	                           }
	            };
	            state.chats.unshift(newChat);
	            saveState();
	            renderChatList();
	            hideModal();
	            openChat(newChat.id);
	        } else {
	            showToast("名字不能为空");
	        }
	    });
	
	    // 让输入框回车也能提交
	    get('chat-name-input').onkeypress = (e) => {
	        if(e.key === 'Enter') get('confirm-create-single').click();
	    };
	}
	
	// 新增函数2：显示创建群聊的弹窗
	function showCreateGroupChatPrompt() {
	    const modalHTML = `
	        <h3>创建群聊</h3>
	        <div class="form-group">
	            <label for="chat-name-input">为你的新群聊起个名字：</label>
	            <input type="text" id="chat-name-input" class="form-control" placeholder="例如：摸鱼一家人">
	        </div>
	        <button id="confirm-create-group" class="btn btn-primary">确定</button>
	    `;
	    showModal(modalHTML);
	
	    get('confirm-create-group').addEventListener('click', () => {
	        const name = get('chat-name-input').value.trim();
	        if (name) {
	            const newChat = {
	                id: generateId('chat'), type: 'group', messages: [],
	                settings: {
	                    groupName: name, members: [],
	                    user: { persona: '我正在与你进行对话。', avatar: '' },
	                    linkedWorldBookIds: [], memoryDepth: 12, background: '', customCss: '',
						aiHeartVoice: '（开始一段新的对话，有点期待。）'
	                },
	                offlineSceneSettings: {
	                               background: '',
	                               colors: {
	                                   narrative: '#495057',
	                                   user_dialogue: '#0056b3',
	                                   user_action: '#5a6268',
	                                   user_internal: '#6c757d',
	                                   user_narrative: '#6a1b9a',
	                                   container_bg: 'rgba(255, 255, 255, 0.75)'
	                               }
	                           }
	            };
	            state.chats.unshift(newChat);
	            saveState();
	            renderChatList();
	            currentChatId = newChat.id;
	            hideModal();
	            openGroupChatSettings();
	        } else {
	            showToast("名字不能为空");
	        }
	    });
	    
	    // 让输入框回车也能提交
	    get('chat-name-input').onkeypress = (e) => {
	        if(e.key === 'Enter') get('confirm-create-group').click();
	    };
	}

    function openSingleChatSettings() {
        const chat = state.chats.find(c => c.id === currentChatId); if (!chat) return;
        get('setting-ai-name').value = chat.settings.ai.name;
        get('setting-ai-persona').value = chat.settings.ai.persona;
        get('setting-user-persona').value = chat.settings.user.persona;
        get('ai-avatar-preview').src = chat.settings.ai.avatar || defaultAiAvatar;
        get('user-avatar-preview').src = chat.settings.user.avatar || defaultUserAvatar;
        get('setting-memory-depth').value = chat.settings.memoryDepth || 12;
        get('chat-bg-preview').src = chat.settings.background || '';
        get('chat-bg-preview').style.display = chat.settings.background ? 'block' : 'none';
        
                // --- 【V2 渲染逻辑】 ---
        const container = get('world-book-link-container');
        const linkedIds = chat.settings.linkedWorldBookIds || [];
        const selectedCount = linkedIds.length;

        const checklistHtml = state.worldBooks.length > 0 ? state.worldBooks.map(wb => {
            const isChecked = linkedIds.includes(wb.id);
            return `
                <div class="wb-link-item">
                    <input type="checkbox" id="wb-link-${wb.id}" data-wbid="${wb.id}" ${isChecked ? 'checked' : ''}>
                    <label for="wb-link-${wb.id}">${wb.title}</label>
                </div>
            `;
        }).join('') : '<p style="color: var(--secondary-text);">还没有世界书条目。</p>';

        container.innerHTML = `
            <div class="collapsible-world-book-container">
                <div class="world-book-summary-trigger">
                    <span class="title">链接的世界书 (${selectedCount} 已选)</span>
                    <svg class="svg-icon chevron-icon"><use href="#icon-chevron-right"></use></svg>
                </div>
                <div class="world-book-checklist-content">
                    ${checklistHtml}
                </div>
            </div>
        `;

        // 【核心】为新生成的触发器绑定点击事件
        container.querySelector('.world-book-summary-trigger').addEventListener('click', (e) => {
            e.currentTarget.closest('.collapsible-world-book-container').classList.toggle('expanded');
        });
		
        // =========== 新增代码开始 ===========
        // 这段代码负责加载CSS并设置实时预览
        const cssTextarea = get('setting-custom-css');
        const previewStyleTag = get('css-preview-style');
        const restoreBtn = get('restore-custom-css-btn');
    
        // 1. 加载已保存的CSS到文本框
        cssTextarea.value = chat.settings.customCss || '';
        
        // 2. 定义一个更新预览的函数
        const updatePreview = () => {
            // 给所有规则加上预览区的父选择器，防止污染页面
            const scopedCss = `#css-preview-container ${cssTextarea.value.replace(/\}/g, '}\n#css-preview-container ')}`;
            previewStyleTag.textContent = scopedCss;
        };
    
        // 3. 监听文本框的输入事件，实时调用更新函数
        cssTextarea.addEventListener('input', updatePreview);
        
        // 4. 给“恢复默认”按钮添加点击事件
        restoreBtn.addEventListener('click', () => {
            cssTextarea.value = ''; // 清空文本框
            updatePreview();      // 更新预览
            showToast('已恢复默认');
        });
    
        // 5. 页面加载时，立即执行一次，显示当前保存的效果
        updatePreview();
        // =========== 新增代码结束 ===========
		
		get('preview-ai-avatar').src = chat.settings.ai.avatar || defaultAiAvatar;
		get('preview-user-avatar').src = chat.settings.user.avatar || defaultUserAvatar;
    
        renderVideoCallImages();
		navigateTo('chat-settings-page');
		 populateVoiceList(); 
    }


    get('save-chat-settings-btn').addEventListener('click', () => {
        const chat = state.chats.find(c => c.id === currentChatId); if (!chat) return;
        chat.settings.ai.name = get('setting-ai-name').value;
        chat.settings.ai.persona = get('setting-ai-persona').value;
        chat.settings.user.persona = get('setting-user-persona').value;
		 chat.settings.customCss = get('setting-custom-css').value;
		  chat.settings.ai.voiceURI = get('setting-ai-voice').value; 
        chat.settings.linkedWorldBookIds = Array.from(get('world-book-link-container').querySelectorAll('input:checked')).map(el => el.dataset.wbid);
        
        const depth = parseInt(get('setting-memory-depth').value, 10);
        chat.settings.memoryDepth = isNaN(depth) || depth < 2 ? 12 : depth;

        saveState();
        get('chat-title').textContent = chat.settings.ai.name;
        renderChatList();
		const chatPageContent = get('chat-page').querySelector('.page-content');
		    if (chat.settings.background) {
		        chatPageContent.style.backgroundImage = `url(${chat.settings.background})`;
		    } else {
		        chatPageContent.style.backgroundImage = 'none';
		    }
		applyChatCss(chat.settings.customCss); 
        showToast('设置已保存');
        navigateBack();
    });
    
    function setupAvatarUpload(inputId, previewId, saveCallback) {
        const input = get(inputId);
        if (!input) return; // 增加一个安全检查
    
        // 只有当 previewId 存在时，才去获取 preview 元素
        const preview = previewId ? get(previewId) : null; 
    
        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            // 稍微放宽图片大小限制以适应背景图
            if (file.size > 10* 1024 * 1024) { 
                showToast('图片太大，请选择4MB以下的图片');
                e.target.value = ''; // 清空选择
                return; 
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const base64String = event.target.result;
                
                // 【核心修复】在这里添加一个判断
                // 只有当 preview 元素存在时，才去更新它的 src 和 display
                if (preview) {
                    preview.src = base64String;
                    preview.style.display = 'block';
                }
                
                // 无论有没有预览，保存数据的回调函数都必须被调用
                saveCallback(base64String);
            };
            reader.readAsDataURL(file);
        });
    }
    // Single Chat Avatars
    setupAvatarUpload('setting-ai-avatar', 'ai-avatar-preview', (base64) => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) { chat.settings.ai.avatar = base64; saveState(); }
    });
    setupAvatarUpload('setting-user-avatar', 'user-avatar-preview', (base64) => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) { chat.settings.user.avatar = base64; saveState(); }
    });
    // Single Chat Background
    setupAvatarUpload('setting-chat-bg', 'chat-bg-preview', (base64) => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) { chat.settings.background = base64; saveState(); }
    });
    get('clear-chat-bg-btn').addEventListener('click', () => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) {
            chat.settings.background = '';
            get('chat-bg-preview').src = '';
            get('chat-bg-preview').style.display = 'none';
            saveState();
        }
    });

    get('delete-chat-btn').addEventListener('click', () => {
        showConfirmationModal('确定要永久删除这个聊天吗？', () => {
            state.chats = state.chats.filter(c => c.id !== currentChatId);
            // currentChatId 已经被我们的新函数处理了，这里可以不写
            saveState();
            renderChatList();
            
            // 【核心修改】调用新函数，直接返回列表页
            navigateToPageAndClearHistory('chat-list-page');
            
            showToast('聊天已删除');
        });
    });
	// --- 【全新】视频通话形象库设置逻辑 ---
	
	// 1. 渲染形象列表
	function renderVideoCallImages() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat) return;
	    const container = get('video-call-images-container');
	    container.innerHTML = ''; // 清空
	    
	    if (chat.settings.ai.videoCallImages.length === 0) {
	        container.innerHTML = `<p style="color: var(--secondary-text); font-size: 14px;">还未添加任何形象。AI在视频通话中将使用它的头像。</p>`;
	    }
	
	    chat.settings.ai.videoCallImages.forEach(img => {
	        container.innerHTML += `
	        <div class="video-image-item" data-id="${img.id}" style="display: flex; gap: 10px; align-items: center; border-bottom: 1px solid #eee; padding-bottom: 10px;">
	            <img src="${img.url}" style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px;">
	            <div style="flex-grow: 1;">
	                <p style="margin: 0 0 5px; font-weight: 500;">情绪: ${img.emotion}</p>
	                <p style="margin: 0; font-size: 13px; color: #888;">描述: ${img.description}</p>
	            </div>
	            <button class="btn-small delete-video-image-btn" style="background: #E53935; color: white; padding: 5px 10px;">删除</button>
	        </div>
	        `;
	    });
	}
	
	// 2. 打开添加/编辑形象的弹窗
	function openVideoImageEditor() {
	    const modalHTML = `
	        <h3>添加新形象</h3>
	        <div class="form-group">
	            <label>情绪关键词 (例如: 开心, 难过, 惊讶)</label>
	            <input type="text" id="video-image-emotion" placeholder="一个简短的中文词语">
	        </div>
	        <div class="form-group">
	            <label>图片描述 (告诉AI何时使用)</label>
	            <input type="text" id="video-image-desc" placeholder="例如：一张微笑的自拍">
	        </div>
	        <div class="form-group">
	            <label>图片 (本地上传)</label>
	            <input type="file" id="video-image-upload" accept="image/*">
	        </div>
	        <button id="save-video-image-btn" class="btn btn-primary">保存</button>
	    `;
	    showModal(modalHTML);
	    
	    let imageBase64 = null;
	    get('video-image-upload').onchange = e => {
	        const file = e.target.files[0];
	        if (!file) return;
	        const reader = new FileReader();
	        reader.onload = event => imageBase64 = event.target.result;
	        reader.readAsDataURL(file);
	    };
	
	    get('save-video-image-btn').onclick = () => {
	        const emotion = get('video-image-emotion').value.trim();
	        const description = get('video-image-desc').value.trim();
	        if (!emotion || !description || !imageBase64) {
	            showToast('所有字段都不能为空');
	            return;
	        }
	
	        const chat = state.chats.find(c => c.id === currentChatId);
	        chat.settings.ai.videoCallImages.push({
	            id: generateId('vimg'),
	            emotion: emotion,
	            description: description,
	            url: imageBase64
	        });
	        saveState();
	        renderVideoCallImages();
	        hideModal();
	    };
	}
	
	// 3. 绑定事件
	function setupVideoImageSettingsListeners() {
	    get('add-video-image-btn').addEventListener('click', openVideoImageEditor);
	    
	    get('video-call-images-container').addEventListener('click', e => {
	        if (e.target.classList.contains('delete-video-image-btn')) {
	            const item = e.target.closest('.video-image-item');
	            const imgId = item.dataset.id;
	            if (confirm('确定要删除这个形象吗？')) {
	                const chat = state.chats.find(c => c.id === currentChatId);
	                chat.settings.ai.videoCallImages = chat.settings.ai.videoCallImages.filter(img => img.id !== imgId);
	                saveState();
	                renderVideoCallImages();
	            }
	        }
	    });
	}

    // --- ADDED: Group Chat Settings Logic ---
    function openGroupChatSettings() {
        const chat = state.chats.find(c => c.id === currentChatId); if (!chat) return;
        get('setting-group-name').value = chat.settings.groupName;
        get('setting-group-user-persona').value = chat.settings.user.persona;
        get('group-user-avatar-preview').src = chat.settings.user.avatar || defaultUserAvatar;
        get('setting-group-memory-depth').value = chat.settings.memoryDepth || 12;
        get('group-chat-bg-preview').src = chat.settings.background || '';
        get('group-chat-bg-preview').style.display = chat.settings.background ? 'block' : 'none';
    
        renderGroupMembersList();
    
                // --- 【V2 渲染逻辑】 ---
                const container = get('group-world-book-link-container'); // <-- 使用正确的ID
                const linkedIds = chat.settings.linkedWorldBookIds || [];
                const selectedCount = linkedIds.length;
        
                const checklistHtml = state.worldBooks.length > 0 ? state.worldBooks.map(wb => {
                    const isChecked = linkedIds.includes(wb.id);
                    return `
                        <div class="wb-link-item">
                            <input type="checkbox" id="group-wb-link-${wb.id}" data-wbid="${wb.id}" ${isChecked ? 'checked' : ''}>
                            <label for="group-wb-link-${wb.id}">${wb.title}</label>
                        </div>
                    `;
                }).join('') : '<p style="color: var(--secondary-text);">还没有世界书条目。</p>';
        
                container.innerHTML = `
                    <div class="collapsible-world-book-container">
                        <div class="world-book-summary-trigger">
                            <span class="title">链接的世界书 (${selectedCount} 已选)</span>
                            <svg class="svg-icon chevron-icon"><use href="#icon-chevron-right"></use></svg>
                        </div>
                        <div class="world-book-checklist-content">
                            ${checklistHtml}
                        </div>
                    </div>
                `;
        
                // 【核心】为新生成的触发器绑定点击事件
                container.querySelector('.world-book-summary-trigger').addEventListener('click', (e) => {
                    e.currentTarget.closest('.collapsible-world-book-container').classList.toggle('expanded');
                });
    
        // =========== 新增代码开始 ===========
        // 这段代码负责加载群聊CSS并设置实时预览
        const cssTextarea = get('setting-group-custom-css');
        const previewStyleTag = get('group-css-preview-style');
        const restoreBtn = get('restore-group-custom-css-btn');
    
        // 1. 加载已保存的CSS
        cssTextarea.value = chat.settings.customCss || '';
        
        // 2. 定义更新预览函数
        const updatePreview = () => {
            const scopedCss = `#group-css-preview-container ${cssTextarea.value.replace(/\}/g, '}\n#group-css-preview-container ')}`;
            previewStyleTag.textContent = scopedCss;
        };
    
        // 3. 监听输入事件
        cssTextarea.addEventListener('input', updatePreview);
        
        // 4. 绑定恢复默认按钮
        restoreBtn.addEventListener('click', () => {
            cssTextarea.value = '';
            updatePreview();
            showToast('已恢复默认');
        });
    
        // 5. 立即更新一次预览
        updatePreview();
        // =========== 新增代码结束 ===========
		
		  get('group-preview-ai-avatar').src = defaultAiAvatar; 
         get('group-preview-user-avatar').src = chat.settings.user.avatar || defaultUserAvatar;
    
    
        navigateTo('group-chat-settings-page');
    }


    function renderGroupMembersList() {
        const chat = state.chats.find(c => c.id === currentChatId); if (!chat) return;
        const container = get('group-members-list');
        container.innerHTML = '';
        chat.settings.members.forEach(member => {
            container.innerHTML += `<div class="list-item" data-member-id="${member.id}">
                <img src="${member.avatar || defaultAiAvatar}" class="avatar-preview" style="width:40px; height:40px; margin-right:12px;">
                <div class="info"><div class="name">${member.name}</div></div>
                <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
            </div>`;
        });
        container.querySelectorAll('.list-item').forEach(item => {
            item.addEventListener('click', () => openMemberEditor(item.dataset.memberId));
        });
    }
    
    function openMemberEditor(memberId = null) {
        const chat = state.chats.find(c => c.id === currentChatId);
        const member = memberId ? chat.settings.members.find(m => m.id === memberId) : null;
        
        const modalHTML = `
            <h3>${memberId ? '编辑' : '添加'}成员</h3>
            <div class="form-group">
                <label>名字</label><input type="text" id="member-name-input" value="${member ? member.name : ''}">
            </div>
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload-group">
                    <img id="member-avatar-preview" class="avatar-preview" src="${member && member.avatar ? member.avatar : defaultAiAvatar}">
                    <label class="upload-btn">上传图片<input type="file" id="member-avatar-input" accept="image/*" style="display:none;"></label>
                </div>
            </div>
            <div class="form-group">
                <label>人设</label><textarea id="member-persona-input">${member ? member.persona : ''}</textarea>
            </div>
            <button id="save-member-btn" class="btn btn-primary">保存</button>
            ${memberId ? '<button id="delete-member-btn" class="btn btn-secondary" style="background-color:#E53935;">删除成员</button>' : ''}
        `;
        showModal(modalHTML);
        
        let newAvatarBase64 = member ? member.avatar : '';
        setupAvatarUpload('member-avatar-input', 'member-avatar-preview', (base64) => { newAvatarBase64 = base64; });

        get('save-member-btn').addEventListener('click', () => {
            const name = get('member-name-input').value.trim();
            const persona = get('member-persona-input').value.trim();
            if (!name) return showToast('名字不能为空');
            
            if (memberId) {
                const existingMember = chat.settings.members.find(m => m.id === memberId);
                existingMember.name = name;
                existingMember.persona = persona;
                existingMember.avatar = newAvatarBase64;
            } else {
                chat.settings.members.push({ id: generateId('member'), name, persona, avatar: newAvatarBase64 });
            }
            saveState();
            renderGroupMembersList();
            hideModal();
        });

        if (memberId) {
            get('delete-member-btn').addEventListener('click', () => {
                if(confirm(`确定要删除成员 ${member.name} 吗？`)) {
                    chat.settings.members = chat.settings.members.filter(m => m.id !== memberId);
                    saveState();
                    renderGroupMembersList();
                    hideModal();
                }
            });
        }
    }

    get('add-group-member-btn').addEventListener('click', () => openMemberEditor(null));
    
    get('save-group-chat-settings-btn').addEventListener('click', () => {
        const chat = state.chats.find(c => c.id === currentChatId); if (!chat) return;
        chat.settings.groupName = get('setting-group-name').value;
        chat.settings.user.persona = get('setting-group-user-persona').value;
		chat.settings.customCss = get('setting-group-custom-css').value;
        chat.settings.linkedWorldBookIds = Array.from(get('group-world-book-link-container').querySelectorAll('input:checked')).map(el => el.dataset.wbid);
        
        const depth = parseInt(get('setting-group-memory-depth').value, 10);
        chat.settings.memoryDepth = isNaN(depth) || depth < 2 ? 12 : depth;

        saveState();
        get('chat-title').textContent = chat.settings.groupName;
        renderChatList();
		const chatPageContent = get('chat-page').querySelector('.page-content');
		    if (chat.settings.background) {
		        chatPageContent.style.backgroundImage = `url(${chat.settings.background})`;
		    } else {
		        chatPageContent.style.backgroundImage = 'none';
		    }
		applyChatCss(chat.settings.customCss);
        showToast('设置已保存');
        navigateBack();
    });
    
    // Group Chat Avatars & Background
    setupAvatarUpload('setting-group-user-avatar', 'group-user-avatar-preview', (base64) => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) { chat.settings.user.avatar = base64; saveState(); }
    });
    setupAvatarUpload('setting-group-chat-bg', 'group-chat-bg-preview', (base64) => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) { chat.settings.background = base64; saveState(); }
    });
    get('clear-group-chat-bg-btn').addEventListener('click', () => {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) {
            chat.settings.background = '';
            get('group-chat-bg-preview').src = '';
            get('group-chat-bg-preview').style.display = 'none';
            saveState();
        }
    });

    // 【V2 完整版】修复了群聊删除的弹窗问题
    get('delete-group-chat-btn').addEventListener('click', () => {
        showConfirmationModal('确定要永久删除这个群聊吗？', () => {
            state.chats = state.chats.filter(c => c.id !== currentChatId);
            saveState();
            renderChatList();
            
            // 【核心修改】同样调用新函数，直接返回列表页
            navigateToPageAndClearHistory('chat-list-page');
            showToast('群聊已删除');
        });
    });



    // --- WORLD BOOK ---
    get('add-world-book-btn').addEventListener('click', () => openWorldBookEditor(null));
    
    function openWorldBookEditor(id) {
        if (id) {
            const wb = state.worldBooks.find(w => w.id === id);
            get('world-book-edit-title').textContent = '编辑世界书';
            get('world-book-edit-id').value = wb.id;
            get('world-book-title-input').value = wb.title;
            get('world-book-content-input').value = wb.content;
            get('delete-world-book-btn').style.display = 'block';
        } else {
            get('world-book-edit-title').textContent = '新建世界书';
            get('world-book-edit-id').value = '';
            get('world-book-title-input').value = '';
            get('world-book-content-input').value = '';
            get('delete-world-book-btn').style.display = 'none';
        }
        navigateTo('world-book-edit-page');
    }

    get('save-world-book-btn').addEventListener('click', () => {
        const id = get('world-book-edit-id').value;
        const title = get('world-book-title-input').value.trim();
        const content = get('world-book-content-input').value.trim();
        if (!title) return showToast('标题不能为空');
        if (id) {
            const wb = state.worldBooks.find(w => w.id === id);
            wb.title = title; wb.content = content;
        } else {
            state.worldBooks.push({ id: generateId('wb'), title, content });
        }
        saveState();
        renderWorldBookList();
        showToast('世界书已保存');
        navigateBack();
    });

   get('delete-world-book-btn').addEventListener('click', () => {
       // 调用我们自己的确认弹窗函数
       showConfirmationModal('确定要删除这个世界书条目吗？删除后，所有链接到此条目的聊天都将失去相关设定。', () => {
           // 用户点击“确定”后执行这里的逻辑
           
           const id = get('world-book-edit-id').value;
           
           // 1. 从世界书列表中删除该条目
           state.worldBooks = state.worldBooks.filter(wb => wb.id !== id);
           
           // 2. 遍历所有聊天，解除与这个已删除世界书的链接
           state.chats.forEach(chat => {
               if (chat.settings && chat.settings.linkedWorldBookIds) {
                   chat.settings.linkedWorldBookIds = chat.settings.linkedWorldBookIds.filter(wbId => wbId !== id);
               }
           });
           
           // 3. 保存状态，更新UI，然后返回
           saveState();
           renderWorldBookList();
           navigateBack();
           showToast('世界书条目已删除'); // 加一个toast提示，体验更好
       });
   });


	// --- 在 DOMContentLoaded 的末尾，添加对新弹窗的事件监听。“一起听”弹窗事件绑定 ---
	const ltOverlay = get('listen-together-overlay');
	
	// 点击遮罩层或关闭按钮关闭弹窗
	ltOverlay.addEventListener('click', (e) => {
	    if (e.target === ltOverlay || e.target.closest('#lt-close-btn')) {
	        hideListenTogetherModal();
	    }
	});
	
	// 弹窗内的播放/暂停按钮
	get('lt-play-pause-btn').addEventListener('click', togglePlayPause);
	
	// 播放列表的事件委托
	get('lt-playlist-container').addEventListener('click', e => {
	    const item = e.target.closest('.lt-playlist-item');
	    const deleteBtn = e.target.closest('.delete-song-btn');
	
	    if (deleteBtn) { // 点击了删除
	        e.stopPropagation(); // 阻止事件冒泡触发播放
	        const songId = deleteBtn.dataset.songId;
	        // ... (这里的删除逻辑和之前侧边栏的完全一样) ...
	        const index = state.music.playlist.findIndex(s => s.id === songId);
	        if (index > -1) {
	            state.music.playlist.splice(index, 1);
	            if (state.music.playbackState.currentTrackIndex === index) stopMusic();
	            else if (state.music.playbackState.currentTrackIndex > index) state.music.playbackState.currentTrackIndex--;
	            saveState();
	            updateListenTogetherModal(); // 刷新弹窗
	        }
	    } else if (item) { // 点击了列表项
	        playSong(parseInt(item.dataset.index, 10));
	    }
	});

   
  // --- DIARY FEATURE LOGIC ---
// 1. 渲染写过日记的角色列表 (已简化，移除头像)
function renderDiaryCharacterList() {
    const container = get('diary-character-list-container');
    const characters = {};

    state.diaries.forEach(diary => {
        if (!characters[diary.chatId]) {
            characters[diary.chatId] = {
                chatId: diary.chatId,
                name: diary.characterName,
                lastDate: '1970-01-01',
                count: 0
            };
        }
        characters[diary.chatId].count++;
        if (diary.date > characters[diary.chatId].lastDate) {
            characters[diary.chatId].lastDate = diary.date;
        }
    });

    const characterList = Object.values(characters);

    if (characterList.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--secondary-text); padding: 40px;">还没有任何 AI 写过日记哦</p>';
        return;
    }

    container.innerHTML = '';
    characterList.forEach(char => {
        container.innerHTML += `
            <div class="diary-card-item" data-chat-id="${char.chatId}">
                <div class="diary-card-icon">
                    <svg class="svg-icon"><use href="#icon-journal"></use></svg>
                </div>
                <div class="diary-card-info">
                    <div class="name">${char.name}的日记本</div>
                    <div class="subtext">共 ${char.count} 篇，最新于 ${char.lastDate}</div>
                </div>
                <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
            </div>`;
    });

    // 【核心修复】将这里的选择器从 .diary-char-item 改为 .diary-card-item
    document.querySelectorAll('.diary-card-item').forEach(item => {
        item.addEventListener('click', () => openDiaryDateList(item.dataset.chatId));
    });
}

   
   // 2. 打开并渲染某个角色的日期列表
   function openDiaryDateList(chatId) {
       const characterDiaries = state.diaries
           .filter(d => d.chatId === chatId)
           .sort((a, b) => b.date.localeCompare(a.date)); 
   
       if (characterDiaries.length === 0) return;
   
       get('diary-character-name').textContent = `${characterDiaries[0].characterName}的日记`;
       const container = get('diary-date-list-container');
       container.innerHTML = '';
       
       // 【核心修改 ①】这里生成了我们新设计的、带图标的卡片HTML结构
       characterDiaries.forEach(diary => {
           container.innerHTML += `
               <div class="diary-card-item" data-diary-id="${diary.id}">
                   <div class="diary-card-icon">
                       <svg class="svg-icon"><use href="#icon-quill"></use></svg>
                   </div>
                   <div class="diary-card-info">
                       <div class="name">${diary.date}</div>
                       <div class="subtext">${diary.content.substring(0, 40)}...</div>
                   </div>
                   <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
               </div>`;
       });
   
       // 【核心修改 ②】事件监听器现在绑定在新的 .diary-card-item 上
       // (因为我们已经不再使用 .diary-date-item 这个类名了)
       document.querySelectorAll('#diary-date-list-container .diary-card-item').forEach(item => {
           item.addEventListener('click', () => openDiaryEntry(item.dataset.diaryId));
       });
   
       navigateTo('diary-date-list-page');
   }
   // 3. 打开并渲染单篇日记 (已增加删除功能)
   function openDiaryEntry(diaryId) {
       const diary = state.diaries.find(d => d.id === diaryId);
       if (!diary) return;
   
       const container = get('diary-entry-content-area');
       // 【核心修改 ①】这里不再生成任何按钮，只生成内容本身
       container.innerHTML = `
           <div class="diary-entry-container">
               <div class="diary-date">${diary.date}</div>
               <div class="diary-content">${diary.content}</div>
           </div>
       `;
       
       // 【核心修改 ②】为我们放在HTML头部的新按钮绑定点击事件
       // 为了防止事件重复绑定，我们先移除旧的监听器，再添加新的
       const deleteBtn = get('header-delete-diary-btn');
       const newDeleteBtn = deleteBtn.cloneNode(true); // 创建一个干净的克隆按钮
       deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn); // 替换旧按钮
   
       newDeleteBtn.addEventListener('click', () => {
           if (confirm('确定要永久删除这篇日记吗？')) {
               state.diaries = state.diaries.filter(d => d.id !== diaryId);
               saveState();
               showToast('日记已删除');
               // 【重要】因为我们是从日期列表页进来的，所以要连续返回两次才能回到角色列表
               navigateBack(); // 返回到日期列表
               // 重新渲染日期列表，它现在会发现少了一篇日记
               const chat = state.chats.find(c => c.id === diary.chatId);
               if(chat) openDiaryDateList(chat.id); 
           }
       });
   
       navigateTo('diary-entry-page');
   }

// --- MOMENTS (朋友圈) FEATURE LOGIC ---

// ---【全新增补函数】渲染朋友圈头部信息 ---
async function renderMomentsHeader() {
    // 从 state.momentsProfile 中获取用户的个人资料
    const profile = state.momentsProfile;

    // 获取需要更新的 HTML 元素
    const avatarEl = get('moments-user-avatar');
    const nameEl = get('moments-user-name');
    const signatureEl = get('moments-signature');
    const coverEl = get('moments-cover-image');

    // 安全检查，如果页面元素不存在，则退出函数，防止报错
    if (!avatarEl || !nameEl || !signatureEl || !coverEl) {
        console.error("朋友圈页面的头部元素不完整，无法渲染。");
        return;
    }

    // 1. 设置头像（使用我们之前优化的异步缓存函数）
    const avatarUrl = await getCachedAvatarUrl(profile.avatar);
    avatarEl.src = avatarUrl || defaultUserAvatar;

    // 2. 设置名字
    nameEl.textContent = profile.name || '我';

    // 3. 设置个性签名
    signatureEl.textContent = profile.signature || '点击设置个性签名';

    // 4. 设置封面图片
    if (profile.coverImage) {
        coverEl.style.backgroundImage = `url(${profile.coverImage})`;
    } else {
        // 如果没有设置封面，给一个默认的渐变色背景，更好看
        coverEl.style.backgroundImage = 'linear-gradient(45deg, #667eea, #764ba2)';
    }
}


// --- 【V2.0 功能修复 & SVG 图标版】，替换旧的 renderMePage 函数 ---
async function renderMePage() {
    const container = get('me-page-container');
    
    // 1. 异步获取用户头像的 Blob URL (这部分不变)
    const userAvatarUrl = await getCachedAvatarUrl(state.momentsProfile.avatar);
    const userName = state.momentsProfile.name || '我';

    // 2.【核心修改】使用全新的 HTML 结构，将 Emoji 替换为 SVG
    container.innerHTML = `
        <!-- (1) 顶部的个人信息卡片，加上了 ID 以便JS能找到它 -->
        <div id="me-profile-card" class="me-profile-card">
            <img class="me-avatar" src="${userAvatarUrl || defaultUserAvatar}" alt="用户头像">
            <div class="me-info">
                <span class="me-name">${userName}</span>
                <span class="me-id">点击可编辑个人资料</span>
            </div>
            <div class="chevron">
                <svg class="svg-icon"><use href="#icon-chevron-right"></use></svg>
            </div>
        </div>

        <!-- (2) 功能列表区域，使用 SVG 图标 -->
        <div class="me-section">
            <div class="me-list-item" data-action="wallet">
                <svg class="svg-icon me-item-icon" viewBox="0 0 24 24" fill="none" stroke="#34C759" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 18v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v1"></path>
                    <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0-6 0"></path>
                    <path d="M15.99 15.99L15 15"></path>
                </svg>
                <span>钱包</span>
            </div>
            <div class="me-list-item" data-action="favorites">
                 <svg class="svg-icon me-item-icon" viewBox="0 0 24 24" fill="none" stroke="#FF9500" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.77 5.82 22 7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                </svg>
                <span>收藏</span>
            </div>
        </div>

        <!-- 你也可以在这里添加更多功能区，例如“设置” -->
        <div class="me-section" style="margin-top: 24px;">
             <div class="me-list-item" data-action="settings">
                 <svg class="svg-icon me-item-icon" viewBox="0 0 24 24"><use href="#icon-settings"></use></svg>
                <span>设置</span>
            </div>
        </div>
    `;

    // 3. 【关键修复】在 HTML 渲染完成后，立刻为这张卡片绑定点击事件
    const profileCard = get('me-profile-card');
    if (profileCard) {
        profileCard.addEventListener('click', openMomentsProfileEditor);
    }

    // 4. (可选但推荐) 为其他按钮也绑定事件，虽然它们现在没功能，但这是个好习惯
    container.querySelectorAll('.me-list-item').forEach(item => {
        item.addEventListener('click', () => {
            const action = item.dataset.action;
            if (action === 'settings') {
                navigateTo('global-settings-page');
            } else {
                showToast(`功能 [${action}] 正在开发中...`);
            }
        });
    });
}



function openMomentsProfileEditor() {
    const modalHTML = `
        <h3>编辑朋友圈主页</h3>
        <div class="form-group">
            <label>你的名字</label>
            <input type="text" id="profile-name-input" value="${state.momentsProfile.name || '我'}">
        </div>
        <div class="form-group">
            <label>你的头像</label>
            <div class="avatar-upload-group">
                <img id="profile-avatar-preview" class="avatar-preview" src="${state.momentsProfile.avatar || defaultUserAvatar}">
                <label class="upload-btn">上传图片<input type="file" id="profile-avatar-input" accept="image/*" style="display:none;"></label>
            </div>
        </div>
        <div class="form-group">
            <label>个性签名</label>
            <input type="text" id="signature-input" value="${state.momentsProfile.signature}">
        </div>
        <div class="form-group">
            <label>更换封面</label>
            <div class="avatar-upload-group">
                <img id="cover-preview" class="avatar-preview" style="border-radius: 8px; width:100px; height:60px; object-fit:cover;" src="${state.momentsProfile.coverImage}">
                <label class="upload-btn">上传图片<input type="file" id="cover-upload-input" accept="image/*" style="display:none;"></label>
            </div>
        </div>
        <button id="save-profile-btn" class="btn btn-primary">保存</button>
    `;
    showModal(modalHTML);

    let newAvatarBase64 = state.momentsProfile.avatar;
    let newCoverBase64 = state.momentsProfile.coverImage;
    
    setupAvatarUpload('profile-avatar-input', 'profile-avatar-preview', (base64) => { newAvatarBase64 = base64; });
    setupAvatarUpload('cover-upload-input', 'cover-preview', (base64) => { newCoverBase64 = base64; });

    get('save-profile-btn').onclick = () => {
        const oldSignature = state.momentsProfile.signature;
        const newSignature = get('signature-input').value;

        // --- 新增逻辑：检查签名是否有实质性变化 ---
        if (newSignature.trim() !== oldSignature.trim()) {
            // 遍历所有聊天，为它们添加一个“未读的签名变更”事件
            state.chats.forEach(chat => {
                // 只为单聊AI角色添加此通知
                if (chat.type === 'single') { 
                    chat.unseenSignatureChange = {
                        old: oldSignature,
                        new: newSignature
                    };
                }
            });
            showToast('签名已更新，AI们会注意到哦！');
        }

        state.momentsProfile.name = get('profile-name-input').value;
        state.momentsProfile.avatar = newAvatarBase64;
        state.momentsProfile.signature = newSignature; // 更新签名
        state.momentsProfile.coverImage = newCoverBase64;
        
        saveState();
        renderMomentsHeader();
        hideModal();
    };
}
// ▼▼▼ 在 setupMomentsPage 函数附近新增此函数 ▼▼▼
// 【V2 修复版】使用自定义弹窗替换 prompt
function handleReplyToComment(momentId, commentId) {
    const moment = state.moments.find(m => m.id === momentId);
    if (!moment) return;
    const targetComment = moment.comments.find(c => c.id === commentId);
    if (!targetComment) return;

    // 步骤1：创建并显示带输入框的弹窗
    const modalHTML = `
        <h3>回复 @${targetComment.authorName}</h3>
        <div class="form-group">
            <textarea id="reply-input" placeholder="输入你的回复..."></textarea>
        </div>
        <button id="submit-reply-btn" class="btn btn-primary">回复</button>
    `;
    showModal(modalHTML);

    // 步骤2：为新弹窗的按钮绑定事件
    get('submit-reply-btn').onclick = () => {
        const replyText = get('reply-input').value.trim();
        if (replyText) {
            const newComment = {
                id: generateId('comment'),
                authorId: 'user',
                authorName: '我',
                content: replyText,
                replyTo: commentId // 记录回复的目标ID
            };
            moment.comments.push(newComment);
            saveState();
            hideModal();
            renderMomentsFeed(); // 重新渲染朋友圈
        } else {
            showToast('回复内容不能为空');
        }
    };
    
    // 让输入框回车也能提交 (体验优化)
    get('reply-input').onkeypress = (e) => {
        if(e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            get('submit-reply-btn').click();
        }
    };
}

// ▲▲▲ 新增函数结束 ▲▲▲

// 导航到朋友圈页面时触发渲染
function setupMomentsPage() {
    renderMomentsHeader();
    renderMomentsFeed(); // 渲染动态
    
    // --- 绑定页面固定按钮的事件 ---
    get('post-new-moment-btn').onclick = () => navigateTo('post-moment-page');
    get('moments-profile-header').onclick = openMomentsProfileEditor;

    // --- 【新增】使用事件委托统一处理动态列表内的所有点击事件 ---
    const feedContainer = get('moments-feed-container');

    // 先移除旧的监听器，防止重复绑定
    if (feedContainer.momentClickListener) {
        feedContainer.removeEventListener('click', feedContainer.momentClickListener);
    }

    // 定义一个统一的点击处理函数
    feedContainer.momentClickListener = (e) => {
        const target = e.target;
        
        // 1. 【全新升级】点击图片，弹出精美查看器
            const imageContainer = target.closest('.moment-image');
            if (imageContainer) {
                // (1) 从父元素找到 momentId，并获取完整的 moment 数据
                const momentCard = imageContainer.closest('.moment-card');
                if (!momentCard) return;
                
                const momentId = momentCard.dataset.momentId;
                const moment = state.moments.find(m => m.id === momentId);
                if (!moment) return;
        
                // (2) 如果有图片描述，就构建精美弹窗；如果没有，就什么都不做
                if (moment.imageDescription) {
                    // (3) 构建和聊天页面完全一样的 Instagram 风格弹窗 HTML
                    const modalHTML = `
                        <div class="ins-header">
                            <img src="${moment.authorAvatar}" alt="${moment.authorName} avatar">
                            <div class="ins-user-info">${moment.authorName}</div>
                            <div class="ins-close-btn" id="ins-viewer-close-btn">
                                <svg class="svg-icon"><use href="#icon-close"></use></svg>
                            </div>
                        </div>
                        <div class="ins-content-body">${moment.imageDescription}</div>
                        <div class="ins-footer">
                            <div class="ins-action-bar">
                                <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-heart"></use></svg></button>
                                <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-comment"></use></svg></button>
                                <button class="ins-action-btn"><svg class="svg-icon"><use href="#icon-send"></use></svg></button>
                                <button class="ins-action-btn bookmark"><svg class="svg-icon"><use href="#icon-bookmark"></use></svg></button>
                            </div>
                            <p class="ins-likes">来自朋友圈 <span>- ${new Date(moment.timestamp).toLocaleDateString()}</span></p>
                        </div>
                    `;
                    
                    // (4) 【关键】应用样式、显示弹窗、添加动画和关闭事件
                    modalContent.className = 'instagram-viewer-modal'; // 应用样式！
                    showModal(modalHTML);
                    get('ins-viewer-close-btn').addEventListener('click', hideModal);
                    setTimeout(() => modalContent.classList.add('show-animation'), 10);
                }
                return; // 处理完图片点击后，结束函数
            }
        
        // 2. 点击点赞按钮
        const likeBtn = target.closest('.like-btn');
        if (likeBtn) {
            handleLikeMoment(likeBtn.dataset.momentId);
            return;
        }

        // 3. 点击评论按钮
        const commentBtn = target.closest('.comment-btn');
        if (commentBtn) {
            handleCommentMoment(commentBtn.dataset.momentId);
            return;
        }

        // 4. 点击删除按钮
        const deleteBtn = target.closest('.moment-delete-btn');
        if (deleteBtn) {
            handleDeleteMoment(deleteBtn.dataset.momentId);
            return;
        }
		//5.回复
		const comment = target.closest('.moment-comment');
		    if (comment) {
		        // 确保点击的不是评论内的作者名链接等，而是评论本身
		        // （如果未来有更复杂的评论结构，这里可以加更精细的判断）
		        const momentCard = comment.closest('.moment-card');
		        if (momentCard) {
		            handleReplyToComment(momentCard.dataset.momentId, comment.dataset.commentId);
		        }
		        return;
		    }
    };

    // 绑定这个统一的监听器
    feedContainer.addEventListener('click', feedContainer.momentClickListener);
}

// --- 完整替换旧的 setupPostMomentPage 函数 ---
function setupPostMomentPage() {
    // 重置表单
    get('moment-text-input').value = '';
    get('moment-image-preview').src = '';
    get('moment-image-preview').style.display = 'none';
    get('moment-image-upload-label').dataset.imageData = '';

    // 图片上传逻辑
    const imageInput = get('moment-image-input');
    const imagePreview = get('moment-image-preview');
    const uploadLabel = get('moment-image-upload-label');
    const descGroup = get('moment-image-desc-group');

    imageInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        if (file.size > 10 * 1024 * 1024) { showToast('图片太大，请选择2MB以下的图片'); return; }
        const reader = new FileReader();
        reader.onload = (event) => {
            const base64String = event.target.result;
            imagePreview.src = base64String;
            imagePreview.style.display = 'block';
            uploadLabel.dataset.imageData = base64String;
            descGroup.style.display = 'block'; // **新功能：显示图片描述输入框**
        };
        reader.readAsDataURL(file);
    };

    // 发布按钮
    get('save-moment-btn').onclick = handlePostMoment;
}

// --- 完整替换旧的 handlePostMoment 函数 ---
function handlePostMoment() {
    const textContent = get('moment-text-input').value.trim();
    const imageDesc = get('moment-image-desc-input').value.trim();
    // 我们直接从预览图片的 src 获取数据，这更可靠
    const imagePreview = get('moment-image-preview');
    const imagePreviewSrc = imagePreview.style.display !== 'none' ? imagePreview.src : null;

    // 基本验证：文字和描述不能都为空
    if (!textContent && !imageDesc) {
        showToast('请分享点什么吧~');
        return;
    }

    const newMoment = {
        id: generateId('moment'),
        authorId: 'user',
        authorName: state.momentsProfile.name || '我',
        authorAvatar: state.momentsProfile.avatar || defaultUserAvatar,
        content: textContent,
        imageUrl: null,
        imageDescription: null,
        timestamp: new Date().toISOString(),
        likes: [],
        comments: []
    };

    // 【核心逻辑】判断图片和描述的状态
    // 1. 用户上传了本地图片 (通过判断 src 是否为 base64 数据)
    if (imagePreviewSrc && imagePreviewSrc.startsWith('data:image')) {
        newMoment.imageUrl = imagePreviewSrc;
        // 如果上传了图片，描述可以为空
        newMoment.imageDescription = imageDesc || ''; 
    } 
    // 2. 用户没上传图片，但写了描述
    else if (imageDesc) {
        newMoment.imageUrl = 'https://files.catbox.moe/608ojk.jpg'; // 使用你指定的默认图片
        newMoment.imageDescription = imageDesc;
    }
    // 3. 只有文字，则 imageUrl 和 imageDescription 保持 null

    state.moments.unshift(newMoment);
    saveState();
    showToast('发布成功');
    navigateBack();
    setupMomentsPage(); // 调用 setupMomentsPage 以确保所有事件监听器都刷新
}

// 渲染整个朋友圈 feed
async function renderMomentsFeed() {
    const container = get('moments-feed-container');
    container.innerHTML = '';

    if (state.moments.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--secondary-text); padding: 40px;">还没有任何动态，点击右上角发布第一条吧！</p>';
        return;
    }
    
    // Helper function to escape HTML attributes
    const escapeAttr = (str) => {
        if (!str) return '';
        return str.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    };

    for (const moment of state.moments) {
        const card = document.createElement('div');
        card.className = 'moment-card';
        card.dataset.momentId = moment.id;

        // --- 【核心修改】在这里处理图片和描述 ---
        let imageHtml = '';
        if (moment.imageUrl) {
            // 如果有描述，添加 data-description 属性和手型鼠标指针
            const descriptionAttr = moment.imageDescription 
                ? `data-description="${escapeAttr(moment.imageDescription)}"` 
                : '';
            const cursorStyle = moment.imageDescription ? 'cursor: pointer;' : '';
            
            imageHtml = `
                <div class="moment-image" ${descriptionAttr} style="${cursorStyle}">
                    <img src="${moment.imageUrl}" alt="朋友圈图片">
                </div>
            `;
        }
        // --- 修改结束 ---

        // (后面的时间、点赞、评论逻辑保持和你原来的一样)
        const postDate = new Date(moment.timestamp);
        const now = new Date();
        const diffSeconds = Math.round((now - postDate) / 1000);
        let timeAgo = '';
        if (diffSeconds < 60) timeAgo = `${diffSeconds}秒前`;
        else if (diffSeconds < 3600) timeAgo = `${Math.floor(diffSeconds / 60)}分钟前`;
        else if (diffSeconds < 86400) timeAgo = `${Math.floor(diffSeconds / 3600)}小时前`;
        else timeAgo = `${Math.floor(diffSeconds / 86400)}天前`;
        
        const likesText = moment.likes.map(l => l.authorName).join(', ');
        const likesHtml = moment.likes.length > 0 ? `
            <div class="moment-likes">
                <svg class="svg-icon"><use href="#icon-heart"></use></svg>
                <span>${likesText}</span>
            </div>` : '';

        // ▼▼▼ 这是 renderMomentsFeed 函数中被修改的部分 ▼▼▼
        const commentsHtml = moment.comments.map(c => {
            let commentContentHtml = '';
            // 【核心修改】检查是否存在 replyTo 字段
            if (c.replyTo) {
                const parentComment = moment.comments.find(p => p.id === c.replyTo);
                if (parentComment) {
                    // 如果找到了被回复的评论，就构建 "A 回复 B" 的格式
                    commentContentHtml = `
                        <span class="comment-author">${c.authorName}</span>
                        回复
                        <span class="replied-to-author">${parentComment.authorName}</span>: 
                        ${c.content}
                    `;
                } else {
                    // 如果因为某些原因没找到（比如原评论被删了），就按普通评论显示
                    commentContentHtml = `<span class="comment-author">${c.authorName}</span>: ${c.content}`;
                }
            } else {
                // 普通的顶级评论
                commentContentHtml = `<span class.author">${c.authorName}</span>: ${c.content}`;
            }
        
            return `<div class="moment-comment" data-comment-id="${c.id}">${commentContentHtml}</div>`;
        }).join('');
        // ▲▲▲ 修改结束 ▲▲▲
        
        const interactionsHtml = (likesHtml || commentsHtml) ? `
            <div class="moment-interactions">
                ${likesHtml}
                ${commentsHtml ? `<div class="moment-comments-container">${commentsHtml}</div>` : ''}
            </div>` : '';

        const userHasLiked = moment.likes.some(l => l.authorId === 'user');
        const avatarUrl = await getCachedAvatarUrl(moment.authorAvatar);

       card.innerHTML = `
             <button class="moment-delete-btn" data-moment-id="${moment.id}" title="删除此动态"><svg class="svg-icon"><use href="#icon-trash"></use></svg></button><div class="moment-header">
                <img src="${avatarUrl || (moment.authorId === 'user' ? defaultUserAvatar : defaultAiAvatar)}" class="avatar"><div class="info">
                    <div class="name">${moment.authorName}</div>
                    <div class="timestamp">${timeAgo}</div>
                </div>
            </div>
            <div class="moment-content">
                <p>${moment.content || ''}</p>
                ${imageHtml} 
            </div>
            <div class="moment-actions">
                <button class="moment-action-btn like-btn ${userHasLiked ? 'liked' : ''}" data-moment-id="${moment.id}">
                    <svg class="svg-icon"><use href="#icon-heart"></use></svg>
                    <span>${userHasLiked ? '已赞' : '赞'}</span>
                </button>
                <button class="moment-action-btn comment-btn" data-moment-id="${moment.id}">
                    <svg class="svg-icon"><use href="#icon-comment"></use></svg>
                    <span>评论</span>
                </button>
            </div>
            ${interactionsHtml}
        `;
        container.appendChild(card);
    }
}

// 处理点赞
function handleLikeMoment(momentId) {
    const moment = state.moments.find(m => m.id === momentId);
    if (!moment) return;
    
    const userLikeIndex = moment.likes.findIndex(l => l.authorId === 'user');
    
    if (userLikeIndex > -1) {
        // 取消点赞
        moment.likes.splice(userLikeIndex, 1);
    } else {
        // 点赞
        moment.likes.push({
            authorId: 'user',
            authorName: '我'
        });
    }
    
    saveState();
    renderMomentsFeed();
}

// 处理评论
function handleCommentMoment(momentId) {
    const moment = state.moments.find(m => m.id === momentId);
    if (!moment) return;
    const modalHTML = `
        <h3>发表评论</h3>
        <div class="form-group">
            <textarea id="comment-input" placeholder="留下你的想法..."></textarea>
        </div>
        <button id="submit-comment-btn" class="btn btn-primary">发表</button>
    `;
    showModal(modalHTML);
    get('submit-comment-btn').onclick = () => {
        const commentText = get('comment-input').value.trim();
        if (commentText) {
            moment.comments.push({
                id: generateId('comment'),
                authorId: 'user',
                authorName: '我',
                content: commentText
            });
            saveState();
            hideModal();
            renderMomentsFeed();
        }
    };
}

// 【V2 修复版】使用自定义弹窗替换 confirm
function handleDeleteMoment(momentId) {
    // 调用我们通用的确认弹窗
    showConfirmationModal('确定要删除这条动态吗？此操作不可撤销。', () => {
        // 用户点击“确定”后，执行这里的删除逻辑
        state.moments = state.moments.filter(m => m.id !== momentId);
        saveState();
        renderMomentsFeed(); // 重新渲染朋友圈以更新视图
        showToast('动态已删除');
    });
}


   function hideModal() {
       // 每次调用时都获取元素，更安全
       const modalOverlay = get('modal-overlay');
       const modalContent = get('modal-content');
       
       // 1. 移除动画类，让弹窗可以平滑消失（如果未来添加消失动画）
       modalContent.classList.remove('show-animation'); 
       
       // 2. 隐藏遮罩层，这是最核心的功能
       modalOverlay.style.display = 'none';
       
       // 3. 【最重要】重置内容容器的样式类
       // 这可以防止图片弹窗的 'instagram-viewer-modal' 样式影响到下一次打开的礼物弹窗
       modalContent.className = '';
       
       // 4. (可选但推荐) 清空内容，释放内存
       modalContent.innerHTML = '';
   }
   window.hideModal = hideModal;

    // --- 新增：聊天搜索功能逻辑 ---
    
    // 1. 打开搜索页面
    function openChatSearch() {
        get('chat-search-input').value = '';
        get('chat-search-results-container').innerHTML = `<p style="text-align:center; color: var(--secondary-text); padding: 40px;">输入关键词搜索此聊天的消息</p>`;
        navigateTo('chat-search-page');
    }
    
    // 2. 渲染搜索结果列表
    async function renderSearchResults(results, keyword) {
        const container = get('chat-search-results-container');
        const chat = state.chats.find(c => c.id === currentChatId);
    
        if (results.length === 0) {
            container.innerHTML = `<p style="text-align:center; color: var(--secondary-text); padding: 40px;">没有找到相关的消息</p>`;
            return;
        }
    
        // 使用 Promise.all 并行处理所有头像的异步获取，提高渲染速度
        const resultsHtmlPromises = results.reverse().map(async msg => {
            let name, avatarSrc;
            if (msg.role === 'user') {
                name = state.momentsProfile.name || '我';
                avatarSrc = chat.settings.user.avatar || defaultUserAvatar;
            } else {
                if (chat.type === 'group') {
                    const member = chat.settings.members.find(m => m.id === msg.memberId);
                    name = member ? member.name : '未知';
                    avatarSrc = member ? (member.avatar || defaultAiAvatar) : defaultAiAvatar;
                } else {
                    name = chat.settings.ai.name;
                    avatarSrc = chat.settings.ai.avatar || defaultAiAvatar;
                }
            }
            
            const avatarUrl = await getCachedAvatarUrl(avatarSrc);
            const date = new Date(msg.timestamp);
            const timestamp = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
            
            let contentText = '';
            if (typeof msg.content === 'string') {
                contentText = msg.content;
            } else if (msg.type === 'voice') {
                contentText = `[语音] ${msg.content}`;
            } else if (msg.type === 'file') {
                contentText = `[文件] ${msg.content.name}`;
            }
    
            const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
            const highlightedContent = contentText.replace(regex, '<mark>$&</mark>');
    
            return `
                <div class="search-result-item" data-msg-id="${msg.msgId}">
                    <img src="${avatarUrl}" class="avatar">
                    <div class="info">
                        <div class="header">
                            <span class="name">${name}</span>
                            <span class="timestamp">${timestamp}</span>
                        </div>
                        <div class="content">${highlightedContent}</div>
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = (await Promise.all(resultsHtmlPromises)).join('');
    }
    
    // 3. 高亮并滚动到指定消息的辅助函数
    function highlightAndScrollToMessage(element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        element.style.transition = 'background-color 0.5s ease';
        element.style.backgroundColor = 'rgba(255, 223, 186, 0.7)'; // 高亮颜色
        setTimeout(() => {
            element.style.backgroundColor = '';
        }, 2500); // 2.5秒后移除高亮
    }
    
    // 4. 绑定所有事件监听器

    get('chat-search-input').addEventListener('input', (e) => {
        const keyword = e.target.value.trim().toLowerCase();
        if (!keyword) {
            get('chat-search-results-container').innerHTML = `<p style="text-align:center; color: var(--secondary-text); padding: 40px;">输入关键词搜索此聊天的消息</p>`;
            return;
        }
    
        const chat = state.chats.find(c => c.id === currentChatId);
        if (!chat) return;
    
        const results = chat.messages.filter(msg => {
            if (typeof msg.content === 'string') return msg.content.toLowerCase().includes(keyword);
            if (msg.type === 'voice' && msg.content.text) return msg.content.text.toLowerCase().includes(keyword);
            if (msg.type === 'file') return msg.content.name.toLowerCase().includes(keyword);
            return false;
        });
    
        renderSearchResults(results, keyword);
    });
    
    get('chat-search-results-container').addEventListener('click', (e) => {
        const item = e.target.closest('.search-result-item');
        if (item) {
            // --- 【核心修复】在导航前，先让输入框失去焦点 ---
            // 这会触发浏览器“收起键盘”的行为，为页面返回做准备
            get('chat-search-input').blur();
            
            const targetId = item.dataset.msgId;
            navigateBack(); // 先返回聊天页面
    
            // 等待页面切换动画完成
            setTimeout(() => {
                const messagesContainer = get('chat-messages-container');
                let targetMessage = messagesContainer.querySelector(`[data-msg-id="${targetId}"]`);
                
                if (targetMessage) {
                    highlightAndScrollToMessage(targetMessage);
                } else {
                    // 如果消息没在当前屏幕，就加载所有消息再定位
                    renderChatMessages(true); 
                    targetMessage = messagesContainer.querySelector(`[data-msg-id="${targetId}"]`);
                    if(targetMessage) {
                        highlightAndScrollToMessage(targetMessage);
                    }
                }
            }, 400); // 400毫秒足够完成切换动画
        }
    });
    // --- 【全新】聊天操作菜单 (Action Sheet) 逻辑 ---

    const actionSheetOverlay = get('chat-action-sheet-overlay');
    const actionSheet = get('chat-action-sheet');
    const actionGrid = actionSheet.querySelector('.action-grid');

    // 1. --- Functions to show and hide the sheet ---
    function showChatActionSheet() {
        actionSheetOverlay.classList.add('show');
    }
    function hideChatActionSheet() {
        actionSheetOverlay.classList.remove('show');
    }

    // 2. --- Event Listeners to trigger the sheet ---
    get('show-actions-btn').addEventListener('click', showChatActionSheet);
    get('cancel-action-sheet').addEventListener('click', hideChatActionSheet);
    actionSheetOverlay.addEventListener('click', (e) => {
        if (e.target === actionSheetOverlay) {
            hideChatActionSheet();
        }
    });

    // 3. --- Main logic handler for clicks on action items (Event Delegation) ---
    actionGrid.addEventListener('click', (e) => {
        const actionItem = e.target.closest('.action-item');
        if (!actionItem) return;

        const action = actionItem.dataset.action;
        
        // Hide the sheet first, then show the specific modal
        hideChatActionSheet();
        
        // Use a short delay to allow the sheet to animate out before the modal appears
        setTimeout(() => {
            switch (action) {
                case 'voice': handleSendVoice(); break;
                case 'file': handleSendFile(); break;
                case 'image': handleSendImage(); break;
                case 'transfer': handleSendTransfer(); break;
                case 'gift': handleSendGift(); break;
				case 'sticker': openStickerLibrary(); break;
                case 'location': handleSendLocation(); break;
				case 'voice_call': startCall('voice'); break; // 新增
				case 'video_call': startCall('video'); break; // 新增
				case 'pet_house':openPetHouse();break;
				case 'offline_scene':
				    startOfflineScene();
				    break;
            }
        }, 300);
    });

    // 4. --- Individual handler functions for each action ---

    function handleSendVoice() {
        const modalHTML = `
            <h3>发送语音</h3>
            <div class="form-group">
                <label for="voice-text-input">语音文字稿</label>
                <input type="text" id="voice-text-input" placeholder="语音描述">
            </div>
            <div class="form-group">
                <label for="voice-duration-input">语音秒数 (1-60)</label>
                <input type="number" id="voice-duration-input" value="10" min="1" max="60">
            </div>
            <button id="confirm-send-voice" class="btn btn-primary">发送</button>
        `;
        showModal(modalHTML);
    
        get('confirm-send-voice').onclick = () => {
            const desc = get('voice-text-input').value.trim();
            const duration = parseInt(get('voice-duration-input').value);
            
            if (!desc) return showToast("文字稿不能为空");
            if (isNaN(duration) || duration < 1 || duration > 60) return showToast("请输入1-60之间的有效秒数");
    
            const voiceContent = { text: desc, duration: duration };
            saveMessage('user', voiceContent, 'voice');
            hideModal();
            showToast('语音消息已发送');
        };
    }


    function handleSendFile() {
        const modalHTML = `
            <h3>发送文件</h3>
            <div class="form-group"><label>文件名</label><input type="text" id="file-name-input" placeholder="例如: project-notes.txt"></div>
            <div class="form-group"><label>文件内容</label><textarea id="file-content-input" placeholder="输入文件的文本内容..." style="min-height: 120px;"></textarea></div>
            <div class="form-group"><label>文件大小</label><input type="text" id="file-size-input" placeholder="例如: 2.5 KB"></div>
            <button id="confirm-send-file" class="btn btn-primary">发送</button>
        `;
        showModal(modalHTML);
        get('confirm-send-file').onclick = () => {
            const name = get('file-name-input').value.trim();
            const body = get('file-content-input').value;
            const size = get('file-size-input').value.trim();
            if (!name || !body) return showToast('文件名和内容不能为空');
            
            const fileContent = { name, body, size: size || '未知大小' };
            saveMessage('user', fileContent, 'file');
            hideModal();
            showToast('文件已发送');
        };
    }
    
    function handleSendImage() {
        // [保持不变] 弹窗HTML，包含两个按钮
        const modalHTML = `
            <h3>发送图片</h3>
            <p>请选择发送方式：</p>
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button id="send-image-desc-btn" class="btn btn-primary" style="flex: 1; margin: 0;">通过文字描述</button>
                <label for="send-image-upload-input" class="btn btn-secondary" style="flex: 1; margin: 0;">从本地上传</label>
            </div>
            <input type="file" id="send-image-upload-input" accept="image/*" style="display:none;">
        `;
        showModal(modalHTML);
    
        // [行为一] 处理“通过文字描述”按钮
        get('send-image-desc-btn').onclick = () => {
            // 先关闭选择弹窗
            hideModal();
            // 稍后打开描述输入弹窗
            setTimeout(() => {
                const descModalHTML = `
                    <h3>输入图片描述</h3>
                    <div class="form-group">
                        <textarea id="image-desc-input" placeholder="例如：一只懒洋洋的猫在晒太阳"></textarea>
                    </div>
                    <button id="confirm-send-desc" class="btn btn-primary">确定</button>
                `;
                showModal(descModalHTML);
                get('confirm-send-desc').onclick = () => {
                    const desc = get('image-desc-input').value.trim();
                    if (!desc) return showToast('描述不能为空');
                    const imageContent = { url: 'https://files.catbox.moe/608ojk.jpg', description: desc };
                    saveMessage('user', imageContent, 'image');
                    hideModal();
                    showToast('图片（描述）已发送');
                };
            }, 200);
        };

    
        // [行为二] 处理“从本地上传”按钮
        get('send-image-upload-input').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (file.size > 10 * 1024 * 1024) { 
                showToast('图片太大，请选择4MB以下的图片');
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const base64String = event.target.result;
                
                // 【核心修改】上传的图片，description留空，让AI去识别
                const imageContent = { url: base64String, description: "" }; 
                saveMessage('user', imageContent, 'image');
                hideModal();
                showToast('图片已发送，请点击“发送”按钮让AI进行识别');
            };
            reader.readAsDataURL(file);
        };
    }

    function handleSendTransfer() {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (!chat) return;
    
        // 【核心判断】如果是群聊，则先选择收礼人
        if (chat.type === 'group') {
            const members = [
                { id: 'user', name: state.momentsProfile.name || '我' }, 
                ...chat.settings.members
            ];
            
            const memberOptionsHtml = members.map(m => 
                `<div class="list-item" data-id="${m.id}" data-name="${m.name}" style="cursor:pointer;">${m.name}</div>`
            ).join('');
    
            showModal(`
                <h3>选择收款人</h3>
                <div class="list-view">${memberOptionsHtml}</div>
            `);
    
            // 为列表项添加点击事件
            document.querySelector('#modal-content .list-view').addEventListener('click', (e) => {
                const target = e.target.closest('.list-item');
                if (target) {
                    const recipientId = target.dataset.id;
                    const recipientName = target.dataset.name;
                    // 选择后，再弹出金额信息框
                    showTransferCreationModal(recipientId, recipientName);
                }
            });
        } else {
            // 如果是单聊，直接弹出金额信息框，收款人就是对方
            showTransferCreationModal(chat.id, chat.settings.ai.name);
        }
    }
    
    // 【新增辅助函数】将转账创建弹窗逻辑抽离出来
    function showTransferCreationModal(recipientId, recipientName) {
        const modalHTML = `
            <h3>转账给 ${recipientName}</h3>
            <div class="form-group"><label>金额 (¥)</label><input type="number" id="transfer-amount-input" placeholder="0.00"></div>
            <div class="form-group"><label>备注</label><input type="text" id="transfer-message-input" placeholder="(可选)"></div>
            <button id="confirm-send-transfer" class="btn btn-primary">发送</button>
        `;
        showModal(modalHTML);
    
        get('confirm-send-transfer').onclick = () => {
            const amount = parseFloat(get('transfer-amount-input').value).toFixed(2);
            if (isNaN(amount) || amount <= 0) return showToast('请输入有效的金额');
            const message = get('transfer-message-input').value.trim();
            
            const transferContent = { 
                amount, 
                message, 
                id: generateId('userTxn'), 
                status: 'sent',
                recipientId: recipientId, 
                recipientName: recipientName 
            };
            saveMessage('user', transferContent, 'transfer');
            hideModal();
            showToast('转账已发送');
        };
    }
    
    function handleSendGift() {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (!chat) return;
    
        // 【核心判断】如果是群聊，则先选择收礼人
        if (chat.type === 'group') {
            // 构造一个包含所有成员（包括用户自己）的列表
            const members = [
                { id: 'user', name: state.momentsProfile.name || '我' }, 
                ...chat.settings.members
            ];
            
            const memberOptionsHtml = members.map(m => 
                `<div class="list-item" data-id="${m.id}" data-name="${m.name}" style="cursor:pointer;">${m.name}</div>`
            ).join('');
    
            showModal(`
                <h3>选择收礼人</h3>
                <div class="list-view">${memberOptionsHtml}</div>
            `);
    
            // 为列表项添加点击事件
            document.querySelector('#modal-content .list-view').addEventListener('click', (e) => {
                const target = e.target.closest('.list-item');
                if (target) {
                    const recipientId = target.dataset.id;
                    const recipientName = target.dataset.name;
                    // 选择后，再弹出礼物信息框
                    showGiftCreationModal(recipientId, recipientName);
                }
            });
        } else {
            // 如果是单聊，直接弹出礼物信息框，收礼人就是对方
            showGiftCreationModal(chat.id, chat.settings.ai.name);
        }
    }
    
    // 【新增辅助函数】将礼物创建弹窗逻辑抽离出来
    function showGiftCreationModal(recipientId, recipientName) {
        const modalHTML = `
            <h3>送礼物给 ${recipientName}</h3>
            <div class="form-group"><label>礼物名称</label><input type="text" id="gift-name-input" placeholder="例如: 一束玫瑰"></div>
            <div class="form-group"><label>礼物描述</label><input type="text" id="gift-desc-input" placeholder="例如: 鲜艳的红玫瑰"></div>
            <div class="form-group"><label>留言</label><input type="text" id="gift-message-input" placeholder="(可选)"></div>
            <button id="confirm-send-gift" class="btn btn-primary">发送</button>
        `;
        showModal(modalHTML);
    
        get('confirm-send-gift').onclick = () => {
            const name = get('gift-name-input').value.trim();
            if (!name) return showToast('礼物名称不能为空');
            const description = get('gift-desc-input').value.trim();
            const message = get('gift-message-input').value.trim();
            
            // 【核心修改】在礼物内容中加入接收者信息
            const giftContent = { 
                name, description, message, 
                id: generateId('userGift'), 
                status: 'sent',
                recipientId: recipientId, 
                recipientName: recipientName 
            };
            saveMessage('user', giftContent, 'gift');
            hideModal();
            showToast('礼物已发送');
        };
    }
	
   // 【V2 修复版】使用自定义弹窗替换 prompt
   function handleSendLocation() {
       // 步骤1：创建并显示带输入框的弹窗
       const modalHTML = `
           <h3>分享位置</h3>
           <div class="form-group">
               <label for="location-input">输入地址或位置名称：</label>
               <input type="text" id="location-input" placeholder="例如：市中心图书馆">
           </div>
           <button id="confirm-send-location" class="btn btn-primary">发送</button>
       `;
       showModal(modalHTML);
   
       // 步骤2：为新弹窗的按钮绑定事件
       get('confirm-send-location').onclick = () => {
           const address = get('location-input').value.trim();
           if (address) {
               saveMessage('user', { address: address }, 'location');
               hideModal();
               showToast('位置已发送');
           } else {
               showToast('位置名称不能为空');
           }
       };
   
       // 让输入框回车也能提交 (体验优化)
       get('location-input').onkeypress = (e) => {
           if(e.key === 'Enter') {
               get('confirm-send-location').click();
           }
       };
   }

	
	
		// ==========================================================
		// --- 【V3.0 终极弹窗交互版】表情包 (Sticker) 功能逻辑 ---
		// ==========================================================
		
		let stickerFileBase64 = null;
	
		// 1. 打开主表情包库 (只负责展示)
		function openStickerLibrary() {
		    const overlay = get('sticker-library-overlay');
		    renderStickerGrid();
		    overlay.classList.add('show');
		}
	
		// 2. 渲染表情包网格 (和之前一样，带删除功能)
		function renderStickerGrid() {
		    const container = get('sticker-grid-container');
		    container.innerHTML = state.stickerLibrary.map(sticker => `
		        <div class="sticker-item" 
		             style="background-image: url(${sticker.url})" 
		             data-sticker-id="${sticker.id}" 
		             title="${sticker.description}">
		             <div class="delete-overlay" data-action="delete" title="删除表情">🗑️</div>
		        </div>
		    `).join('');
		}
	
		// 3. 关闭主表情包库
		function closeStickerLibrary() {
		    get('sticker-library-overlay').classList.remove('show');
		}
	
		// 4. 【全新】弹出“添加单个表情”的专用弹窗
		function showSingleStickerAddModal() {
		    stickerFileBase64 = null; // 每次打开都重置
		    const modalHTML = `
		        <h3>添加单个表情</h3>
		        <div class="form-group">
		            <label for="single-sticker-url-input">图片 URL (或从下方上传)</label>
		            <input type="text" id="single-sticker-url-input" placeholder="http://...">
		        </div>
		        <div class="form-group">
		            <label for="single-sticker-desc-input">表情描述 (必填)</label>
		            <input type="text" id="single-sticker-desc-input" placeholder="例如：一个猫猫头在说“好耶”">
		        </div>
		        <div style="display:flex; gap:10px;">
		            <label for="single-sticker-upload-input" class="btn btn-secondary" style="flex:1; margin:0;">选择本地文件</label>
		            <button id="confirm-save-single-sticker" class="btn btn-primary" style="flex:1; margin:0;">保存</button>
		        </div>
		        <input type="file" id="single-sticker-upload-input" accept="image/*" style="display:none;">
		    `;
		    showModal(modalHTML); // 复用你的通用弹窗
	
		    // 绑定这个新弹窗内的事件
		    get('single-sticker-upload-input').onchange = (e) => {
		        const file = e.target.files[0];
		        if (!file) return;
		        if (file.size > 2 * 1024 * 1024) return showToast('图片文件请小于 2MB');
		        const reader = new FileReader();
		        reader.onload = event => {
		            stickerFileBase64 = event.target.result;
		            get('single-sticker-url-input').value = `已选择: ${file.name}`;
		            get('single-sticker-url-input').disabled = true;
		        };
		        reader.readAsDataURL(file);
		    };
	
		    get('confirm-save-single-sticker').onclick = () => {
		        const description = get('single-sticker-desc-input').value.trim();
		        const url = get('single-sticker-url-input').value.trim();
		        if (!description) return showToast('必须为表情包添加描述');
		        
		        const finalUrl = stickerFileBase64 || url;
		        if (!finalUrl || finalUrl.startsWith('已选择:')) return showToast('请提供 URL 或上传本地文件');
	
		        state.stickerLibrary.push({ id: generateId('sticker'), url: finalUrl, description });
		        saveState();
		        showToast('表情包已添加！');
		        hideModal();
		        renderStickerGrid(); // 刷新主库
		    };
		}
	
		// 5. 【全新】弹出“批量添加”的专用弹窗 (逻辑与上次相同，现在它有了自己的家)
		function showBatchStickerUploadModal() {
		    const modalHTML = `
		        <h3>批量添加表情包</h3>
		        <p style="font-size: 14px; color: var(--secondary-text); margin-bottom: 10px;">
		            请按格式输入: <b>图片URL,表情描述</b><br>
		            每个表情占一行，URL和描述用英文逗号隔开。
		        </p>
		        <div class="form-group">
		            <textarea id="batch-sticker-urls-input" placeholder="https://.../happy.png,开心\nhttps://.../sad.gif,难过" style="min-height: 200px;"></textarea>
		        </div>
		        <button id="confirm-batch-add-btn" class="btn btn-primary" style="width: 100%;">确认添加</button>
		    `;
		    showModal(modalHTML);
	
		    get('confirm-batch-add-btn').onclick = () => {
		        const inputText = get('batch-sticker-urls-input').value.trim();
		        if (!inputText) return showToast('输入内容不能为空');
	
		        const lines = inputText.split('\n');
		        const newStickers = [];
		        const failedLines = [];
	
		        lines.forEach((line, index) => {
		            line = line.trim();
		            if (!line) return;
		            const parts = line.split(',');
		            const url = parts[0]?.trim();
		            const description = parts.slice(1).join(',').trim(); 
		            if (url && url.startsWith('http') && description) {
		                newStickers.push({ id: generateId('sticker'), url, description });
		            } else {
		                failedLines.push(index + 1); 
		            }
		        });
	
		        if (newStickers.length > 0) {
		            state.stickerLibrary.push(...newStickers);
		            saveState();
		            renderStickerGrid();
		        }
	
		        if (failedLines.length > 0) {
		            showToast(`成功 ${newStickers.length} 个, 失败 ${failedLines.length} 行。`, 4000);
		        } else if (newStickers.length > 0) {
		            showToast(`成功批量添加了 ${newStickers.length} 个新表情包！`);
		        } else {
		            showToast('没有找到任何格式正确的内容。');
		        }
	
		        if (newStickers.length > 0) hideModal();
		    };
		}
	
		// 6. 【重构】绑定所有入口和交互事件
		function setupStickerLibraryListeners() {
		    // 主弹窗的关闭和添加按钮
		    get('sticker-close-btn').addEventListener('click', closeStickerLibrary);
		    get('add-single-sticker-btn').addEventListener('click', () => {
	            closeStickerLibrary();
	            setTimeout(showSingleStickerAddModal, 250);
	        });
		    get('batch-add-sticker-btn').addEventListener('click', () => {
	            closeStickerLibrary();
	            setTimeout(showBatchStickerUploadModal, 250);
	        });
		    
		    // 表情网格的事件委托 (发送 与 删除)
		    get('sticker-grid-container').addEventListener('click', e => {
		        const item = e.target.closest('.sticker-item');
		        if (!item) return;
		        
		        const stickerId = item.dataset.stickerId;
		        const action = e.target.dataset.action;
	
		        if (action === 'delete') {
		            e.stopPropagation();
		            showConfirmationModal('确定要删除这个表情包吗？', () => {
	                    state.stickerLibrary = state.stickerLibrary.filter(s => s.id !== stickerId);
	                    saveState();
	                    renderStickerGrid();
	                });
		        } else {
		            saveMessage('user', stickerId, 'sticker');
		            closeStickerLibrary();
		        }
		    });
		}


	
	// --- 【全新】语音/视频通话功能逻辑 ---
	let isCallMuted = false;
	let callTimerInterval = null;
	let currentCallType = null;
	let synthesis = window.speechSynthesis; // 获取语音合成接口
	let currentCallTranscript = []; 
	
// 1. 开始通话 (V3 稳定版)
function startCall(type) {
    const chat = state.chats.find(c => c.id === currentChatId);
    if (!chat || chat.type !== 'single') {
        showToast("此功能仅在单人聊天中可用");
        return;
    }
    
    currentCallType = type;
    currentCallTranscript = [];
    get('call-history-log').innerHTML = '';
    
    const callPage = get('call-page');
    get('call-name').textContent = chat.settings.ai.name;
    get('call-avatar').src = chat.settings.ai.avatar || defaultAiAvatar;
    
    if (type === 'voice') {
        callPage.classList.remove('video-mode');
        get('call-background').style.backgroundImage = 'none';
    } else {
        callPage.classList.add('video-mode');
        const initialImage = chat.settings.ai.videoCallImages[0]?.url || chat.settings.ai.avatar || defaultAiAvatar;
        get('call-background').style.backgroundImage = `url(${initialImage})`;
    }

    get('call-status').textContent = '正在连接...';
    setTimeout(() => {
        let seconds = 0;
        get('call-status').textContent = '通话中 00:00';
        callTimerInterval = setInterval(() => {
            seconds++;
            const min = String(Math.floor(seconds / 60)).padStart(2, '0');
            const sec = String(seconds % 60).padStart(2, '0');
            get('call-status').textContent = `通话中 ${min}:${sec}`;
        }, 1000);
    }, 1500 + Math.random() * 1000);
    
    // ▼▼▼ 在导航到页面之前，先设置好所有事件监听 ▼▼▼
    setupCallPageListeners();
    navigateTo('call-page');
}

	
// 【V6 稳定版】替换你原来的 hangupCall 函数
function hangupCall() {
    // 停止计时器
    if (callTimerInterval) {
        clearInterval(callTimerInterval);
        callTimerInterval = null; // 清理
    }

    // 停止语音
    try {
        if (synthesis && synthesis.speaking) {
            synthesis.cancel();
        }
    } catch (e) {
        console.warn("停止语音时出错: ", e);
    }
    
    // --- 核心逻辑：保存通话记录 ---
    const statusText = get('call-status')?.textContent || '';
    const timeMatch = statusText.match(/(\d{2}):(\d{2})/);
    const callDurationSeconds = timeMatch ? parseInt(timeMatch[1], 10) * 60 + parseInt(timeMatch[2], 10) : 0;

    if (callDurationSeconds > 0 && currentCallTranscript.length > 0) {
        const chat = state.chats.find(c => c.id === currentChatId);
        if (chat) {
            const summaryMessage = {
                msgId: generateId('msg'),
                role: 'system',
                type: 'call_summary',
                content: { 
                    duration: callDurationSeconds, 
                    callType: currentCallType,
                    transcript: [...currentCallTranscript] // 复制一份副本
                },
                timestamp: new Date().toISOString()
            };
            
            chat.messages.push(summaryMessage);
            chat.lastUpdated = new Date().toISOString();
            saveState(); // 保存状态
        }
    }
    
    // 清理状态
    currentCallType = null;
    currentCallTranscript = [];
    isCallMuted = false;
    get('call-input-wrapper').style.display = 'none';

    // --- 最后再执行页面导航 ---
    navigateBack();

    // 在页面切换后，确保聊天列表和消息被刷新
    setTimeout(() => {
        renderChatList();
        if (get('chat-page').classList.contains('active')) {
            renderChatMessages(true);
            const container = get('chat-messages-container');
            if(container) container.scrollTop = container.scrollHeight;
        }
    }, 350); // 等待导航动画完成
}

// 3. 在通话中发送消息给 AI (完整增强版)
async function sendCallMessage() {
    const input = get('call-input');
    const text = input.value.trim();
    if (!text) return;
	addMessageToCallHistory('user', text); 
	currentCallTranscript.push({ role: 'user', content: text });

    input.value = '';
    
    const chat = state.chats.find(c => c.id === currentChatId);
    if (!chat) {
        showToast("错误：找不到当前聊天");
        return;
    }

    // --- 【新增】在通话前，先检查并获取 API 配置 ---
    const { currentApiId, savedApis } = state.apiSettings;
    const currentApi = savedApis.find(api => api.id === currentApiId);
    if (!currentApi || !currentApi.url || !currentApi.key || !currentApi.model) {
        showToast("API 未配置或未选择模型，请前往设置");
        return;
    }

    try {
        // --- 1. 构建聊天记录上下文 (完整版) ---
        const memoryDepth = chat.settings.memoryDepth || 12;
        const recentMessages = chat.messages.slice(-memoryDepth).map(m => {
            let content = '';
            // 将各种消息类型转换为 AI 能理解的纯文本
            switch (m.type) {
                case 'text':
                    content = m.content;
                    break;
                case 'image':
                    content = `[图片消息，描述: '${m.content.description || '无'}']`;
                    break;
                case 'sticker':
                    const sticker = state.stickerLibrary.find(s => s.id === m.content);
                    content = `[表情包: '${sticker ? sticker.description : '未知'}']`;
                    break;
                case 'voice':
                    content = `[语音消息: '${m.content.text}']`;
                    break;
                case 'file':
                    content = `[文件消息: '${m.content.name}']`;
                    break;
                case 'transfer':
                    content = `[转账消息: 金额 ¥${m.content.amount}, 状态: ${m.content.status}]`;
                    break;
                case 'gift':
                    content = `[礼物消息: '${m.content.name}', 状态: ${m.content.status}]`;
                    break;
                case 'location':
                    content = `[位置消息: '${m.content.address}']`;
                    break;
                case 'fanfic_share':
                    content = `[文章分享: '${m.content.title}']`;
                    break;
                case 'forwarded_record':
                    content = `[转发的聊天记录]`;
                    break;
                case 'retracted':
                case 'ai_retracted':
                    content = `[一条消息被撤回]`;
                    break;
				case 'scene_summary':
            const summarySnippet = m.content.storyText.substring(0, 400); // 截取故事摘要
            content = `[系统提示(最高优先级)：我们刚刚结束了一段线下互动，故事的简要回顾是：“...${summarySnippet}”。现在我们正在通话，请基于这段共同经历继续对话。]`;
            break;
            
        // (原有的 call_summary case 在这里可以简化，因为通话中不会有上一次的通话记录)
        case 'call_summary':
            const duration = m.content.duration;
            const min = String(Math.floor(duration / 60)).padStart(2, '0');
            const sec = String(duration % 60).padStart(2, '0');
            content = `[通话回顾: 我们之前通过一次电话，聊了 ${min}:${sec}。]`;
            break;
                default:
                    content = `[${m.type || '未知类型'}消息]`;
            }
            return {
                role: m.role === 'ai' ? 'assistant' : 'user',
                content: content
            };
        });
        const chatHistoryContext = recentMessages.map(m => `${m.role === 'user' ? '用户' : '你'}: ${m.content}`).join('\n');
		//
		let callTranscriptContext = '这是通话的开始。';
		if (currentCallTranscript.length > 0) {
		    callTranscriptContext = '以下是当前这通电话已经发生的对话记录：\n' +
		    currentCallTranscript.map(log => {
		        const speaker = log.role === 'user' ? '用户' : '你';
		        return `${speaker}: "${log.content}"`;
		    }).join('\n');
		}

        // --- 2. 构建视频形象上下文 ---
        let videoImagesContext = '该角色没有可用的视频形象。';
        if (chat.settings.ai.videoCallImages && chat.settings.ai.videoCallImages.length > 0) {
            videoImagesContext = '该角色拥有以下视频通话形象，你可以根据回复的情绪选择一个使用：\n' +
            chat.settings.ai.videoCallImages.map(img => `- [${img.emotion}]: ${img.description}`).join('\n');
        }
        
        // --- 3. 构建完整的 System Prompt ---
        const callSystemPrompt = `你正在与用户进行一场实时的【${currentCallType === 'voice' ? '语音' : '视频'}通话】。
你的回复必须严格遵守以下规则：
1.  你的回复必须是一段**口语化**的话语。
2.  **【最重要】** 你的输出格式必须是：[SET_IMAGE:情绪关键词]你的回复文本。
    -   \`[SET_IMAGE:...]\` 是给系统的指令。
    -   情绪关键词必须从下面的可用形象列表中选择。
    -   如果是语音通话，或不想切换形象，请使用 \`[SET_IMAGE:无]\`。
3.  完全代入你的人设进行对话。
4.  **你要参考下面的聊天记录，确保通话内容和之前的聊天是连贯的。**

# 最近的聊天记录:
${chatHistoryContext}

# 你的人设:
${chat.settings.ai.persona}

# 可用的视频形象列表:
${videoImagesContext}

# 当前通话记录 (高优先级):
${callTranscriptContext}

现在，请接着上面的聊天记录，回应用户在通话中说的第一句话。
# 用户刚刚说:
${text}`;

        // --- 4. 发起 API 请求 ---
        let requestUrl = currentApi.url.trim();
        if (requestUrl.endsWith('/')) requestUrl = requestUrl.slice(0, -1);
        requestUrl = `${requestUrl}/v1/chat/completions`;

        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${currentApi.key}` },
            body: JSON.stringify({
                model: currentApi.model,
                messages: [
                    { role: 'system', content: callSystemPrompt },
                    // 注意：在通话中，我们不需要发送完整的历史记录，因为prompt里已经包含了
                    { role: 'user', content: text } 
                ]
            })
        });

        if (!response.ok) throw new Error(`API 请求失败: ${response.status} ${response.statusText}`);
        
        const data = await response.json();
        const aiResponseText = data.choices[0].message.content;

        // --- 5. 解析和处理 AI 回复 ---
        const imageMatch = aiResponseText.match(/^\[SET_IMAGE:(.+?)\]/);
        let spokenText = aiResponseText;

        if (imageMatch) {
            const emotion = imageMatch[1];
            spokenText = aiResponseText.substring(imageMatch[0].length).trim();
            
            if (currentCallType === 'video' && emotion !== '无') {
                const image = chat.settings.ai.videoCallImages.find(img => img.emotion === emotion);
                if (image) {
                    const bg = get('call-background');
                    // 使用图片预加载技术，实现平滑过渡
                    const tempImg = new Image();
                    tempImg.src = image.url;
                    tempImg.onload = () => {
                        bg.style.opacity = 0;
                        setTimeout(() => {
                            bg.style.backgroundImage = `url(${image.url})`;
                            bg.style.opacity = 1;
                        }, 500); // 等待淡出动画完成
                    }
                }
            }
        }
        
         // --- 6. 显示和播放 AI 的回复 ---
                if (spokenText) {
                   addMessageToCallHistory('ai', spokenText);
                   currentCallTranscript.push({ role: 'ai', content: spokenText });
                   if (!isCallMuted) {
                       const utterance = new SpeechSynthesisUtterance(spokenText);
                       utterance.lang = 'zh-CN';
                       const chat = state.chats.find(c => c.id === currentChatId);
                       if (chat && chat.settings.ai.voiceURI && chat.settings.ai.voiceURI !== 'default') {
                           const selectedVoice = availableVoices.find(v => v.voiceURI === chat.settings.ai.voiceURI);
                           if (selectedVoice) {
                               utterance.voice = selectedVoice;
                           }
                       }
                       synthesis.speak(utterance);
                   }
                }
            // 这是 try 块的正确结束位置
            } catch (error) {
                // catch 块必须紧跟在 try 块之后
                console.error("通话中API调用失败:", error);
                showToast(`通话错误: ${error.message}`);
                const utterance = new SpeechSynthesisUtterance("抱歉，我的网络好像出了一点问题。");
                utterance.lang = 'zh-CN';
                synthesis.speak(utterance);
            }
        // 这是 sendCallMessage 函数的正确结束位置
        }
// 【V5 终极稳定版】替换你原来的 setupCallPageListeners
function setupCallPageListeners() {
    const callPage = get('call-page');
    if (!callPage) return;

    // --- 步骤一：为关键按钮进行【直接、可靠】的事件绑定 ---
    // 每次调用此函数时，都会重新获取按钮并绑定事件，确保万无一失
    const hangupBtn = get('call-hangup-wrapper');
    if (hangupBtn) {
        // 先移除旧的监听器，防止重复绑定
        hangupBtn.replaceWith(hangupBtn.cloneNode(true));
        get('call-hangup-wrapper').addEventListener('click', hangupCall);
    }
    
    // --- 步骤二：使用事件委托处理其他非关键按钮 ---
    // 这个监听器只绑定一次，后续不再重复添加
    if (!callPage.dataset.delegated) {
        callPage.addEventListener('click', (e) => {
            const target = e.target;
            const actionTarget = target.closest('[data-call-action]');

            if (!actionTarget) return;

            const action = actionTarget.dataset.callAction;
            
            switch(action) {
                case 'send':
                    sendCallMessage();
                    break;
                case 'toggle-input':
                    const wrapper = get('call-input-wrapper');
                    if (wrapper) wrapper.style.display = (wrapper.style.display === 'flex') ? 'none' : 'flex';
                    break;
                case 'toggle-mute':
                    isCallMuted = !isCallMuted;
                    const muteIcon = get('call-mute-icon');
                    const muteLabel = get('call-mute-label');
                    if (!muteIcon || !muteLabel) return;
        
                    if (isCallMuted) {
                        try { synthesis.cancel(); } catch (err) {}
                        muteIcon.innerHTML = `<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15" stroke-width="2.5"></line><line x1="17" y1="9" x2="23" y2="15" stroke-width="2.5"></line>`;
                        muteLabel.textContent = '取消静音';
                        showToast('已静音');
                    } else {
                        muteIcon.innerHTML = `<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>`;
                        muteLabel.textContent = '静音';
                        showToast('已取消静音');
                    }
                    break;
            }
        });

        // 打上标记，表示已经委托过了
        callPage.dataset.delegated = 'true';
    }

    // --- 步骤三：为输入框绑定独立事件 ---
    const callInput = get('call-input');
    if (callInput) { 
        callInput.onkeypress = (e) => { 
            if(e.key === 'Enter') {
                e.preventDefault();
                sendCallMessage();
            }
        }; 
    }
}

	// --- 【全新】AI 主动来电功能逻辑 ---
	
	let incomingCallType = null;
	let incomingCallFromChatId = null;
	
	// 1. 触发来电界面
	// 1. 触发来电界面 (V2 安全版)
	function triggerIncomingCall(type) {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat) return;
	
	    // VVVV 新增的安全检查 VVVV
	    const overlay = get('incoming-call-overlay');
	    const ringtone = get('ringtone');
	    const background = get('incoming-call-background');
	    const avatar = get('incoming-call-avatar');
	    const nameEl = get('incoming-call-name');
	    const typeEl = get('incoming-call-type');
	
	    // 如果任何一个关键UI元素不存在，就直接退出，防止报错
	    if (!overlay || !ringtone || !background || !avatar || !nameEl || !typeEl) {
	        console.error("来电界面UI元素不完整，无法触发来电。请检查HTML部分。");
	        return; 
	    }
	    // ^^^^ 安全检查结束 ^^^^
	
	    incomingCallType = type;
	    incomingCallFromChatId = chat.id;
	
	    // 填充来电信息
	    avatar.src = chat.settings.ai.avatar || defaultAiAvatar;
	    nameEl.textContent = chat.settings.ai.name;
	    typeEl.textContent = `邀请你进行${type === 'voice' ? '语音' : '视频'}通话...`;
	    
	    const bgImage = (type === 'video' && chat.settings.ai.videoCallImages[0]?.url) 
	                    ? chat.settings.ai.videoCallImages[0].url 
	                    : chat.settings.ai.avatar;
	    
	    // 现在这里的 background 变量是安全的，不会是 null
	    background.style.backgroundImage = `url(${bgImage || ''})`;
	
	    // 显示界面并播放铃声
	    overlay.style.display = 'block';
		try {
		        ringtone.play();
		    } catch (error) {
		        console.warn("Ringtone playback was blocked by the browser. This is expected behavior.", error);
		    }
		
	    ringtone.play();
	}
	
	// 2. 接受通话
	function acceptIncomingCall() {
	    hideIncomingCall();
	    if (incomingCallType && incomingCallFromChatId) {
	        // 确保当前聊天是来电的那个聊天
	        currentChatId = incomingCallFromChatId;
	        startCall(incomingCallType);
	    }
	}
	
	// 3. 拒绝/挂断通话
	function declineIncomingCall() {
	    hideIncomingCall();
	    
	    // (可选) 可以在这里记录用户拒绝了通话，以便 AI 下次知道
	    const chat = state.chats.find(c => c.id === incomingCallFromChatId);
	    if (chat) {
	        // 我们可以向待处理反馈中添加一条信息
	        if (!chat.pendingFeedback) chat.pendingFeedback = [];
	        chat.pendingFeedback.push('[系统提示：用户刚刚拒绝了你的通话请求，你可以适当地在对话中表现出一点点失落或理解。]');
	        saveState();
	    }
	}
	
	// 4. 隐藏来电界面
	function hideIncomingCall() {
	    const overlay = get('incoming-call-overlay');
	    const ringtone = get('ringtone');
	    overlay.style.display = 'none';
	    ringtone.pause();
	    ringtone.currentTime = 0; // 重置铃声
	}
	
	// 5. 绑定事件
	function setupIncomingCallListeners() {
	    get('accept-call-btn').addEventListener('click', acceptIncomingCall);
	    get('decline-call-btn').addEventListener('click', declineIncomingCall);
	}
	// --- 【全新】AI 音色选择逻辑 ---
	
	let availableVoices = [];
	
	// 1. 预加载并填充声音列表
	function populateVoiceList() {
	    const voiceSelect = get('setting-ai-voice');
	    if (typeof speechSynthesis === 'undefined' || !voiceSelect) {
	        return;
	    }
	    
	    // getVoices() 可能是异步的，需要这样处理
	    const loadVoices = () => {
	        availableVoices = synthesis.getVoices().filter(voice => voice.lang.startsWith('zh'));
	        voiceSelect.innerHTML = '<option value="default">默认</option>';
	        availableVoices.forEach(voice => {
	            const option = document.createElement('option');
	            option.textContent = `${voice.name} (${voice.lang})`;
	            option.setAttribute('value', voice.voiceURI);
	            voiceSelect.appendChild(option);
	        });
	        
	        // 加载完成后，设置当前选中的值
	        const chat = state.chats.find(c => c.id === currentChatId);
	        if (chat && chat.settings.ai.voiceURI) {
	            voiceSelect.value = chat.settings.ai.voiceURI;
	        }
	    };
	
	    loadVoices();
	    if (speechSynthesis.onvoiceschanged !== undefined) {
	        speechSynthesis.onvoiceschanged = loadVoices;
	    }
	}
	//通话记录
	function addMessageToCallHistory(sender, text) {
	    const logContainer = get('call-history-log');
	    if (!text) return;
	
	    // logContainer.style.display = 'flex'; // 不再需要这行，因为它现在默认可见
	    
	    const p = document.createElement('p');
	    p.className = sender;
	    p.textContent = text;
	    
	    logContainer.appendChild(p); // 【修改】改为 appendChild，让新消息在底部
	    logContainer.scrollTop = logContainer.scrollHeight; // 【新增】自动滚动到底部
	}
	// --- 【全新】通话记录回放功能 ---
	
	function showCallTranscriptViewer(encodedTranscript) {
	    if (!encodedTranscript) return;
	
	    try {
	        const transcript = JSON.parse(decodeURIComponent(encodedTranscript));
	        
	        // 复用通话界面的聊天记录样式来渲染
	        const transcriptHtml = transcript.map(log => {
	            return `<p class="${log.role}">${log.content}</p>`;
	        }).join('');
	
	        const modalHTML = `
	            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
	                <h3 style="margin:0;">通话记录</h3>
	                <button id="close-transcript-viewer" class="lt-close-btn" style="position: static;">&times;</button>
	            </div>
	            <div class="call-history-log" style="max-height: 70vh; flex-direction: column; background: #f0f2f5; color: #333;">
	                ${transcriptHtml}
	            </div>
	        `;
	        
	        showModal(modalHTML);
	        
	        // 为弹窗内的关闭按钮添加事件
	        get('close-transcript-viewer').onclick = hideModal;
	
	    } catch (e) {
	        console.error("解析通话记录失败:", e);
	        showToast("无法加载通话记录");
	    }
	}
	// =================================================================
	// --- 【全新】温馨小屋 (Pet & Plant) 核心功能函数 ---
	// =================================================================
	
	// 1. 主入口函数
	function openPetHouse() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat) return;
	
	    if (!chat.petAndPlant) { // 如果是 null，说明是第一次
	        get('ph-main-view').style.display = 'none';
	        get('ph-adoption-view').style.display = 'block';
	    } else {
	        get('ph-adoption-view').style.display = 'none';
	        get('ph-main-view').style.display = 'flex';
	        renderPetHouse(); // 渲染主界面
	    }
	    
	    get('pet-house-overlay').classList.add('show');
	}
	
	// 2. 渲染温馨小屋主界面
	function renderPetHouse() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    // 【新】如果连小屋数据都没有，就创建一个空的，并显示主界面
	    if (!chat.petAndPlant) {
	        chat.petAndPlant = {
	            coins: 10, pet: null, plant: null, careLog: [], inventory: []
	        };
	        get('ph-main-view').style.display = 'flex';
	        get('ph-adoption-view').style.display = 'none'; // 确保旧的隐藏
	    }
	
	    const { coins, pet, plant, careLog, inventory } = chat.petAndPlant;
	
	    // 更新金币 (这部分不变)
	    get('ph-coins-display').textContent = `💰 ${coins}`;
	
	    // --- 渲染宠物视图 ---
	    const petView = get('ph-pet-view');
	    // 【核心判断】如果宠物槽位有数据，就渲染宠物信息
	    if (pet && pet.isActive) {
	        petView.innerHTML = `
	            <div class="creature-display">
	                <div class="creature-image" style="font-size: 80px;">${PET_SPECIES[pet.speciesId].icon}</div>
	                <div class="creature-name">
	                    <span id="pet-name-display">${pet.name}</span>
	                    <button class="rename-btn" data-type="pet" title="改名">✏️</button>
	                    <span class="creature-species">(${PET_SPECIES[pet.speciesId].name})</span>
	                </div>
	                <small>${pet.growthStage}</small>
	            </div>
	            <div class="ph-status-bars">
	                 <!-- 状态条的 HTML 保持不变 -->
	                <div class="ph-status-bar">
	                    <label>饱食度</label>
	                    <div class="progress-bg"><div class="progress-fill" style="width: ${pet.status.hunger}%; background: #F56C6C;"></div></div>
	                </div>
	                <div class="ph-status-bar">
	                    <label>愉悦度</label>
	                    <div class="progress-bg"><div class="progress-fill" style="width: ${pet.status.happiness}%; background: #E6A23C;"></div></div>
	                </div>
	                <div class="ph-status-bar">
	                    <label>健康度</label>
	                    <div class="progress-bg"><div class="progress-fill" style="width: ${pet.status.health}%; background: #67C23A;"></div></div>
	                </div>
	            </div>
	        `;
	    } else {
	        // 【核心判断】如果宠物槽位是空的，就渲染“领养”按钮
	        petView.innerHTML = `
	            <div style="text-align: center; padding: 40px 0;">
	                <p>还没有领养宠物呢。</p>
	                <button class="btn btn-primary" id="render-adopt-pet-btn">领养一只宠物</button>
	            </div>
	        `;
	    }
	
	    // --- 渲染植物视图 (逻辑同上) ---
	    const plantView = get('ph-plant-view');
	    // 如果植物槽位有数据...
	    if (plant && plant.isActive) {
	        plantView.innerHTML = `
	            <div class="creature-display">
	                 <div class="creature-image" style="font-size: 80px;">${PLANT_SPECIES[plant.speciesId].icon}</div>
	                 <div class="creature-name">
	                    <span id="plant-name-display">${plant.name}</span>
	                    <button class="rename-btn" data-type="plant" title="改名">✏️</button>
	                    <span class="creature-species">(${PLANT_SPECIES[plant.speciesId].name})</span>
	                 </div>
	                 <small>${plant.growthStage}</small>
	             </div>
	             <div class="ph-status-bars">
	                 <!-- 状态条的 HTML 保持不变 -->
	                 <div class="ph-status-bar">
	                     <label>水 分</label>
	                     <div class="progress-bg"><div class="progress-fill" style="width: ${plant.status.water}%; background: #409EFF;"></div></div>
	                 </div>
	                 <div class="ph-status-bar">
	                     <label>光 照</label>
	                     <div class="progress-bg"><div class="progress-fill" style="width: ${plant.status.sunlight}%; background: #E6A23C;"></div></div>
	                 </div>
	                 <div class="ph-status-bar">
	                     <label>健康度</label>
	                     <div class="progress-bg"><div class="progress-fill" style="width: ${plant.status.health}%; background: #67C23A;"></div></div>
	                 </div>
	             </div>
	        `;
	    } else {
	        // 如果植物槽位是空的，就渲染“种植”按钮
	        plantView.innerHTML = `
	            <div style="text-align: center; padding: 40px 0;">
	                <p>还没有种植植物呢。</p>
	                <button class="btn btn-secondary" id="render-adopt-plant-btn">种植一株植物</button>
	            </div>
	        `;
	    }
	    
	    // --- 日志和仓库的渲染逻辑保持不变 ---
	    const logContainer = get('ph-care-log-container');
	    logContainer.innerHTML = careLog.slice(-5).reverse().map(log => `<p>${new Date(log.timestamp).toLocaleTimeString()} - ${log.event}</p>`).join('');
	
	    const inventoryContainer = get('ph-inventory-container');
	    inventoryContainer.innerHTML = '';
	    const userInventory = inventory.filter(item => item.quantity > 0);
	    if (userInventory.length === 0) {
	        inventoryContainer.innerHTML = `<p style="color: #999;">空空如也~</p>`;
	    } else {
	        userInventory.forEach(item => {
	            const itemInfo = SHOP_ITEMS[item.itemId];
	            inventoryContainer.innerHTML += `
	                <div class="inventory-item">
	                    <span>${itemInfo.icon} ${itemInfo.name} (x${item.quantity})</span>
	                    <button class="btn-small use-item-btn" data-item-id="${item.itemId}" style="padding: 2px 8px;">使用</button>
	                </div>
	            `;
	        });
	    }
		const commonSectionsContainer = get('ph-common-sections');
		if (commonSectionsContainer) {
		    // 【核心修复】先移除旧的，再添加新的
		    get('ph-open-amusement-btn')?.remove(); // 使用可选链，如果按钮不存在也不会报错
		    const amusementParkBtnHtml = `
		            <button id="ph-open-amusement-btn" class="btn btn-secondary" style="margin-top: 15px; background-color: #67C23A; width: 100%;">🎡 前往游乐园</button>
		        `;
		    commonSectionsContainer.insertAdjacentHTML('beforeend', amusementParkBtnHtml);
		}
	}

	
	// 3. 处理领养逻辑
	function handleAdoption(type) {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat) return;
	
	    // 【新】前置检查
	    if (type === 'pet' && chat.petAndPlant?.pet?.isActive) {
	        showToast("你已经有宠物了！");
	        return;
	    }
	    if (type === 'plant' && chat.petAndPlant?.plant?.isActive) {
	        showToast("你已经种植了植物！");
	        return;
	    }
	    
	    // 【核心改造】使用弹窗来选择，而不是 prompt
	    
	    const speciesData = type === 'pet' ? PET_SPECIES : PLANT_SPECIES;
	    const modalTitle = type === 'pet' ? '领养一只新宠物' : '种植一株新植物';
	    
	    // 动态生成选项列表的 HTML
	    const choiceListHtml = Object.keys(speciesData).map(key => `
	        <div class="list-item" data-species-id="${key}" style="cursor: pointer;">
	            <div style="font-size: 24px; margin-right: 15px;">${speciesData[key].icon}</div>
	            <div class="info">
	                <div class="name">${speciesData[key].name}</div>
	            </div>
	            <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
	        </div>
	    `).join('');
	
	    // 显示选择弹窗
	    showModal(`
	        <h3>${modalTitle}</h3>
	        <div class="list-view">${choiceListHtml}</div>
	    `);
	
	    // 为弹窗内的列表项添加事件监听
	    get('modal-content').querySelector('.list-view').addEventListener('click', e => {
	        const selectedItem = e.target.closest('.list-item');
	        if (selectedItem) {
	            const speciesId = selectedItem.dataset.speciesId;
	            // 隐藏物种选择弹窗
	            hideModal();
	            // 稍后弹出命名弹窗
	            setTimeout(() => {
	                showNamingPrompt(type, speciesId, speciesData);
	            }, 200);
	        }
	    });
	}
	// 【新增辅助函数】弹出命名框
	function showNamingPrompt(type, speciesId, speciesData) {
	    const name = prompt(`给你的新${speciesData[speciesId].name}取个名字吧：`);
	    if (!name || !name.trim()) {
	        showToast("名字不能为空哦！");
	        return;
	    }
	
	    const chat = state.chats.find(c => c.id === currentChatId); // 再次获取chat，确保安全
	    if (!chat) return;
	    
	    // 如果是第一次，创建 petAndPlant 对象
	    if (!chat.petAndPlant) {
	         chat.petAndPlant = {
	             coins: 10, pet: null, plant: null, careLog: [], inventory: []
	         };
	    }
	    
	    // 后续的创建和保存逻辑和你原来的一样
	    const newCreature = {
	        isActive: true, speciesId: speciesId, name: name.trim(),
	        growthPoints: 0,
	        growthStage: type === 'pet' ? '幼崽期' : '种子期',
	        status: { health: 100, [type === 'pet' ? 'hunger' : 'water']: 80, [type === 'pet' ? 'happiness' : 'sunlight']: 80 },
	        lastUpdate: new Date().toISOString()
	    };
	
	    if (type === 'pet') {
	        chat.petAndPlant.pet = newCreature;
	    } else {
	        chat.petAndPlant.plant = newCreature;
	    }
	    
	    addCareLog(`你 领养了 ${speciesData[speciesId].name}“${name}”。`);
	    saveState();
	    openPetHouse(); // 直接刷新小屋弹窗
	}

	
	// 4. 打开商店
	function openShop() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat || !chat.petAndPlant) return;
	
	    get('shop-coins-display').textContent = `💰 ${chat.petAndPlant.coins}`;
	    const container = get('shop-items-container');
	    container.innerHTML = Object.keys(SHOP_ITEMS).map(itemId => {
	        const item = SHOP_ITEMS[itemId];
	        return `
	            <div class="shop-item">
	                <div class="shop-item-icon">${item.icon}</div>
	                <div class="shop-item-name">${item.name}</div>
	                <div class="shop-item-desc">${item.desc}</div>
	                <button class="shop-item-buy-btn" data-item-id="${itemId}">💰 ${item.price}</button>
	            </div>
	        `;
	    }).join('');
	
	    get('shop-overlay').classList.add('show');
	}
	
	// 5. 购买和使用道具
	function handleBuyItem(itemId) {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    const item = SHOP_ITEMS[itemId];
	    if (!chat || !chat.petAndPlant || !item) return;
	
	    if (chat.petAndPlant.coins >= item.price) {
	        chat.petAndPlant.coins -= item.price;
	        
	        let existingItem = chat.petAndPlant.inventory.find(i => i.itemId === itemId);
	        if (existingItem) {
	            existingItem.quantity++;
	        } else {
	            chat.petAndPlant.inventory.push({ itemId, quantity: 1 });
	        }
	        
	        showToast(`购买 ${item.name} 成功！`);
	        get('shop-coins-display').textContent = `💰 ${chat.petAndPlant.coins}`;
	        saveState();
	    } else {
	        showToast("小鱼币不足！");
	    }
	}
	
	function handleUseItem(itemId) {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    const itemInfo = SHOP_ITEMS[itemId];
	    if (!chat || !chat.petAndPlant || !itemInfo) return;
	
	    // 前置检查：库存是否足够
	    const inventoryItem = chat.petAndPlant.inventory.find(i => i.itemId === itemId);
	    if (!inventoryItem || inventoryItem.quantity <= 0) return;
	
	    // 【新】判断是否是游戏道具
	    if (itemInfo.isGame) {
	        // 关闭小屋弹窗，准备开始游戏
	        get('pet-house-overlay').classList.remove('show');
	        // 延迟一点启动游戏，UI过渡更自然
	        setTimeout(() => {
	            startToyBallGame(itemId); 
	        }, 300);
	        return; // 直接返回，不走下面的普通道具逻辑
	    }
	
	    // --- 普通道具使用逻辑 ---
	    
	    // 减少库存
	    inventoryItem.quantity--;
	
	    // 施加效果
	    const target = (itemInfo.type === 'pet' || itemInfo.type === 'any') ? chat.petAndPlant.pet : chat.petAndPlant.plant;
	    if (target && target.isActive) {
	        for (const key in itemInfo.effect) {
	            if (key === 'growthPoints') { // 特殊处理成长值
	                target.growthPoints += itemInfo.effect[key];
	            } else {
	                target.status[key] = Math.min(100, target.status[key] + itemInfo.effect[key]);
	            }
	        }
	        addCareLog(`你 对 ${target.name} 使用了 ${itemInfo.name}。`);
	        showToast(`你使用了 ${itemInfo.name}！`);
	        renderPetHouse();
	        saveState();
	    }
	}
	
	//小游戏
	function startToyBallGame(itemId) {
	    const gameDuration = 10; // 游戏持续10秒
	    let score = 0;
	    
	    // 创建游戏弹窗
	    const modalHTML = `
	        <div style="text-align: center;">
	            <h3>逗猫棒小游戏！</h3>
	            <p>在 <span id="game-timer">${gameDuration}</span> 秒内尽可能多地点中逗猫棒！</p>
	            <div id="game-area" style="position: relative; width: 100%; height: 200px; background: #f0f2f5; border-radius: 12px; overflow: hidden; cursor: pointer;">
	                <div id="game-ball" style="font-size: 40px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); transition: all 0.3s ease;">🥎</div>
	            </div>
	            <p>得分: <span id="game-score">0</span></p>
	        </div>
	    `;
	    showModal(modalHTML);
	
	    const timerEl = get('game-timer');
	    const scoreEl = get('game-score');
	    const gameArea = get('game-area');
	    const ballEl = get('game-ball');
	
	    // 小球移动逻辑
	    const moveBall = () => {
	        const maxX = gameArea.clientWidth - 40;
	        const maxY = gameArea.clientHeight - 40;
	        ballEl.style.top = `${Math.random() * maxY}px`;
	        ballEl.style.left = `${Math.random() * maxX}px`;
	    };
	
	    // 点击小球得分
	    ballEl.addEventListener('click', (e) => {
	        e.stopPropagation(); // 防止点击穿透
	        score++;
	        scoreEl.textContent = score;
	        ballEl.style.transform = "scale(1.2)"; // 点击反馈
	        setTimeout(() => ballEl.style.transform = "scale(1)", 100);
	        moveBall();
	    });
	
	    // 倒计时
	    let timeLeft = gameDuration;
	    const gameInterval = setInterval(() => {
	        timeLeft--;
	        timerEl.textContent = timeLeft;
	        if (timeLeft <= 0) {
	            clearInterval(gameInterval);
	            endToyBallGame(itemId, score);
	        }
	    }, 1000);
	    
	    moveBall(); // 游戏开始时移动一次
	}
	
	function showGameSelectionModal() {
	    // 先关闭小屋弹窗，避免重叠
	    get('pet-house-overlay').classList.remove('show');
	
	    // 延迟打开游戏选择，过渡更自然
	    setTimeout(() => {
	        const modalHTML = `
	            <h3>欢迎来到游乐园！</h3>
	            <p style="text-align: center; color: #888;">玩游戏可以赚取小鱼币哦！</p>
	            <div class="list-view" style="margin-top: 20px;">
	                <div class="list-item game-select-item" data-game="guess_number">
	                    <div style="font-size:24px; margin-right: 15px;">🔢</div>
	                    <div class="info"><div class="name">猜数字</div></div>
	                    <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
	                </div>
	                <div class="list-item game-select-item" data-game="tap_fast">
	                    <div style="font-size:24px; margin-right: 15px;">👆</div>
	                    <div class="info"><div class="name">快速点击</div></div>
	                    <div class="chevron"><svg class="svg-icon"><use href="#icon-chevron-right"></use></svg></div>
	                </div>
	            </div>
	        `;
	        showModal(modalHTML);
	
	        // 为游戏列表项绑定点击事件
	        get('modal-content').querySelector('.list-view').addEventListener('click', e => {
	            const selectedGame = e.target.closest('.game-select-item');
	            if (selectedGame) {
	                const gameId = selectedGame.dataset.game;
	                if (gameId === 'guess_number') {
	                    startGuessNumberGame();
	                } else if (gameId === 'tap_fast') {
	                    startTapFastGame();
	                }
	            }
	        });
	    }, 300);
	}
	
	// =======================================================
	// ▼▼▼ 新增小游戏逻辑 ▼▼▼
	// =======================================================
	
	// --- 游戏1：猜数字 ---
	function startGuessNumberGame() {
	    const targetNumber = Math.floor(Math.random() * 100) + 1;
	    let chances = 6;
	
	    const modalHTML = `
	        <h3>猜数字 (1-100)</h3>
	        <p>你有 ${chances} 次机会猜出我心中的数字。</p>
	        <div class="form-group">
	            <input type="number" id="guess-input" style="text-align: center;">
	        </div>
	        <button id="submit-guess-btn" class="btn btn-primary">猜！</button>
	        <p id="guess-feedback" style="margin-top: 15px; min-height: 20px;"></p>
	    `;
	    showModal(modalHTML);
	
	    const inputEl = get('guess-input');
	    const feedbackEl = get('guess-feedback');
	    const submitBtn = get('submit-guess-btn');
	
	    const endGame = (isWin) => {
	        inputEl.disabled = true;
	        submitBtn.disabled = true;
	        const coinsGained = isWin ? 20 - (6 - chances) * 2 : 0; // 猜对奖励，越早猜对奖励越多
	        if (isWin) {
	            feedbackEl.innerHTML = `🎉 恭喜你猜对了！数字就是 <b>${targetNumber}</b>！<br>你获得了 ${coinsGained} 小鱼币！`;
	        } else {
	            feedbackEl.textContent = `很遗憾，机会用完了。正确数字是 ${targetNumber}。`;
	        }
	
	        if (coinsGained > 0) {
	            const chat = state.chats.find(c => c.id === currentChatId);
	            if (chat?.petAndPlant) {
	                chat.petAndPlant.coins += coinsGained;
	                saveState();
	            }
	        }
	    };
	
	    submitBtn.addEventListener('click', () => {
	        const guess = parseInt(inputEl.value);
	        if (isNaN(guess)) {
	            feedbackEl.textContent = '请输入一个有效的数字。';
	            return;
	        }
	
	        chances--;
	        if (guess === targetNumber) {
	            endGame(true);
	        } else if (chances <= 0) {
	            endGame(false);
	        } else {
	            feedbackEl.textContent = `猜 ${guess < targetNumber ? '小' : '大'}了！你还有 ${chances} 次机会。`;
	            inputEl.value = '';
	            inputEl.focus();
	        }
	    });
	}
	
	// --- 游戏2：快速点击 ---
	function startTapFastGame() {
	    const gameDuration = 10;
	    let score = 0;
	
	    const modalHTML = `
	        <div style="text-align: center;">
	            <h3>10秒快速点击！</h3>
	            <div id="tap-game-area" style="width: 100%; height: 200px; background: #409EFF; border-radius: 12px; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; font-weight: bold; cursor: pointer; user-select: none;">
	                点击这里！
	            </div>
	            <p style="font-size: 28px; margin: 15px 0;">得分: <span id="tap-score">0</span></p>
	            <p>时间剩余: <span id="tap-timer">${gameDuration}</span> 秒</p>
	        </div>
	    `;
	    showModal(modalHTML);
	    
	    const timerEl = get('tap-timer');
	    const scoreEl = get('tap-score');
	    const gameArea = get('tap-game-area');
	    
	    let timeLeft = gameDuration;
	    gameArea.textContent = '准备...';
	    
	    // 游戏点击区域
	    gameArea.addEventListener('click', () => {
	        if(gameArea.textContent === '点击这里！') { // 确保游戏已经开始
	            score++;
	            scoreEl.textContent = score;
	        }
	    });
	
	    // 倒计时
	    setTimeout(() => {
	        gameArea.textContent = '点击这里！';
	        const gameInterval = setInterval(() => {
	            timeLeft--;
	            timerEl.textContent = timeLeft;
	            if (timeLeft <= 0) {
	                clearInterval(gameInterval);
	                gameArea.textContent = '时间到！';
	                gameArea.style.pointerEvents = 'none'; // 禁止再次点击
	                gameArea.style.background = '#F56C6C';
	
	                const coinsGained = Math.floor(score / 5); // 每5分奖励1个金币
	                showToast(`游戏结束！你获得了 ${coinsGained} 个小鱼币！`);
	
	                if (coinsGained > 0) {
	                    const chat = state.chats.find(c => c.id === currentChatId);
	                    if (chat?.petAndPlant) {
	                        chat.petAndPlant.coins += coinsGained;
	                        saveState();
	                    }
	                }
	            }
	        }, 1000);
	    }, 1500); // 延迟1.5秒开始
	}
	
	// =======================================================
	// ▲▲▲ 新增小游戏逻辑结束 ▲▲▲
	// =======================================================


	
	function endToyBallGame(itemId, score) {
	    hideModal();
	
	    const chat = state.chats.find(c => c.id === currentChatId);
	    const itemInfo = SHOP_ITEMS[itemId];
	    if (!chat || !chat.petAndPlant || !itemInfo) return;
	
	    // 减少库存
	    const inventoryItem = chat.petAndPlant.inventory.find(i => i.itemId === itemId);
	    if (inventoryItem) inventoryItem.quantity--;
	
	    // 根据得分计算愉悦度
	    const happinessGained = Math.min(50, 5 + score * 3); // 基础5点，每分+3，上限50
	    const coinsGained = Math.floor(score / 3); // 每3分奖励1个金币
	
	    const pet = chat.petAndPlant.pet;
	    if (pet && pet.isActive) {
	        pet.status.happiness = Math.min(100, pet.status.happiness + happinessGained);
	        
	        let resultMessage = `和 ${pet.name} 玩了一会儿，它的愉悦度增加了 ${happinessGained} 点！`;
	        if (coinsGained > 0) {
	            chat.petAndPlant.coins += coinsGained;
	            resultMessage += ` 意外收获了 ${coinsGained} 个小鱼币！`;
	        }
	        
	        showToast(resultMessage);
	        addCareLog(`和 ${pet.name} 玩了逗猫棒小游戏。`);
	        saveState();
	    }
	}


	
	// 6. 添加日志的辅助函数
	function addCareLog(eventText) {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!chat || !chat.petAndPlant) return;
	    chat.petAndPlant.careLog.push({ timestamp: new Date().toISOString(), event: eventText });
	}
	
	// 7. 状态衰减和生长检查 (全局)
	function updateAllPetsAndPlantsStatus() {
	    const now = new Date();
	    let stateChanged = false; // 标记状态是否真的发生变化
	
	    state.chats.forEach(chat => {
	        if (!chat.petAndPlant) return;
	
	        const pp = chat.petAndPlant;
	        const lastUpdate = new Date(pp.pet?.lastUpdate || pp.plant?.lastUpdate || now);
	        const hoursPassed = (now - lastUpdate) / (1000 * 60 * 60);
	
	        if (hoursPassed < 1) return; // 每小时执行一次
	
	        const ticks = Math.floor(hoursPassed); // 计算过去了几个小时（整数）
	        const decayRate = 5 * ticks;
	
	        // --- 宠物逻辑 ---
	        if (pp.pet && pp.pet.isActive) {
	            pp.pet.status.hunger = Math.max(0, pp.pet.status.hunger - decayRate);
	            pp.pet.status.happiness = Math.max(0, pp.pet.status.happiness - (decayRate / 2));
	            
				if (pp.pet.status.hunger <= 10) { // 如果饱食度低于10（极度饥饿）
				        // 健康度也开始下降，下降速度可以是饥饿惩罚的一半
				        pp.pet.status.health = Math.max(0, pp.pet.status.health - (decayRate / 2));
				        
				        // 【可选-记录日志】我们可以记录这一负面事件
				        // 为避免日志爆炸，可以加一个随机判断，比如1/3的概率记录
				        if (Math.random() < 0.33) {
				            addCareLog(`${pp.pet.name} 因为太饿了，看起来无精打采的。`);
				        }
				    }
	            // 【新】成长逻辑
	            pp.pet.growthPoints += ticks; // 每小时增加1点成长值
	            
	            // 【新】成长阶段判断
	            let oldStage = pp.pet.growthStage;
	            if (oldStage === '幼崽期' && pp.pet.growthPoints >= 24) { // 24小时后
	                pp.pet.growthStage = '成长期';
	            } else if (oldStage === '成长期' && pp.pet.growthPoints >= 168) { // 1周后
	                pp.pet.growthStage = '成年期';
	            }
	            if (oldStage !== pp.pet.growthStage) {
	                // 如果当前聊天是打开的，就弹窗提示
	                if(chat.id === currentChatId) showToast(`你的${pp.pet.name}长大了，进入了${pp.pet.growthStage}！`);
	                // 记录日志
	                addCareLog(`${pp.pet.name} 进入了 ${pp.pet.growthStage}！`);
	            }
	            
	            pp.pet.lastUpdate = now.toISOString();
	            stateChanged = true;
	        }
	        
	        // --- 植物逻辑 (同理) ---
	        if (pp.plant && pp.plant.isActive) {
	            pp.plant.status.water = Math.max(0, pp.plant.status.water - decayRate);
	            pp.plant.status.sunlight = Math.max(0, pp.plant.status.sunlight - decayRate);
				if (pp.plant.status.water <= 10) { // 如果水分低于10（极度缺水）
				        // 健康度开始下降
				        pp.plant.status.health = Math.max(0, pp.plant.status.health - decayRate); // 植物缺水更致命，惩罚可以重一些
				        
				        // 【可选-记录日志】
				         if (Math.random() < 0.33) {
				            addCareLog(`${pp.plant.name} 的叶子因为缺水有点枯黄了。`);
				        }
				    }
	            pp.plant.growthPoints += ticks;
	
	            let oldStage = pp.plant.growthStage;
	            if (oldStage === '种子期' && pp.plant.growthPoints >= 12) {
	                pp.plant.growthStage = '发芽期';
	            } else if (oldStage === '发芽期' && pp.plant.growthPoints >= 48) {
	                pp.plant.growthStage = '成长期';
	            }
	            if (oldStage !== pp.plant.growthStage) {
	                 if(chat.id === currentChatId) showToast(`你的${pp.plant.name}长大了，进入了${pp.plant.growthStage}！`);
	                 addCareLog(`${pp.plant.name} 进入了 ${pp.plant.growthStage}！`);
	            }
	            
	            pp.plant.lastUpdate = now.toISOString();
	            stateChanged = true;
	        }
	    });
	
	    if (stateChanged) {
	        saveState(); // 只有当状态真的改变时才保存
	    }
	}
	function getPetMood(pet) {
	    if (!pet || !pet.isActive) return '不在家';
	    
	    const { hunger, happiness, health } = pet.status;
	    
	    if (health < 30) return '看起来病殃殃的，非常虚弱';
	    if (hunger < 20) return '饿得喵喵叫，急需食物';
	    if (happiness < 20) return '看起来很无聊，情绪低落';
	    
	    if (happiness > 80 && hunger > 80) return '心满意足，正在打呼噜';
	    if (happiness > 80) return '非常开心，正摇着尾巴';
	    if (hunger > 80) return '饱餐一顿，很满足';
	
	    return '状态良好，看起来很平静';
	}


	// =================================================================
	// --- 【全新】线下剧场 (Offline Scene) 核心功能函数 ---
	// =================================================================
	
	// 1. 开始线下剧场
	// 【V3 最终版】
	function startOfflineScene() {
	    get('scene-choices-container').innerHTML = '';
	    get('scene-input-area').style.display = 'block';
	
	    const location = prompt("请输入场景地点：", "咖啡馆的靠窗座位");
	    if (!location) return;
	    const time = prompt("请输入场景时间：", "一个下雨的午后");
	    if (!time) return;
	
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (chat) {
			if (!chat.offlineSceneSettings) {
			             chat.offlineSceneSettings = {
			                background: '',
			                colors: { /* ... 默认颜色 ... */ }
			            };
			        }
	        // 【核心修改】直接在这里应用已保存的背景，不再调用外部函数
	        const contentArea = get('scene-log-container');
	        if (chat.offlineSceneSettings.background) {
	            contentArea.style.backgroundImage = `url(${chat.offlineSceneSettings.background})`;
	            contentArea.style.backgroundSize = 'cover';
	            contentArea.style.backgroundPosition = 'center';
	        } else {
	            contentArea.style.backgroundImage = 'none';
	        }
	    }
	
	    currentOfflineScene = {
	        location: location,
	        time: time,
	        log: [
	            { type: 'narrative', content: `场景：${location}。时间：${time}。` }
	        ]
	    };
	
	    renderOfflineSceneLog();
	    navigateTo('offline-scene-page');
	}
	
	// 2. 渲染故事日志
	// 【V4.0 最终版，包含所有美化】
	function renderOfflineSceneLog() {
	    const chat = state.chats.find(c => c.id === currentChatId);
	    if (!currentOfflineScene || !chat) return;
	
	    const container = get('scene-log-container');
	    if (!container) return;
	    
	    // 【核心】从 chat.offlineSceneSettings 中一次性读取所有颜色设置
	    const colors = chat.offlineSceneSettings.colors;
	
	    container.innerHTML = currentOfflineScene.log.map((entry, index) => {
	        // 对于每一种 entry 类型，我们都返回一个完整的、带样式的 div
			 const deleteButton = `<button class="scene-entry-delete-btn" data-log-index="${index}" title="删除此条目">&times;</button>`;
	        if (entry.type === 'narrative') {
	            const style = `color: ${colors.narrative}; background-color: ${colors.container_bg}; position: relative;`;
	            return `<div class="scene-entry narrative" style="${style}">${entry.content}${deleteButton}</div>`;
	        } 
	        else if (entry.type === 'user_input') {
	            // 【核心】对 user_input 的修改就在这里！
	            // 我们为所有 user input 类型都应用统一的容器背景色
	            const className = `scene-entry user-${entry.mode}`;
	            const style = `color: ${colors['user_' + entry.mode]}; background-color: ${colors.container_bg}; position: relative;`;
	            return `<div class="${className}" style="${style}">${entry.content}${deleteButton}</div>`;
	        }
	        return ''; // 对于未知类型，返回空
	    }).join('');
	    
	    container.scrollTop = container.scrollHeight;
	}
	// 在 JS 功能区添加这两个函数
	function getOpacityFromRgba(rgba) {
	    if (!rgba || typeof rgba !== 'string') return 1; 
	    const match = rgba.match(/, ([\d\.]+)\)/);
	    return match ? parseFloat(match[1]) : 1;
	}
	function setColorWithOpacity(hexColor, opacity) {
	    const r = parseInt(hexColor.slice(1, 3), 16);
	    const g = parseInt(hexColor.slice(3, 5), 16);
	    const b = parseInt(hexColor.slice(5, 7), 16);
	    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
	}
	
	// 3. 发送用户输入 (对话/行动/内心)
	async function sendOfflineEntry() {
	    const input = get('scene-input');
	    const content = input.value.trim();
	    if (!content) return;
	
	    const activeModeBtn = get('scene-input-mode-selector').querySelector('.active');
	    const mode = activeModeBtn.dataset.mode;
	
	    // 将用户输入添加到日志
	    currentOfflineScene.log.push({
	        type: 'user_input',
	        mode: mode,
	        content: content
	    });
	    
	    input.value = '';
	    input.style.height = 'auto';
	    renderOfflineSceneLog();
	
	    // 请求AI生成后续剧情
	    await generateOfflineNarrative();
	}
	
	// 4. 请求AI生成叙事 (最终清理版 V6.0 - 包含通话记忆)
	async function generateOfflineNarrative() {
	    // 【修正】更健壮的安全检查
	    if (!currentOfflineScene) {
	        showToast("场景数据已丢失，请返回聊天重试");
	        const btn = get('generate-ai-narrative-btn');
	        if (btn) btn.disabled = false;
	        return;
	    }
	
	    const chat = state.chats.find(c => c.id === currentChatId);
	    const { currentApiId, savedApis } = state.apiSettings;
	    const currentApi = savedApis.find(api => api.id === currentApiId);
	    if (!currentApi) return showToast("API未配置");
	
	    const btn = get('generate-ai-narrative-btn');
	    if (!btn) { console.error("无法找到 AI 续写按钮！"); return; }
	    const icon = btn.querySelector('.svg-icon');
	    const spinner = btn.querySelector('.spinner');
	    if (!icon || !spinner) { console.error("按钮内部缺少 icon 或 spinner 元素！"); return; }
	
	    btn.disabled = true;
	    icon.style.display = 'none';
	    spinner.style.display = 'block';
	
	    try {
	        // --- 【核心升级】构建包含所有记忆的上下文 ---
	        const memoryDepth = chat.settings.memoryDepth || 12;
	
	        // 1. 构建线上聊天记录摘要 (现在它能理解所有类型的消息了)
	        const recentMessages = chat.messages.slice(-memoryDepth).map(m => {
	            let content = '';
	            switch (m.type) {
	                // 【全新升级的通话记忆，用于故事】
	                case 'call_summary':
	                    if (m.content.transcript && m.content.transcript.length > 0) {
	                        const transcriptText = m.content.transcript.map(log => `${log.role === 'user' ? '用户' : '你'}: "${log.content}"`).join('\n');
	                        content = `[系统提示：我们刚刚结束了一次通话，以下是完整的通话记录，你需要将通话中的情绪和关键信息融入到接下来的故事叙述中。\n---\n${transcriptText}\n---]`;
	                    } else {
	                        const d = m.content.duration;
	                        const min = String(Math.floor(d / 60)).padStart(2, '0');
	                        const sec = String(d % 60).padStart(2, '0');
	                        content = `[通话回顾: 我们刚刚通过一次电话，时长 ${min}:${sec}]`;
	                    }
	                    break;
	
	                // (其他所有 case 保持和 callApi 函数中一致即可)
	                case 'scene_summary':
	                    const summarySnippet = m.content.storyText.substring(0, 400);
	                    content = `[上一个故事回顾：“...${summarySnippet}”]`;
	                    break;
	                case 'text': content = m.content; break;
	                case 'image': content = `[图片消息，描述: '${m.content.description || '无'}']`; break;
	                case 'sticker':
	                    const sticker = state.stickerLibrary.find(s => s.id === m.content);
	                    content = `[表情包: '${sticker ? sticker.description : '未知'}']`;
	                    break;
	                case 'voice': content = `[语音消息: '${m.content.text}']`; break;
	                case 'file': content = `[文件消息: '${m.content.name}']`; break;
	                case 'transfer': content = `[转账消息: 金额 ¥${m.content.amount}, 状态: ${m.content.status}]`; break;
	                case 'gift': content = `[礼物消息: '${m.content.name}', 状态: ${m.content.status}]`; break;
	                case 'location': content = `[位置消息: '${m.content.address}']`; break;
	                case 'fanfic_share': content = `[文章分享: '${m.content.title}']`; break;
	                case 'forwarded_record': content = `[转发的聊天记录]`; break;
	                case 'retracted': case 'ai_retracted': content = `[一条消息被撤回]`; break;
	                default: content = `[${m.type || '未知类型'}消息]`;
	            }
	            // 【关键的修复逻辑】：根据聊天类型获取正确的发言人名字
            let senderName = '';
            if (m.role === 'user') {
                senderName = '用户'; // 或者用你的统一的用户昵称
            } else { // role === 'ai'
                if (chat.type === 'group') {
                    // 如果是群聊，从成员列表里找
                    const member = chat.settings.members.find(mem => mem.id === m.memberId);
                    senderName = member ? member.name : '未知成员'; // 找不到就给个默认值
                } else {
                    // 如果是单聊，才从 settings.ai.name 获取
                    senderName = chat.settings.ai.name;
                }
            }
            
            return {
                role: m.role, //保留原始role，下面转换用
                content: content,
                senderName: senderName // 将获取到的名字也一并返回
            };
        });
        // 在这里，我们使用上面处理好的 senderName 来构建最终的文本
        const recentMessagesText = recentMessages.map(m =>
            `${m.senderName}: ${m.content}`
        ).join('\n');
		
	        // 2. 构建所有历史线下故事的完整上下文
	        let allPreviousScenesContext = '';
	        const allFinishedScenes = chat.messages.filter(m => m.type === 'scene_summary');
	        if (allFinishedScenes.length > 0) {
	            const sceneTexts = allFinishedScenes.map((scene, index) => {
	                return `
	--- 历史线下故事 ${index + 1} ---
	故事全文：
	${scene.content.storyText}
	---`;
	            }).join('\n\n');
	            
	            allPreviousScenesContext = `
	# 所有已完成的线下故事 (重要历史参考)
	${sceneTexts}`;
	        }
	
	        // 3. 构建当前正在进行的线下故事日志
	        const sceneLogText = currentOfflineScene.log.map(entry => {
	            if (entry.type === 'narrative') return entry.content;
	            if (entry.type === 'user_input') {
	                if (entry.mode === 'dialogue') return `你说：“${entry.content}”`;
	                if (entry.mode === 'action') return `[你的行动：${entry.content}]`;
	                if (entry.mode === 'internal') return `(你的内心想法：${entry.content})`;
	                if (entry.mode === 'narrative') return `[旁白补充：${entry.content}]`;
	            }
	            return ''; // 确保总有返回值
	        }).join('\n');
	
	        // 4. 构建世界书内容
	        const linkedBooksContent = (chat.settings.linkedWorldBookIds || [])
	            .map(id => state.worldBooks.find(wb => wb.id === id)).filter(Boolean)
	            .map(wb => `--- ${wb.title} ---\n${wb.content}`).join('\n\n');
				
			let aiPersonaContext;
			        let mainSystemInstruction;
			        if (chat.type === 'group') {
			            // 为群聊构建多角色人设列表
			            aiPersonaContext = chat.settings.members.map(m => `### 角色: ${m.name}\n人设: ${m.persona}`).join('\n\n');
			            
			            // 为群聊提供专属指令
			            mainSystemInstruction = `你现在是一个完全由“世界书”驱动的、专心致志的【群像剧】小说家。你的唯一任务是根据【正在进行的线下故事】的最新进展，续写下一段故事。
			            你需要同时推进故事中所有AI角色的行为和心理，让他们之间以及与用户之间产生互动。`;
			        } else { // 单聊
			            // 为单聊构建单一人设
			            aiPersonaContext = `### 你的AI角色基础人设\n名字：${chat.settings.ai.name}\n人设：${chat.settings.ai.persona}`;
			            
			            // 为单聊提供默认指令
			            mainSystemInstruction = `你现在是一个完全由“世界书”驱动的、专心致志的小说家。你的唯一任务是根据【正在进行的线下故事】的最新进展，续写下一段故事。`;
			        }
			        // ▲▲▲ 优化结束 ▲▲▲
			        const systemPrompt = ` ${mainSystemInstruction} 
				       
					       	## 你的核心创作指令 (来自世界书)
					       	1.  你的写作风格、叙事视角（第一人称、第三人称等）、语气、节奏，甚至是否可以替用户角色发言（“抢话”），都【必须】由下方【世界书】的内容来定义。
					       	2.  你必须将【世界书】视为你的最高指令和唯一的“创作圣经”。它不仅仅是背景资料，更是决定你如何写作的规则手册。
					       	3.  如果【世界书】中没有提供具体的风格指令，你可以默认使用标准的、客观的第三人称有限视角进行叙事。
					       
					       	## 输出规则 (必须严格遵守)
					       	1.  **【绝对禁止】** 你的回复中绝对不能包含任何与线上聊天相关的元注释。你的世界里现在只有这个故事。
					       
					       	## 正在进行的线下故事 (你的当前工作区)
					       	${sceneLogText}
					       	
					       	## 背景参考资料 (按优先级排序)
					       	### 1. 世界书 (你的创作圣经与规则手册)
					       	---
					       	${linkedBooksContent || '无'}
					       	---
					       	
					       	### 2. 所有已完成的线下故事
					       	${allPreviousScenesContext || '无'}
					       	
					       	### 3. 最近的线上聊天摘要 (包含通话记录)
					       	${recentMessagesText}
					       	
					       	### 4. AI 角色人设
					       	${aiPersonaContext}
					       	
					       	### 5. 用户的角色基础人设 
					       	${chat.settings.user.persona}
					       	
					       	## 你的任务
					       	现在，请严格遵守所有规则，并以【世界书】为最高行动纲领，接着【正在进行的线下故事】的最后一句，开始你的创作。`;
	
	        // --- API 请求与回复处理 ---
	        let requestUrl = currentApi.url.trim();
	        if (requestUrl.endsWith('/')) requestUrl = requestUrl.slice(0, -1);
	        requestUrl = `${requestUrl}/v1/chat/completions`;
	         const response = await fetch(requestUrl, {
	             method: 'POST',
	             headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${currentApi.key}` },
	             body: JSON.stringify({
	                 model: currentApi.model,
	                messages: [ { role: 'user', content: systemPrompt } ]
	             })
	         });
	        if (!response.ok) throw new Error(`API 请求失败: ${response.statusText}`);
	        const data = await response.json();
	        let narrativeContent = ''; // 1. 先准备一个默认的空回复
	                // 2. 检查 API 的响应是否有效
	                if (data && Array.isArray(data.choices) && data.choices.length > 0 && data.choices[0].message && typeof data.choices[0].message.content === 'string') {
	                    // 只有当所有条件都满足时，才去获取内容
	                    narrativeContent = data.choices[0].message.content;
	                } else {
	                    // 如果API返回的数据结构不正确，我们就在控制台记录错误，并给出一个友好的用户提示
	                    console.error('收到的API响应格式不正确或为空:', data);
	                    narrativeContent = '[系统提示：AI暂时没有回应，可能是太累了，请稍后再试或结束场景。]';
	                }
	
	        const choiceMatch = narrativeContent.match(/\[CHOICE:(.*?)\]/);
	        if (choiceMatch) {
	            narrativeContent = narrativeContent.replace(choiceMatch[0], '').trim();
	            const choices = choiceMatch[1].split('::').map(c => c.trim());
	            renderSceneChoices(choices);
	        }
	
	        currentOfflineScene.log.push({ type: 'narrative', content: narrativeContent });
	        renderOfflineSceneLog();
	
	    } catch (error) {
	        console.error(error);
	        if (currentOfflineScene) {
	            currentOfflineScene.log.push({ type: 'narrative', content: `[系统错误: ${error.message}]`});
	            renderOfflineSceneLog();
	        }
	    } finally {
	       btn.disabled = false;
	       icon.style.display = 'block';
	       spinner.style.display = 'none';
	    }
	}
			
			// 5. 结束场景并保存
			// 【完整记忆版】替换原来的 finishOfflineScene
			function finishOfflineScene() { // 不再需要 async
			 get('scene-choices-container').innerHTML = '';
			    get('scene-input-area').style.display = 'block';
			    if (!currentOfflineScene || currentOfflineScene.log.length <= 1) {
			        navigateBack();
			        return;
			    }
			
			    const chat = state.chats.find(c => c.id === currentChatId);
			    if (!chat) return;
			
			    // --- 【核心修改】直接将故事日志格式化为文本 ---
			    // 我们不再需要调用API，这个过程是即时的
			    const fullStoryText = currentOfflineScene.log.map(entry => {
			        if (entry.type === 'narrative') {
			            return entry.content; // AI的旁白
			        }
			        if (entry.type === 'user_input') {
			            // 根据用户的输入模式，生成更自然的描述
			            if (entry.mode === 'dialogue') return `你说：“${entry.content}”`;
			            if (entry.mode === 'action') return `[你的行动：${entry.content}]`;
			            if (entry.mode === 'internal') return `(你的内心想法：${entry.content})`;
			            if (entry.mode === 'narrative') return `[旁白补充：${entry.content}]`;
			        }
			        return ''; // 对于未知类型，返回空字符串
			    }).join('\n\n'); // 使用双换行来分隔段落，更易读
			    // --- 修改结束 ---
			
			    const summaryMessage = {
			        msgId: generateId('msg'),
			        role: 'system',
			        type: 'scene_summary',
			        content: {
			            fullLog: currentOfflineScene.log, // 原始日志仍然保留，用于回顾
			            storyText: fullStoryText // 【新增】保存格式化后的完整故事文本
			        },
			        timestamp: new Date().toISOString()
			    };
			    chat.messages.push(summaryMessage);
			    chat.lastUpdated = new Date().toISOString();
			    saveState();
			    renderChatMessages(true);
			    renderChatList();
			
			    currentOfflineScene = null;
			    navigateBack();
				setTimeout(() => {
				    const container = get('chat-messages-container');
				    if (container) {
				        container.scrollTop = container.scrollHeight;
				    }
				}, 100); 
			}
			// 6. 打开场景设置弹窗
// 【V3 最终版】
function openSceneSettings() {
    const chat = state.chats.find(c => c.id === currentChatId);
    if (!chat) return;
    const settings = chat.offlineSceneSettings;

    const modalHTML = `
        <h3>场景设置</h3>
        <div class="form-group">
            <label>场景背景 (URL或本地上传)</label>
            <input type="text" id="scene-bg-url-input" placeholder="输入图片 URL 或清空以移除背景" value="${settings.background && settings.background.startsWith('http') ? settings.background : ''}">
            <label class="upload-btn" style="margin-top: 8px;">
                上传本地背景 <input type="file" id="scene-bg-file-input" accept="image/*" style="display:none;">
            </label>
        </div>
        <h4>文本颜色设置</h4>
        <div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
            <div><label>AI 旁白</label><input type="color" id="color-narrative" value="${settings.colors.narrative}"></div>
            <div><label>你的对话</label><input type="color" id="color-user_dialogue" value="${settings.colors.user_dialogue}"></div>
            <div><label>你的行动</label><input type="color" id="color-user_action" value="${settings.colors.user_action}"></div>
            <div><label>你的内心</label><input type="color" id="color-user_internal" value="${settings.colors.user_internal}"></div>
            <div><label>你的旁白</label><input type="color" id="color-user_narrative" value="${settings.colors.user_narrative}"></div>
        </div>
		<h4>容器背景设置</h4>
		<div class="form-group">
		    <label>磨砂背景颜色</label>
		    <input type="color" id="color-container_bg" value="${settings.colors.container_bg}">
		    <label>透明度</label>
		    <input type="range" id="opacity-container_bg" min="0" max="1" step="0.05" value="${getOpacityFromRgba(settings.colors.container_bg)}">
		</div>
        <button id="save-scene-settings-btn" class="btn btn-primary">应用并关闭</button>
    `;
    showModal(modalHTML);

    const urlInput = get('scene-bg-url-input');
    const fileInput = get('scene-bg-file-input');
    const contentArea = get('scene-log-container');

    // 【核心新增】URL 输入框的实时更新逻辑
    urlInput.oninput = () => {
        const newUrl = urlInput.value.trim();
        settings.background = newUrl; // 直接更新 state
        if (newUrl) {
            contentArea.style.backgroundImage = `url(${newUrl})`;
        } else {
            contentArea.style.backgroundImage = 'none';
        }
    };

    // 【核心修改】本地上传的逻辑
    fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const base64String = event.target.result;
            settings.background = base64String; // 直接更新 state
            urlInput.value = ''; // 清空URL输入框，防止混淆
            urlInput.placeholder = '已使用本地图片';
            contentArea.style.backgroundImage = `url(${base64String})`;
        };
        reader.readAsDataURL(file);
    };

    // 【核心简化】"应用并关闭"按钮的逻辑
    get('save-scene-settings-btn').onclick = () => {
        // 背景已经在上面的事件中实时更新到 state 里了，这里无需再处理

        // 只需处理颜色
        settings.colors.narrative = get('color-narrative').value;
        settings.colors.user_dialogue = get('color-user_dialogue').value;
        settings.colors.user_action = get('color-user_action').value;
        settings.colors.user_internal = get('color-user_internal').value;
        settings.colors.user_narrative = get('color-user_narrative').value;
		const hexColor = get('color-container_bg').value;
		const opacity = get('opacity-container_bg').value;
		settings.colors.container_bg = setColorWithOpacity(hexColor, opacity);
        
        saveState(); // 保存最终状态
        renderOfflineSceneLog(); // 重新渲染日志以应用新颜色
        hideModal();
    };


    // 在 openSceneSettings 函数内
    get('scene-bg-file-input').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const newBackgroundValue = event.target.result;
            settings.background = newBackgroundValue;
            
            // 【核心修正】在这里清空 URL 输入框，并更新占位符
            const urlInput = get('scene-bg-url-input');
            urlInput.value = ''; // 清空
            urlInput.placeholder = '已使用本地图片，输入新URL可覆盖'; // 给出提示
    
           // 【核心修正】将错误的函数调用替换为实际的应用逻辑
            const contentArea = get('scene-log-container');
            if (newBackgroundValue) {
                contentArea.style.backgroundImage = `url(${newBackgroundValue})`;
                contentArea.style.backgroundSize = 'cover';
                contentArea.style.backgroundPosition = 'center';
            } else {
                contentArea.style.backgroundImage = 'none';
            }
        };
        reader.readAsDataURL(file);
    };
}


			// 8. 渲染故事选项按钮
			function renderSceneChoices(choices) {
			    const container = get('scene-choices-container');
			    container.innerHTML = choices.map(choiceText => {
			        // 移除 A. B. 这样的前缀
			        const cleanText = choiceText.replace(/^[A-Z]\.\s*/, '');
			        return `<button class="scene-choice-btn" data-choice="${cleanText}">${choiceText}</button>`;
			    }).join('');
			    // 禁用输入区，强制用户做选择
			    get('scene-input-area').style.display = 'none';
			}
			
			// 9. 处理用户选择
			function handleSceneChoice(choiceText) {
			    // 将用户的选择作为一个“行动”记录到日志中
			    currentOfflineScene.log.push({
			        type: 'user_input',
			        mode: 'action', // 我们将选择视为一种特殊的“行动”
			        content: `[选择了：${choiceText}]`
			    });
			    
			    // 清空选项并恢复输入区
			    get('scene-choices-container').innerHTML = '';
			    get('scene-input-area').style.display = 'block';
			
			    renderOfflineSceneLog();
			    // 立即请求 AI 对用户的选择做出反应
			    generateOfflineNarrative();
			}
        // --- 【新增】一个独立的函数来处理用户输入，方便复用 ---
        function addUserEntryToLog() {
            const content = sceneInput.value.trim();
            if (!content || !currentOfflineScene) return;
        
            const activeModeBtn = get('scene-input-mode-selector').querySelector('.active');
            const mode = activeModeBtn.dataset.mode;
        
            currentOfflineScene.log.push({
                type: 'user_input',
                mode: mode,
                content: content
            });
            
            sceneInput.value = '';
            sceneInput.style.height = 'auto';
            renderOfflineSceneLog();
        }
		// =================================================================
		// --- 【全新】纪念日 & 全局设置功能 ---
		// =================================================================
		
		// 1. 渲染纪念日列表页面
		function renderAnniversaryList() {
		    const container = get('anniversary-list-container');
		    if (state.anniversaries.length === 0) {
		        container.innerHTML = `<p style="text-align:center; color: var(--secondary-text); padding: 40px;">还没有纪念日，点击右上角添加一个吧</p>`;
		        return;
		    }
		
		    // 按日期排序，最近的在前
		    const sortedAnniversaries = [...state.anniversaries].sort((a, b) => {
		        const daysA = calculateDaysUntil(a.date);
		        const daysB = calculateDaysUntil(b.date);
		        return daysA - daysB;
		    });
		
		    container.innerHTML = sortedAnniversaries.map(ann => {
		        const daysUntil = calculateDaysUntil(ann.date);
		        let countdownText = `${daysUntil}`;
		        let countdownLabel = '天后';
		        let isTodayClass = '';
		
		        if (daysUntil === 0) {
		            countdownText = 'Today!';
		            countdownLabel = '就是今天！';
		            isTodayClass = 'is-today';
		        } else if (daysUntil < 0) {
		            countdownText = `${-daysUntil}`;
		            countdownLabel = '天前';
		        }
		
		        let typeText = '全局';
		        if (ann.type !== 'global') {
		            const chat = state.chats.find(c => c.id === ann.type);
		            typeText = chat ? `与 ${chat.settings.ai.name}` : '私密';
		        }
		
		        return `
		            <div class="anniversary-card" data-ann-id="${ann.id}" style="background-image: url(${ann.backgroundImage || ''}); color: ${ann.fontColor || '#FFFFFF'};">
		                <div class="anniversary-card-content">
		                    <div class="countdown ${isTodayClass}">${countdownText}</div>
		                    <div class="countdown-label">${countdownLabel}</div>
		                    <div class="title">${ann.title}</div>
		                    <div class="date">${ann.date}</div>
		                </div>
		                <div class="type-badge">${typeText}</div>
		            </div>
		        `;
		    }).join('');
		}
		
		// 2. 打开纪念日编辑器
		function openAnniversaryEditor(id = null) {
		    const titleEl = get('anniversary-edit-title');
		    const idInput = get('anniversary-edit-id');
		    const titleInput = get('anniversary-title-input');
		    const dateInput = get('anniversary-date-input');
		    const typeSelect = get('anniversary-type-select');
		    const bgColorInput = get('anniversary-bg-input');
		    const fontColorInput = get('anniversary-font-color-input');
		    const bgPreview = get('anniversary-bg-preview');
		    const deleteBtn = get('delete-anniversary-btn');
		
		    // 填充类型下拉框
		    typeSelect.innerHTML = '<option value="global">全局纪念日 (所有角色可见)</option>';
		    state.chats.filter(c => c.type === 'single').forEach(chat => {
		        typeSelect.innerHTML += `<option value="${chat.id}">与 ${chat.settings.ai.name} 相关</option>`;
		    });
		
		    if (id) {
		        const ann = state.anniversaries.find(a => a.id === id);
		        if (!ann) return;
		        titleEl.textContent = '编辑纪念日';
		        idInput.value = ann.id;
		        titleInput.value = ann.title;
		        dateInput.value = ann.date;
		        typeSelect.value = ann.type;
		        fontColorInput.value = ann.fontColor || '#FFFFFF';
		        bgPreview.src = ann.backgroundImage || '';
		        bgPreview.style.display = ann.backgroundImage ? 'block' : 'none';
		        deleteBtn.style.display = 'block';
		    } else {
		        titleEl.textContent = '添加纪念日';
		        idInput.value = '';
		        titleInput.value = '';
		        dateInput.value = new Date().toISOString().slice(0, 10);
		        typeSelect.value = 'global';
		        fontColorInput.value = '#FFFFFF';
		        bgPreview.src = '';
		        bgPreview.style.display = 'none';
		        deleteBtn.style.display = 'none';
		    }
		    navigateTo('anniversary-edit-page');
		}
		
		// 3. 保存纪念日
		function handleSaveAnniversary() {
		    const id = get('anniversary-edit-id').value;
		    const title = get('anniversary-title-input').value.trim();
		    const date = get('anniversary-date-input').value;
		    const type = get('anniversary-type-select').value;
		    const fontColor = get('anniversary-font-color-input').value;
		    const backgroundImage = get('anniversary-bg-preview').src;
		
		    if (!title || !date) {
		        showToast('标题和日期不能为空');
		        return;
		    }
		
		    const anniversaryData = { id: id || generateId('ann'), title, date, type, fontColor, backgroundImage, isRecurring: true };
		
		    if (id) {
		        const index = state.anniversaries.findIndex(a => a.id === id);
		        state.anniversaries[index] = anniversaryData;
		    } else {
		        state.anniversaries.push(anniversaryData);
		    }
		    
		    saveState();
		    showToast('纪念日已保存');
		    renderAnniversaryList();
		    navigateBack();
		}
		
		// 4. 删除纪念日
		function handleDeleteAnniversary() {
		    const id = get('anniversary-edit-id').value;
		    if (confirm('确定要删除这个纪念日吗？')) {
		        state.anniversaries = state.anniversaries.filter(a => a.id !== id);
		        saveState();
		        showToast('纪念日已删除');
		        renderAnniversaryList();
		        navigateBack();
		    }
		}
		
		
		// 6. 辅助函数：计算日期倒计时
		function calculateDaysUntil(targetDateStr) {
		    const targetDate = new Date(targetDateStr);
		    const now = new Date();
		    
		    // 将年份统一为今年，以计算循环纪念日
		    targetDate.setFullYear(now.getFullYear());
		    
		    // 如果纪念日已经过去，则计算到明年的
		    if (targetDate < now && targetDate.toDateString() !== now.toDateString()) {
		        targetDate.setFullYear(now.getFullYear() + 1);
		    }
		    
		    const diffTime = targetDate - now;
		    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
		    return diffDays;
		}
		
		// 7. 绑定所有新页面的事件监听
		function setupNewAppListeners() {
		    // 纪念日列表页
		    const addAnniversaryBtn = get('add-anniversary-btn');
		    if (addAnniversaryBtn) addAnniversaryBtn.addEventListener('click', () => openAnniversaryEditor(null));
		
		    const anniversaryListContainer = get('anniversary-list-container');
		    if (anniversaryListContainer) anniversaryListContainer.addEventListener('click', e => {
		        const card = e.target.closest('.anniversary-card');
		        if (card) {
		            openAnniversaryEditor(card.dataset.annId);
		        }
		    });
		
		    // 纪念日编辑页
		    const saveAnniversaryBtn = get('save-anniversary-btn');
		    if (saveAnniversaryBtn) saveAnniversaryBtn.addEventListener('click', handleSaveAnniversary);
		    
		    const deleteAnniversaryBtn = get('delete-anniversary-btn');
		    if (deleteAnniversaryBtn) deleteAnniversaryBtn.addEventListener('click', handleDeleteAnniversary);
		    
		    // setupAvatarUpload 内部已经有 get()，但为了安全，我们检查一下
		    if (get('anniversary-bg-input')) {
		        setupAvatarUpload('anniversary-bg-input', 'anniversary-bg-preview', (base64) => {
		            get('anniversary-bg-preview').src = base64;
		        });
		    }
		
		    // 全局设置页
		    const timeToggle = get('enable-time-awareness-toggle');
		    if (timeToggle) timeToggle.addEventListener('change', (e) => {
		        state.globalSettings.enableTimeAwareness = e.target.checked;
		        saveState();
		        showToast(`AI时间感知已${e.target.checked ? '开启' : '关闭'}`);
		    });
		}
		// --- 【全新】全局美化核心函数 ---
				// 1. 【全新】应用主题颜色的核心函数
						// 1. 【终极修正版】应用主题颜色的核心函数
			function applyThemeColors(colors) {
					    const root = document.documentElement;
					    const colorMap = {
					        accent: '--accent-color',
					        primaryText: '--primary-text',
					        secondaryText: '--secondary-text',
					        phoneBg: '--phone-bg',
					        globalBg: '--bg-color',
					        borderColor: '--border-color',
							homeTextColor: '--home-text-color'
					    };
					    for (const key in colors) {
					        if (colorMap[key]) {
					            root.style.setProperty(colorMap[key], colors[key]);
					        }
					        // 【核心修正】特殊处理头部背景
					        if (key === 'headerBg') {
					            root.style.setProperty('--header-bg-rgb', hexToRgb(colors[key]));
					        }
					    }
					}
					
					
				// 0. 【全新】颜色转换工具函数
		function hexToRgb(hex) {
		    let r = 0, g = 0, b = 0;
		    // 3 digit hex
		    if (hex.length == 4) {
		        r = "0x" + hex[1] + hex[1];
		        g = "0x" + hex[2] + hex[2];
		        b = "0x" + hex[3] + hex[3];
		    }
		    // 6 digit hex
		    else if (hex.length == 7) {
		        r = "0x" + hex[1] + hex[2];
		        g = "0x" + hex[3] + hex[4];
		        b = "0x" + hex[5] + hex[6];
		    }
		    return `${+r}, ${+g}, ${+b}`;
		}
		
		
		// 1. 在页面加载或设置保存后，应用所有全局样式
		function applyGlobalStyles() {
		    const settings = state.globalSettings;
		
		    // a. 应用字体
		     const oldFontTag = document.getElementById('global-font-style');
		        if (oldFontTag) oldFontTag.remove(); // 移除旧的样式
		    
		        if (settings.customFontCss) { // 检查是否有自定义字体CSS
		            const style = document.createElement('style');
		            style.id = 'global-font-style';
		            style.textContent = settings.customFontCss;
		            document.head.appendChild(style);
		        }
		
		    // b. 应用壁纸
		    const homeScreenContent = get('home-screen-content');
		    if (homeScreenContent) {
		        if (settings.wallpaperUrl) {
		            homeScreenContent.style.backgroundImage = `url(${settings.wallpaperUrl})`;
		        } else {
		            // 默认的深色背景
		            homeScreenContent.style.backgroundImage = 'linear-gradient(to bottom, #2b324a, #1c1c1e)';
		        }
		    }
		
		    // c. 应用小组件样式
		    const widgetArea = get('home-widget-area');
		    if (widgetArea) {
		        widgetArea.style.background = settings.widget.background;
		        widgetArea.style.color = settings.widget.fontColor;
		    }
		
		    // d. 应用图标 (这会在渲染主屏幕时处理)
		    renderHomeScreen(); 
		}
		//纪念日小组件
		function renderAnniversaryWidget() {
		    const container = get('home-widget-anniversary').querySelector('.home-widget-inner');
		    if (!container) return;
		
		    const upcomingAnniversaries = state.anniversaries
		        .map(ann => ({ ...ann, daysUntil: calculateDaysUntil(ann.date) }))
		        .filter(ann => ann.daysUntil >= 0) // 只看还没到的
		        .sort((a, b) => a.daysUntil - b.daysUntil);
		
		    if (upcomingAnniversaries.length > 0) {
		        const nextAnn = upcomingAnniversaries[0];
		        container.innerHTML = `
		            <div>
		                <div class="widget-anniversary-days">${nextAnn.daysUntil}</div>
		                <div class="widget-anniversary-label">Days</div>
		            </div>
		            <div class="widget-anniversary-title">${nextAnn.title}</div>
		        `;
		    } else {
		        container.innerHTML = `
		            <div>
		                <div class="widget-anniversary-days">🎉</div>
		                <div class="widget-anniversary-label"></div>
		            </div>
		            <div class="widget-anniversary-title">暂无即将到来的纪念日</div>
		        `;
		    }
		
		    // 应用自定义样式
		    const widgetSettings = state.globalSettings.widget;
		    if (widgetSettings.anniversaryBg) {
		        container.style.backgroundImage = `url(${widgetSettings.anniversaryBg})`;
		    }
		    if (widgetSettings.anniversaryColor) {
		        container.style.color = widgetSettings.anniversaryColor;
		    }
		}
		
		//音乐小组件
		function renderMusicWidget() {
		    const container = get('home-widget-music-inner');
		    if (!container) return;
		
		    const playbackState = state.music.playbackState;
		    const currentSong = state.music.playlist[playbackState.currentTrackIndex];
		
		    // 默认的封面
		    const defaultCover = 'https://files.catbox.moe/608ojk.jpg';
		    // 优先用当前歌曲封面，其次是全局封面，最后是默认封面
		    const coverUrl = currentSong?.cover || state.music.vinylCover || defaultCover;
		
		    // 根据播放状态决定是否添加 .playing 类
		    const playingClass = playbackState.isPlaying ? 'playing' : '';
		
		    // 动态生成黑胶唱片的HTML
		    container.innerHTML = `
		        <div class="widget-vinyl-container">
		            <div class="widget-vinyl-record ${playingClass}">
		                <div class="widget-vinyl-cover" style="background-image: url(${coverUrl});"></div>
		            </div>
		        </div>
		    `;
		}
		// 2. 渲染全新的主屏幕
		// ▼▼▼ 用下面的完整函数替换你现有的 renderHomeScreen 函数 ▼▼▼
		function renderHomeScreen() {
		    // 1. 内部函数和数据 (这部分几乎不变)
		    const appDetails = {
		        'chat-list-page': { name: '聊天', icon: '#icon-chat' },
		        'moments-page': { name: '朋友圈', icon: '#icon-moments' },
		        'anniversary-list-page': { name: '纪念日', icon: '#icon-anniversary-new' },
		        'global-settings-page': { name: '设置', icon: '#icon-settings' },
		        'music-app-page': { name: '音乐', icon: '#icon-music' },
		        'fanfic-forum-page': { name: '论坛', icon: '#icon-forum-new' },
		        'world-book-list-page': { name: '世界书', icon: '#icon-book' },
		        'diary-character-list-page': { name: '日记', icon: '#icon-journal' },
		        'api-settings-page': { name: 'API', icon: '#icon-key' }
		    };
		
		    const createIconHtml = (target, typeClass) => {
		        const details = appDetails[target];
		        if (!details) return '';
		        const customIconUrl = state.globalSettings.customIcons[target];
		        let content = customIconUrl
		            ? `<div class="app-icon-bg" style="background-image: url(${customIconUrl}); background-size: cover; backdrop-filter: none;"></div>`
		            : `<div class="app-icon-bg"></div><svg class="svg-icon"><use href="${details.icon}"></use></svg>`;
		        
		        // 【核心修改】现在App名称只为大图标的“内胆”生成
		        //const nameHtml = typeClass === 'app-icon-large-inner' ? `<span class="app-name">${details.name}</span>` : '';
		        
		        return `<div class="${typeClass}" data-target="${target}">${content}</div>`;
		    };
		
		    const appOrder = {
		        mainRight: ['moments-page', 'music-app-page', 'fanfic-forum-page', 'diary-character-list-page'],
		        dock: ['api-settings-page', 'world-book-list-page', 'global-settings-page', 'anniversary-list-page']
		    };
		
		    // 2. 填充网格内容
		    
		    // 【核心修改】这是本次修复的关键！
		    // 我们不再修改 chatContainer 的 innerHTML，而是修改它内部的 .app-icon-large-inner
		    const chatContainer = get('home-app-chat');
		    if (chatContainer) {
		        // 我们直接把完整的、带 app-icon-large-inner 类的图标 HTML 塞进去
		        // 这样就完美匹配了新的 CSS 规则
		        chatContainer.innerHTML = createIconHtml('chat-list-page', 'app-icon-large-inner');
		    }
		
		    const smallGrid = get('home-app-grid-top-right');
		    if (smallGrid) smallGrid.innerHTML = appOrder.mainRight.map(target => createIconHtml(target, 'app-icon-small')).join('');
		    
		    const dock = get('home-bottom-dock');
		    if (dock) dock.innerHTML = appOrder.dock.map(target => createIconHtml(target, 'app-icon-dock')).join('');
		
		    // 3. 渲染小组件 (无变化)
		    renderAnniversaryWidget();
		    renderMusicWidget();
		
		    // 4. 绑定事件 (无变化)
		    const homeContent = get('home-screen-content');
		    if(homeContent) {
		        if(homeContent.homeClickListener) homeContent.removeEventListener('click', homeContent.homeClickListener);
		        homeContent.homeClickListener = (e) => {
		            const icon = e.target.closest('[data-target]');
		            if (icon && icon.dataset.target) {
		                navigateTo(icon.dataset.target);
		            }
		        };
		        homeContent.addEventListener('click', homeContent.homeClickListener);
		    }
		}
		
		// 3. 渲染全局设置页面
		// 完整替换现有的 renderGlobalSettingsPage 函数
		function renderGlobalSettingsPage() {
		    const settings = state.globalSettings;
		    const widgetSettings = settings.widget;
		
		    get('enable-time-awareness-toggle').checked = settings.enableTimeAwareness;
		    get('global-font-css-input').value = settings.customFontCss || '';
		    get('wallpaper-preview').src = settings.wallpaperUrl;
		    
		    // VVVV 修改这里以加载新设置 VVVV
		    get('widget-anniversary-color-input').value = widgetSettings.anniversaryColor || '#FFFFFF';
		    // ^^^^ 修改结束 ^^^^
			  const themeColors = settings.themeColors;
		    get('theme-color-accent').value = themeColors.accent;
		    get('theme-color-primary-text').value = themeColors.primaryText;
		    get('theme-color-secondary-text').value = themeColors.secondaryText;
		    get('theme-color-phone-bg').value = themeColors.phoneBg;
		    get('theme-color-global-bg').value = themeColors.globalBg;
		    get('theme-color-header-bg').value = themeColors.headerBg;
		    get('theme-color-border-color').value = themeColors.borderColor;
			get('theme-color-home-text').value = themeColors.homeTextColor;
		
		    const iconsContainer = get('custom-icons-container');
		    iconsContainer.innerHTML = Object.keys(settings.customIcons).map(target => {
		        const appName = target.replace(/-page|-list/g, '').replace(/-/g, ' ');
		        return `
		            <div class="form-group">
		                <label style="text-transform: capitalize;">${appName} Icon URL</label>
		                <input type="text" class="custom-icon-input" data-target="${target}" value="${settings.customIcons[target] || ''}">
		            </div>
		        `;
		    }).join('');
			
		    const chatIconsContainer = get('custom-chat-icons-container');
		       const chatIconSettings = [
		           { key: 'plus', label: '更多(+)按钮' },
		           { key: 'sendAsUser', label: '“我”发送按钮' },
		           { key: 'send', label: 'AI回复/发送按钮' },
		           { key: 'loading', label: 'AI回复时加载中图标' },
		           { key: 'back', label: '聊天顶部返回按钮' },
		           { key: 'more', label: '聊天顶部更多(...)按钮' },
		       ];
		       chatIconsContainer.innerHTML = chatIconSettings.map(item => `
		           <div class="form-group">
		               <label>${item.label} Icon URL</label>
		               <input type="text" class="custom-chat-icon-input" data-key="${item.key}" value="${state.globalSettings.chatIcons[item.key] || ''}">
		           </div>
		       `).join('');
		}
		
		// 6. 绑定所有设置页面的事件
		function setupGlobalSettingsListeners() {
		
		    // 壁纸上传
		    setupAvatarUpload('wallpaper-upload-input', 'wallpaper-preview', (base64) => {
		        state.globalSettings.wallpaperUrl = base64;
		        // 不在这里保存，等待用户点击总的保存按钮
		    });
		    get('clear-wallpaper-btn').onclick = () => {
		        get('wallpaper-preview').src = '';
		        state.globalSettings.wallpaperUrl = '';
		    };
			setupAvatarUpload('widget-anniversary-bg-input', null, (base64) => {
			        state.globalSettings.widget.anniversaryBg = base64;
			        showToast('纪念日背景已暂存，点击保存生效');
			    });
			
			  // ▼▼▼ 全新代码：处理所有新的颜色选择器 ▼▼▼
		    const colorSelectors = get('theme-color-selectors');
		    if (colorSelectors) {
		        // 实时预览
		        colorSelectors.addEventListener('input', (e) => {
		            if (e.target.type === 'color') {
		                const variable = e.target.dataset.variable;
		                const value = e.target.value;
                        
                        // 特殊处理头部背景的实时预览
                        if (variable === '--headerBg') {
                            document.documentElement.style.setProperty('--header-bg-rgb', hexToRgb(value));
                        } else {
		                    document.documentElement.style.setProperty(variable, value);
                        }
		            }
		        });
		    }
            
            const resetBtn = get('reset-theme-colors-btn');
            if (resetBtn) {
                // 【核心修正】“恢复默认”按钮的正确逻辑
                resetBtn.addEventListener('click', () => {
                    if (confirm('确定要将颜色恢复为默认主题吗？')) {
                        const defaultColors = defaultState.globalSettings.themeColors;
                        
                        // 1. 立即将页面的实时样式恢复为默认
                        applyThemeColors(defaultColors);
                        
                        // 2. 将颜色选择器输入框的值也恢复为默认
                        get('theme-color-accent').value = defaultColors.accent;
		                get('theme-color-primary-text').value = defaultColors.primaryText;
		                get('theme-color-secondary-text').value = defaultColors.secondaryText;
		                get('theme-color-phone-bg').value = defaultColors.phoneBg;
		                get('theme-color-global-bg').value = defaultColors.globalBg;
		                get('theme-color-header-bg').value = defaultColors.headerBg;
		                get('theme-color-border-color').value = defaultColors.borderColor;
						get('theme-color-home-text').value = defaultColors.homeTextColor;

                        showToast('已恢复默认颜色');
                    }
                });
            }
		    // ▲▲▲ 代码结束 ▲▲▲
		
		    // 保存所有设置
		   get('save-global-settings-btn').onclick = () => {
		           // VVVV 修改这里以保存新设置 VVVV
		           const widgetSettings = state.globalSettings.widget;
		           widgetSettings.anniversaryColor = get('widget-anniversary-color-input').value;
				   state.globalSettings.customFontCss = get('global-font-css-input').value.trim();
		           // 注意：背景图片已经在上传时直接存入 state.globalSettings.widget 了
		           // ^^^^ 修改结束 ^^^^
		   
		           document.querySelectorAll('.custom-icon-input').forEach(input => {
		               state.globalSettings.customIcons[input.dataset.target] = input.value.trim();
		           });
				   
				const themeColors = state.globalSettings.themeColors;
                themeColors.accent = get('theme-color-accent').value;
                themeColors.primaryText = get('theme-color-primary-text').value;
                themeColors.secondaryText = get('theme-color-secondary-text').value;
                themeColors.phoneBg = get('theme-color-phone-bg').value;
                themeColors.globalBg = get('theme-color-global-bg').value;
                themeColors.headerBg = get('theme-color-header-bg').value;
                themeColors.borderColor = get('theme-color-border-color').value;
				themeColors.homeTextColor = get('theme-color-home-text').value;
				
				document.querySelectorAll('.custom-chat-icon-input').forEach(input => {
				            const key = input.dataset.key;
				            if (state.globalSettings.chatIcons.hasOwnProperty(key)) {
				                state.globalSettings.chatIcons[key] = input.value.trim();
				            }
				        });
		   
		           saveState();
		           applyGlobalStyles();
				   applyCustomChatIcons();
		           showToast('全局设置已保存并应用！');
		           navigateBack();
		       };
			const exportBtn = get('export-data-btn');
			const importInput = get('import-data-input');
			
			// 导出数据逻辑
			exportBtn.addEventListener('click', async () => {
			    showToast('正在准备数据...');
			    try {
			        const fullState = await loadStateDB();
			        if (!fullState) {
			            showToast('无法加载数据进行导出', 3000);
			            return;
			        }
			
			        const jsonString = JSON.stringify(fullState, null, 2); // 格式化JSON，方便阅读
			        const blob = new Blob([jsonString], { type: 'application/json' });
			        const url = URL.createObjectURL(blob);
			
			        const a = document.createElement('a');
			        const today = new Date().toISOString().slice(0, 10);
			        a.href = url;
			        a.download = `AiPhone_Backup_${today}.json`;
			        document.body.appendChild(a);
			        a.click();
			        document.body.removeChild(a);
			
			        URL.revokeObjectURL(url); // 释放内存
			        showToast('数据已开始下载！', 3000);
			
			    } catch (error) {
			        console.error('导出失败:', error);
			        showToast(`导出失败: ${error.message}`, 4000);
			    }
			});
			
			// 导入数据逻辑
			importInput.addEventListener('change', (e) => {
			    const file = e.target.files[0];
			    if (!file) return;
			
			    // 第一次确认：合并还是覆盖？
			    const importMode = confirm(
			        '请选择导入模式：\n\n' +
			        '【确定】= 智能合并 (推荐)\n' +
			        '在现有数据基础上，添加备份文件中没有的新聊天、新世界书等。会询问如何处理设置。\n\n' +
			        '【取消】= 完全覆盖\n' +
			        '删除手机当前所有数据，用备份文件完全替代。'
			    );
			
                if (importMode) {
                        // --- 用户选择了“智能合并” ---
                        const reader = new FileReader();
                        reader.onload = async (event) => {
                            try {
                                const importedState = JSON.parse(event.target.result);
                                if (!importedState || !importedState.chats) throw new Error('文件格式无效。');
                
                                showToast('正在准备合并数据...');
                                const currentState = await loadStateDB() || JSON.parse(JSON.stringify(defaultState));
                                const newState = JSON.parse(JSON.stringify(currentState));
                
                                // 1. 合并所有列表型数据
                                const listsToMerge = ['chats', 'worldBooks', 'moments', 'diaries', 'fanfics', 'anniversaries', 'stickerLibrary'];
                                listsToMerge.forEach(key => {
                                    // 确保当前状态和导入状态中都有这个数组
                                    if (Array.isArray(newState[key]) && Array.isArray(importedState[key])) {
                                        const existingIds = new Set(newState[key].map(item => item.id));
                                        importedState[key].forEach(itemToImport => {
                                            // 只要ID不存在，就添加进来，不再关心它是否被“喜欢”
                                            if (itemToImport.id && !existingIds.has(itemToImport.id)) {
                                                newState[key].push(itemToImport);
                                            }
                                        });
                                    }
                                });
                
                                // ▼▼▼ 【核心修复】为非数组类型的数据（如音乐播放列表）进行特殊处理 ▼▼▼
                                if (importedState.music && typeof importedState.music === 'object') {
                                    // 简单策略：如果当前没有播放列表，就用导入的
                                    if (newState.music.playlist.length === 0) {
                                        newState.music = importedState.music;
                                    }
                                }
                                // ▲▲▲ 修复结束 ▲▲▲
                
                                // 2. 询问用户如何处理设置型数据
                                const keepSettings = confirm(
                                    '对于“API设置”和“全局设置”：\n\n' +
                                    '【确定】= 保留手机当前的设置。\n\n' +
                                    '【取消】= 使用备份文件中的设置来覆盖。'
                                );
                
                                if (!keepSettings) {
                                    newState.apiSettings = importedState.apiSettings;
                                    newState.globalSettings = importedState.globalSettings;
                                }
                                
                                // 3. 保存合并后的新状态
                                await saveStateDB(newState);
                                showToast('数据合并成功！应用即将刷新...', 3000);
                                setTimeout(() => location.reload(), 3000);
                
                            } catch (error) {
                                console.error('合并失败:', error);
                                showToast(`合并失败: ${error.message}`, 4000);
                            } finally {
                                e.target.value = '';
                            }
                        };
                        reader.readAsText(file);
  			    } else {
			        // --- 用户选择了“完全覆盖”（保持原有逻辑） ---
			        const confirmation = confirm(
			            '【警告】\n\n“完全覆盖”将删除当前所有数据！此操作不可撤销！\n\n您确定要继续吗？'
			        );
			        if (!confirmation) {
			            e.target.value = '';
			            showToast('导入已取消', 2000);
			            return;
			        }
			
			        const reader = new FileReader();
			        reader.onload = async (event) => {
			            try {
			                const importedState = JSON.parse(event.target.result);
			                if (importedState && importedState.chats && importedState.apiSettings) {
			                    await saveStateDB(importedState);
			                    showToast('数据覆盖成功！应用即将刷新...', 3000);
			                    setTimeout(() => location.reload(), 3000);
			                } else {
			                    throw new Error('文件格式无效或已损坏。');
			                }
			            } catch (error) {
			                console.error('覆盖失败:', error);
			                showToast(`覆盖失败: ${error.message}`, 4000);
			            } finally {
			                e.target.value = '';
			            }
			        };
			        reader.readAsText(file);
			    }
			});
		}
		
		
		
		// 7. 更新时间
		function updateSystemTime() {
		    const now = new Date();
		    const timeEl = get('home-time');
		    const dateEl = get('home-date');
		    if(timeEl && dateEl) {
		        timeEl.textContent = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
		        const dayOfWeek = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()];
		        dateEl.textContent = `${now.getMonth() + 1}月${now.getDate()}日 ${dayOfWeek}`;
		    }
		}
	 
	    //三个小圆点
		// ▼▼▼ 使用这个新版本替换你原来的 setupChatHeaderMenu 函数 ▼▼▼
		function setupChatHeaderMenu() {
		    const moreBtn = get('chat-more-options-btn');
		    const menu = get('chat-header-menu'); // 现在获取的是全局菜单
		
		    // 安全检查，如果HTML元素不存在则直接退出
		    if (!moreBtn || !menu) {
		        console.error("聊天页面的“更多”按钮或全局菜单的HTML结构丢失！");
		        return;
		    }
		
		    // --- 控制菜单的显示和隐藏 ---
		    moreBtn.addEventListener('click', (e) => {
		        e.stopPropagation(); // 阻止点击事件冒泡到 document
		
		        if (menu.style.display === 'block') {
		            menu.style.display = 'none';
		        } else {
		            // 计算菜单应该出现的位置
		            const phoneBodyRect = get('phone-body').getBoundingClientRect();
		            const btnRect = moreBtn.getBoundingClientRect();
		
		            // 菜单的顶部 = 按钮的底部 - 手机容器的顶部 + 一点间距
		            const top = btnRect.bottom - phoneBodyRect.top + 5; 
		            // 菜单的右侧 = 手机容器的右侧 - 按钮的右侧
		            const right = phoneBodyRect.right - btnRect.right;
		
		            // 应用计算出的位置
		            menu.style.top = `${top}px`;
		            menu.style.right = `${right}px`;
		            menu.style.left = 'auto'; // 确保 left 样式被重置
		            
		            menu.style.display = 'block';
		        }
		    });
		
		    // --- 在文档任意位置点击，隐藏菜单 ---
		    document.addEventListener('click', (e) => {
		        if (menu.style.display === 'block' && !menu.contains(e.target) && !moreBtn.contains(e.target)) {
		            menu.style.display = 'none';
		        }
		    });
		
		    // --- 使用事件委托处理菜单项的点击 (逻辑不变) ---
		    menu.addEventListener('click', (e) => {
		        const menuItem = e.target.closest('.context-menu-item');
		        if (!menuItem) return;
		
		        const action = menuItem.dataset.action;
		        
		        // 点击后立即隐藏菜单
		        menu.style.display = 'none';
		
		        switch (action) {
		            case 'search':
		                openChatSearch();
		                break;
		            case 'music':
		                showListenTogetherModal();
		                break;
		            case 'settings':
		                const chat = state.chats.find(c => c.id === currentChatId);
		                if (!chat) return;
		                if (chat.type === 'group') {
		                    openGroupChatSettings();
		                } else {
		                    openSingleChatSettings();
		                }
		                break;
		        }
		    });
		}
		// 图标url聊天页面
		function applyCustomChatIcons() {
		    const icons = state.globalSettings.chatIcons;
		    const styleId = 'custom-chat-icons-style';
		    let styleTag = document.getElementById(styleId);
		
		    // 如果 style 标签不存在，就创建一个
		    if (!styleTag) {
		        styleTag = document.createElement('style');
		        styleTag.id = styleId;
		        document.head.appendChild(styleTag);
		    }
		
		    const iconMap = {
		        plus: '#show-actions-btn',
		        sendAsUser: '#send-as-user-btn',
		        send: '#call-api-btn',
		        back: '#chat-page .app-header .back-btn',
		        more: '#chat-more-options-btn',
		    };
		
		    let cssRules = '';
		
		    for (const key in iconMap) {
		        if (icons[key]) {
		            const selector = iconMap[key];
		            cssRules += `
		                ${selector} {
		                    background-image: url('${icons[key]}') !important;
		                }
		                ${selector} {
		                    /* 应用通用样式 */
		                    background-size: 60% !important;
		                    background-position: center !important;
		                    background-repeat: no-repeat !important;
		                }
		                /* 应用隐藏和透明的特定样式 */
		                ${selector}.input-action-btn {
		                    background-color: transparent !important;
		                }
		                ${selector} .svg-icon {
		                    display: none !important;
		                }
		            `;
		        }
		    }
		    
		    // 特殊处理加载中图标
		    if (icons.loading) {
		        cssRules += `
		            #call-api-btn.is-loading {
		                background-image: url('${icons.loading}') !important;
		                animation: spin 1.5s linear infinite;
		            }
		            #call-api-btn.is-loading .spinner {
		                display: none !important;
		            }
		        `;
		    }
		
		    styleTag.textContent = cssRules;
		}
		// ▲▲▲ 全新函数结束 ▲▲▲
		
		// --- 【全新】设置主聊天 App 页面（页签切换等）的函数 ---
		function setupChatAppMainPage() {
		    const navContainer = get('app-bottom-nav');
		    const contentContainer = get('chat-app-content');
		    const titleEl = get('chat-app-main-title');
		    const addBtn = get('add-chat-btn');
		
		    if (!navContainer || !contentContainer) return;
		
		    navContainer.addEventListener('click', (e) => {
		        const targetBtn = e.target.closest('.nav-btn');
		        if (!targetBtn) return;
		
		        const tabName = targetBtn.dataset.tab;
		
		        // 如果点击的是朋友圈，直接跳转，不走页签切换逻辑
		        if (tabName === 'moments') {
		            navigateTo('moments-page');
		            return;
		        }
		
		        // 切换导航按钮的激活状态
		        navContainer.querySelector('.nav-btn.active').classList.remove('active');
		        targetBtn.classList.add('active');
		
		        // 切换内容面板的显示
		        contentContainer.querySelectorAll('.tab-pane').forEach(pane => {
		            pane.style.display = 'none';
		        });
		        get(`tab-pane-${tabName}`).style.display = 'flex'; // 使用 flex 以支持内部滚动
		
		        // 根据页签更新页面标题和右上角按钮
		        switch (tabName) {
		            case 'chat':
		                titleEl.textContent = '聊天';
		                addBtn.style.display = 'block';
		                renderChatList(); // 每次切回都刷新列表
		                break;
		            case 'contacts':
		                titleEl.textContent = '联系人';
		                addBtn.style.display = 'none'; // 联系人页面暂时不显示+号
		                renderContactsPage(); // 渲染联系人页面
		                break;
		            case 'me':
		                titleEl.textContent = '我';
		                addBtn.style.display = 'none';
		                renderMePage(); // 渲染“我”的页面
		                break;
		        }
		    });
		
		    // 默认加载聊天列表
		    renderChatList();
		}

        // --- 【全新】渲染联系人页面的函数 ---
        function renderContactsPage() {
            const container = get('contacts-list-container');
            
            // 1. 按类型分组
            const singleChats = state.chats.filter(c => c.type === 'single');
            const groupChats = state.chats.filter(c => c.type === 'group');
        
            let html = '';
        
            // 2. 渲染群聊部分
            if (groupChats.length > 0) {
                html += `<div class="contact-section-header">群聊</div>`;
                groupChats.forEach(chat => {
                    html += `
                        <div class="list-item chat-list-item" data-chat-id="${chat.id}">
                            <img class="chat-list-avatar" src="${chat.settings.members[0]?.avatar || defaultAiAvatar}" />
                            <div class="info">
                                <div class="name">${chat.settings.groupName}</div>
                            </div>
                        </div>`;
                });
            }
        
            // 3. 渲染单聊联系人部分
            if (singleChats.length > 0) {
                html += `<div class="contact-section-header">联系人</div>`;
                singleChats.forEach(chat => {
                    html += `
                        <div class="list-item chat-list-item" data-chat-id="${chat.id}">
                            <img class="chat-list-avatar" src="${chat.settings.ai.avatar || defaultAiAvatar}" />
                            <div class="info">
                                <div class="name">${chat.settings.ai.name}</div>
                            </div>
                        </div>`;
                });
            }
        
            container.innerHTML = html;
        }
		
		// --- 【全新】为联系人搜索框绑定事件 ---
		function setupContactsSearch() {
		    const searchInput = get('contacts-search-input');
		    if (!searchInput) return;
		
		    searchInput.addEventListener('input', (e) => {
		        const keyword = e.target.value.trim().toLowerCase();
		        const contactItems = document.querySelectorAll('#contacts-list-container .chat-list-item');
		
		        contactItems.forEach(item => {
		            const name = item.querySelector('.name').textContent.toLowerCase();
		            if (name.includes(keyword)) {
		                item.style.display = 'flex';
		            } else {
		                item.style.display = 'none';
		            }
		        });
		    });
		}

		
		//function updateLayoutForMusicPlayer() ,function renderMusicPlayer() ,else if (transferToMatch)
		//function startCall(type),function setupCallPageListeners(),function hangupCall(),挂断final
    // --- INITIALIZATION ---
    async function initialize() {
        await loadState();
		applyCustomChatIcons(); 
		 applyThemeColors(state.globalSettings.themeColors);
		renderChatList();
		renderApiSettingsPage();
        renderWorldBookList();
		renderHomeScreen(); // 渲染新主屏幕
		applyGlobalStyles(); // 应用保存的样式
		updateSystemTime();
		setInterval(updateSystemTime, 1000 * 30);
		setupGlobalSettingsListeners();
		 setupApiSettingsPageListeners();
		applyMusicAppWallpaper();
		setupStickerLibraryListeners();
        setupCallPageListeners();
        setupVideoImageSettingsListeners();
        setupIncomingCallListeners();
	    setupNewAppListeners();
		 setupChatHeaderMenu();
		 setupChatAppMainPage(); // 设置页签切换
		setupContactsSearch();  // 绑定联系人搜索事件

    // --- 【全新】启动温馨小屋相关功能 ---
    // 绑定事件
    get('ph-close-btn').onclick = () => get('pet-house-overlay').classList.remove('show');
    get('ph-adopt-pet-btn').onclick = () => handleAdoption('pet');
    get('ph-adopt-plant-btn').onclick = () => handleAdoption('plant');
    get('ph-open-shop-btn').onclick = openShop;
    get('shop-close-btn').onclick = () => get('shop-overlay').classList.remove('show');
    
    get('ph-tabs').addEventListener('click', e => {
        if (e.target.classList.contains('ph-tab-btn')) {
            document.querySelectorAll('.ph-tab-btn, .ph-content').forEach(el => el.classList.remove('active'));
            e.target.classList.add('active');
            get(e.target.dataset.target).style.display = 'block';
            if(e.target.dataset.target === 'ph-pet-view') {
                get('ph-plant-view').style.display = 'none';
            } else {
                get('ph-pet-view').style.display = 'none';
            }
        }
    });
    
    get('shop-items-container').addEventListener('click', e => {
        if (e.target.classList.contains('shop-item-buy-btn')) {
            handleBuyItem(e.target.dataset.itemId);
        }
    });
    get('ph-inventory-container').addEventListener('click', e => {
        if (e.target.classList.contains('use-item-btn')) {
            handleUseItem(e.target.dataset.itemId);
        }
    });

    // 启动全局状态衰减定时器
    setInterval(updateAllPetsAndPlantsStatus, 60 * 60 * 1000); // 每小时执行一次
	
	// --- 【全新】绑定线下剧场页面的事件 ---
	get('scene-settings-btn').addEventListener('click', openSceneSettings);
    const sendUserEntryBtn = get('send-user-entry-btn');
    const generateAiNarrativeBtn = get('generate-ai-narrative-btn');
   sceneInput = get('scene-input'); 
    
    // “仅记录我的话/动作” 按钮
    sendUserEntryBtn.addEventListener('click', () => {
        addUserEntryToLog();
    });
    
    // “让AI续写故事” 按钮
    generateAiNarrativeBtn.addEventListener('click', async () => {
        // 先将输入框中的内容记录下来，再请求AI
        await addUserEntryToLog();
        // 只有当日志中有新内容时才请求AI
        if (currentOfflineScene && currentOfflineScene.log.length > 0) {
            await generateOfflineNarrative();
        }
    });
    
    sceneInput.addEventListener('keypress', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            // 回车默认触发“AI续写”
            generateAiNarrativeBtn.click();
        }
    });
	// “结束场景”和“模式选择”按钮的绑定保持不变
	get('finish-scene-btn').addEventListener('click', finishOfflineScene);
	get('scene-input-mode-selector').addEventListener('click', e => {
	    if (e.target.classList.contains('scene-input-mode-btn')) {
	        get('scene-input-mode-selector').querySelectorAll('.active').forEach(b => b.classList.remove('active'));
	        e.target.classList.add('active');
	    }
	});
	get('scene-choices-container').addEventListener('click', e => {
	    if (e.target.classList.contains('scene-choice-btn')) {
	        handleSceneChoice(e.target.dataset.choice);
	    }
	});
	
	 get('scene-log-container').addEventListener('click', e => {
        if (e.target.classList.contains('scene-entry-delete-btn')) {
            const indexToDelete = parseInt(e.target.dataset.logIndex, 10);
            if (!isNaN(indexToDelete) && currentOfflineScene) {
                // Remove the item from the log array
                currentOfflineScene.log.splice(indexToDelete, 1);
                // Save the change and re-render the view
                saveState();
                renderOfflineSceneLog();
                showToast('条目已删除');
            }
        }
    });
	const heartVoiceOverlay = get('heart-voice-overlay');
	    if (heartVoiceOverlay) {
	        heartVoiceOverlay.addEventListener('click', (e) => {
	            // 点击遮罩层或气泡本身都可以关闭
	            if (e.target === heartVoiceOverlay || e.target.closest('#heart-voice-bubble')) {
	                hideHeartVoice();
	            }
	        });
	    }

		
	
}
    //宠物改名
	// 在 initialize 或 setupPetHouseListeners 函数中添加
	const petHouseModal = get('pet-house-modal');
	petHouseModal.addEventListener('click', e => {
	    if (e.target.classList.contains('rename-btn')) {
	        const type = e.target.dataset.type; // 'pet' or 'plant'
	        const chat = state.chats.find(c => c.id === currentChatId);
	        if (!chat || !chat.petAndPlant) return;
	
	        const creature = chat.petAndPlant[type];
	        if (!creature) return;
	
	        // 使用 prompt 弹窗让用户输入新名字
	        const newName = prompt(`为你的${type === 'pet' ? '宠物' : '植物'}取一个新名字：`, creature.name);
	
	        if (newName && newName.trim() && newName !== creature.name) {
	            const oldName = creature.name;
	            creature.name = newName.trim();
	            saveState();
	            renderPetHouse(); // 重新渲染小屋以显示新名字
	            addCareLog(`${oldName} 现在有了一个新名字，叫做 ${creature.name}。`);
	            showToast(`改名成功！`);
	        }
	    }
		if (e.target.id === 'render-adopt-pet-btn') {
		        handleAdoption('pet');
		    }
		    // 【新增】处理“种植植物”按钮
		    if (e.target.id === 'render-adopt-plant-btn') {
		        handleAdoption('plant');
		    }
		if (e.target.id === 'ph-open-amusement-btn') {
		    showGameSelectionModal();
		}
	});
	
	// 【新增】为同人论坛的“添加角色”按钮和标签容器绑定事件
	    const addCharBtn = get('fanfic-add-char-btn');
	    if (addCharBtn) {
	        addCharBtn.addEventListener('click', openCharSelectModal);
	    }
	    const pillsContainer = get('fanfic-char-pills-container');
	    if (pillsContainer) {
	        // 使用事件委托，处理标签上“x”按钮的点击事件
	        pillsContainer.addEventListener('click', (e) => {
	            if (e.target.classList.contains('fanfic-char-pill-remove')) {
	                const nameToRemove = e.target.dataset.name;
	                selectedFanficChars = selectedFanficChars.filter(name => name !== nameToRemove);
	                renderSelectedCharPills(); // 移除后立即重新渲染标签
	            }
	        });
	    }
		
	  const toggleSearchBtn = get('toggle-fanfic-search-btn');
	      const searchContainer = get('fanfic-search-container');
	      if (toggleSearchBtn && searchContainer) {
	          toggleSearchBtn.addEventListener('click', () => {
	              // 我们不再使用 display: none, 而是切换一个 .open 类
	              const isOpen = searchContainer.classList.toggle('open');
	              
	              // 为了更好的可访问性，我们可以更新按钮的标题
	              toggleSearchBtn.title = isOpen ? '收起筛选' : '展开筛选';
	              
	              // 同时，我们把按钮的颜色也改一下，提示用户当前的状态
	              toggleSearchBtn.style.color = isOpen ? 'var(--accent-color)' : 'var(--primary-text)';
	          });
	      }
		  
    initialize();

});
</script>
<script>
    // JS 动态适配手机浏览器工具栏高度
    document.addEventListener('DOMContentLoaded', () => {

        const phoneContainer = document.querySelector('.phone-container');

        function setAppHeight() {
            if (phoneContainer) {
                const vh = window.innerHeight;
                phoneContainer.style.height = vh + 'px';
            }
        }

        setAppHeight(); // 页面加载时执行
        window.addEventListener('resize', setAppHeight); // 窗口变化时执行
        window.addEventListener('orientationchange', setAppHeight); // 横竖屏切换时执行
    });
</script>
</body>
</html>


